<!-- index.html -->
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Atendimento de Enfermagem</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: Arial, Helvetica, sans-serif;
      margin: 0;
      padding: 0;
      background: #f5f5f5;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    .page {
      width: 100%;
      max-width: 800px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin: 20px 0 10px 0;
      text-align: center;
    }
    .center-card {
      background: #ffffff;
      border-radius: 16px;
      padding: 30px 20px 25px 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 420px;
      margin-top: 10px;
    }

    .live-guidance {
      width: 100%;
      background: #f9fbff;
      border: 1px solid #d7e6ff;
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 14px;
    }
    .live-guidance-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }
    .live-guidance-title {
      font-weight: bold;
      font-size: 13px;
      color: #0c5460;
      margin: 0;
    }
    .live-guidance-context {
      font-size: 12px;
      color: #555;
      text-align: right;
      margin: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 55%;
    }
    .live-guidance-status {
      font-size: 12px;
      color: #555;
      margin: 0 0 8px 0;
      min-height: 16px;
    }
    .live-guidance-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .live-guidance-item {
      background: #ffffff;
      border-radius: 10px;
      border: 1px solid #e4eefc;
      padding: 8px;
      font-size: 13px;
      line-height: 1.35;
      color: #1f2937;
    }
    .live-guidance-empty {
      font-size: 12px;
      color: #666;
      background: #ffffff;
      border-radius: 10px;
      border: 1px dashed #c8d8f5;
      padding: 8px;
    }
    .live-guidance-item-text {
      margin-bottom: 6px;
    }
    .live-guidance-item-actions {
      display: flex;
      justify-content: flex-end;
    }
    .mini-red-btn {
      border: none;
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 12px;
      color: #fff;
      cursor: pointer;
    }
    .mini-red-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    #recordBtn {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      font-size: 20px;
      font-weight: bold;
      color: #fff;
      margin-bottom: 10px;
      transition: background 0.2s, transform 0.1s;
    }
    #recordBtn.start {
      background: #28a745;
    }
    #recordBtn.recording {
      background: #dc3545;
    }
    #recordBtn:active {
      transform: scale(0.97);
    }
    #startNotice {
      font-size: 13px;
      color: #555;
      text-align: center;
      margin-top: 8px;
      margin-bottom: 8px;
    }
    #timer {
      font-size: 26px;
      margin-top: 16px;
      font-family: "Courier New", monospace;
    }
    #micStatus {
      margin-top: 8px;
      font-size: 14px;
      text-align: center;
      color: #333;
      min-height: 20px;
    }
    .controls-row {
      margin-top: 12px;
      display: flex;
      gap: 8px;
      align-items: center;
    }
    #pauseBtn {
      padding: 6px 14px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: #6c757d;
      color: #fff;
      font-size: 13px;
      display: none;
    }
    #pauseLabel {
      font-size: 12px;
      color: #555;
      margin-top: 6px;
      text-align: center;
    }
    #finishHint {
      font-size: 12px;
      color: #555;
      margin-top: 10px;
      text-align: center;
    }
    .results-card {
      background: #ffffff;
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      width: 100%;
      max-width: 800px;
      margin-top: 20px;
    }
    .results-card h2 {
      margin-top: 0;
    }
    .error {
      color: #b00020;
      margin-top: 8px;
      font-size: 13px;
      text-align: center;
    }
    .loading-dot::after {
      content: "...";
      animation: dots 1s steps(3, end) infinite;
    }
    @keyframes dots {
      0% { content: ""; }
      33% { content: "."; }
      66% { content: ".."; }
      100% { content: "..."; }
    }

    .soap-block {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 10px;
      background: #fafafa;
    }
    .soap-block-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }
    .soap-label {
      font-weight: bold;
      font-size: 14px;
    }
    .soap-textarea {
      width: 100%;
      min-height: 60px;
      resize: vertical;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #ddd;
      font-size: 14px;
      font-family: inherit;
      background: #ffffff;
    }
    .copy-soap-btn {
      padding: 4px 8px;
      border-radius: 12px;
      border: 1px solid #0c5460;
      background: #ffffff;
      color: #0c5460;
      font-size: 12px;
      cursor: pointer;
    }
    .copy-soap-btn:hover {
      background: #e6f2f5;
    }

    .prescription-textarea {
      width: 100%;
      min-height: 140px;
      resize: vertical;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #ddd;
      font-size: 14px;
      font-family: inherit;
      background: #fafafa;
      white-space: pre-wrap;
    }

    .prescription-actions {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    #copyPrescriptionBtn,
    #copyHospitalPrescriptionBtn,
    #printHospitalPrescriptionBtn,
    #generateHospitalPrescriptionBtn,
    #copySaeBtn,
    #printPregnancyBtn,
    #printLactationBtn,
        #copyFullSoapBtn,
    #printSoapBtn,
    #updateInteractionsBtn,
    #printInteractionsBtn
{
      padding: 8px 18px;
      border-radius: 20px;
      border: 1px solid #0c5460;
      background: #ffffff;
      color: #0c5460;
      font-size: 14px;
      cursor: pointer;
    }
    #copyPrescriptionBtn:hover,
    #copyHospitalPrescriptionBtn:hover,
    #printHospitalPrescriptionBtn:hover,
    #generateHospitalPrescriptionBtn:hover,
    #copySaeBtn:hover,
    #printPregnancyBtn:hover,
    #printLactationBtn:hover,
        #copyFullSoapBtn:hover,
    #printSoapBtn:hover,
    #updateInteractionsBtn:hover,
    #printInteractionsBtn:hover
{
      background: #e6f2f5;
    }

    #printBtn {
      margin-top: 0;
      padding: 8px 18px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: #0c5460;
      color: #fff;
      font-size: 14px;
      display: none;
    }

    #recommendationsBtn {
      margin-left: 0;
      padding: 8px 18px;
      border-radius: 20px;
      border: 1px solid #dc3545;
      background: #dc3545;
      color: #fff;
      cursor: pointer;
      font-size: 14px;
    }
    #recommendationsBtn:hover {
      background: #c82333;
      border-color: #c82333;
    }

    
    #generateHospitalPrescriptionBtn {
      border: 1px solid #dc3545;
      background: #dc3545;
      color: #fff;
    }
    #generateHospitalPrescriptionBtn:hover {
      background: #c82333;
      border-color: #c82333;
    }
.soap-title-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .recommendations-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 360px;
      max-width: 100%;
      height: 100vh;
      background: #ffffff;
      box-shadow: -2px 0 8px rgba(0,0,0,0.15);
      display: none;
      flex-direction: column;
      padding: 16px;
      z-index: 1000;
    }
    .recommendations-panel.visible {
      display: flex;
    }
    .recommendations-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .recommendations-header h3 {
      margin: 0;
      font-size: 16px;
    }
    .close-panel-btn {
      border: none;
      background: transparent;
      font-size: 18px;
      cursor: pointer;
      padding: 4px 8px;
    }
    .recommendations-status {
      font-size: 13px;
      color: #555;
      margin-bottom: 8px;
    }
    .recommendations-list {
      flex: 1;
      overflow-y: auto;
      margin-bottom: 12px;
      font-size: 14px;
    }
    .recommendation-item {
      background: #f5f5f5;
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 6px;
    }
    .ask-questions-btn {
      padding: 8px 16px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: #007bff;
      color: #fff;
      font-size: 14px;
    }
    .ask-questions-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .recommendations-footer {
      font-size: 11px;
      color: #666;
      margin-top: 8px;
    }

    .questions-timer {
      font-size: 18px;
      margin-top: 10px;
      font-family: "Courier New", monospace;
      text-align: center;
      color: #333;
    }

    .mini-status {
      margin-top: 6px;
      font-size: 12px;
      color: #555;
      min-height: 16px;
    }

    .classification-box {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 10px;
      background: #fafafa;
      white-space: pre-wrap;
      font-size: 14px;
      line-height: 1.35;
      min-height: 48px;
    }

    .risk-triage-box {
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 12px;
      background: #fafafa;
    }
    .risk-triage-current {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    .risk-badge {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      color: #fff;
      font-weight: bold;
      font-size: 13px;
      min-width: 120px;
      text-align: center;
    }
    .risk-none { background: #6c757d; }
    .risk-vermelho { background: #dc3545; }
    .risk-laranja { background: #fd7e14; }
    .risk-amarelo { background: #ffc107; color: #1f2937; }
    .risk-verde { background: #28a745; }
    .risk-azul { background: #0d6efd; }

    .risk-meaning {
      font-size: 14px;
      line-height: 1.35;
      color: #1f2937;
      white-space: pre-wrap;
      flex: 1;
      min-width: 180px;
    }

    .risk-legend {
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 13px;
      color: #1f2937;
    }
    .risk-legend-row {
      display: flex;
      align-items: flex-start;
      gap: 10px;
    }
    .risk-legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 4px;
      margin-top: 2px;
      flex: 0 0 14px;
    }
    .swatch-vermelho { background: #dc3545; }
    .swatch-laranja { background: #fd7e14; }
    .swatch-amarelo { background: #ffc107; }
    .swatch-verde { background: #28a745; }
    .swatch-azul { background: #0d6efd; }


    .section-header-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .section-header-row h2 {
      margin: 0;
    }

    .module-card {
      background: #ffffff;
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      width: 100%;
      max-width: 800px;
      margin-top: 20px;
    }
    .module-card h2 {
      margin-top: 0;
    }
    .inline-input-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 10px;
    }
    .text-input {
      flex: 1;
      min-width: 220px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #ddd;
      font-size: 14px;
      font-family: inherit;
      background: #ffffff;
    }
    .answer-box {
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 12px;
      background: #fafafa;
      white-space: pre-wrap;
      font-size: 14px;
      line-height: 1.4;
      min-height: 70px;
      margin-top: 12px;
    }
    .small-record-btn {
      padding: 10px 16px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      color: #fff;
      transition: background 0.2s, transform 0.1s;
    }
    .small-record-btn.start {
      background: #28a745;
    }
    .small-record-btn.recording {
      background: #dc3545;
    }
    .small-record-btn:active {
      transform: scale(0.98);
    }
    .report-actions {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    @media (max-width: 480px) {
      #recordBtn {
        width: 150px;
        height: 150px;
        font-size: 18px;
      }
      .prescription-actions {
        flex-direction: column;
        align-items: flex-start;
      }
    }

    .hidden {
      display: none !important;
    }
  

    .patientinfo-panel {
      border: 1px solid #e6e6e6;
      border-radius: 10px;
      padding: 12px;
      margin-bottom: 12px;
      background: #fafafa;
    }
    .patientinfo-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .mini-timer {
      font-size: 16px;
      font-weight: bold;
      min-width: 64px;
    }
    .patient-summary {
      margin-top: 8px;
      font-size: 14px;
      color: #333;
      white-space: pre-wrap;
    }


  
    #patientInfoBtn {
      background: #b00020;
      border-color: #b00020;
    }
    #patientInfoBtn:hover {
      filter: brightness(0.95);
    }

  
    .photo-btn {
      background: #dc3545;
      border: none;
      color: #fff;
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
    }
    .photo-btn:hover {
      filter: brightness(0.95);
    }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.45);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      padding: 16px;
    }
    .modal {
      background: #fff;
      border-radius: 14px;
      width: 100%;
      max-width: 420px;
      padding: 16px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.25);
    }
    .modal h3 {
      margin: 0 0 8px 0;
      font-size: 16px;
    }
    .modal p {
      margin: 0 0 12px 0;
      font-size: 13px;
      color: #555;
    }
    .modal-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .modal-actions button {
      flex: 1 1 140px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #d1d5db;
      background: #f9fafb;
      cursor: pointer;
      font-weight: 600;
    }
    .modal-actions button.primary {
      background: #2563eb;
      color: #fff;
      border-color: #2563eb;
    }
    .modal-actions button.danger {
      background: #dc3545;
      color: #fff;
      border-color: #dc3545;
    }
    .hidden-input {
      display: none !important;
    }

    .consult-type-panel {
      width: 100%;
      background: #ffffff;
      border-radius: 12px;
      border: 1px solid #e5e7eb;
      padding: 12px;
      margin-bottom: 12px;
    }
    .consult-type-title {
      margin: 0 0 10px 0;
      font-weight: bold;
      font-size: 13px;
      color: #111827;
    }
    .consult-type-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 10px;
    }
    .consult-type-btn {
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid #0c5460;
      background: #ffffff;
      color: #0c5460;
      font-size: 13px;
      cursor: pointer;
      flex: 1 1 160px;
      text-align: center;
      font-weight: 600;
    }
    .consult-type-btn:hover {
      background: #e6f2f5;
    }
    .consult-type-btn.active {
      background: #0c5460;
      color: #ffffff;
    }
    .consult-guide-drawer {
      width: 100%;
      background: #f9fbff;
      border: 1px solid #d7e6ff;
      border-radius: 12px;
      padding: 12px;
    }
    .consult-guide-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 10px;
      margin-bottom: 10px;
    }
    .consult-guide-title {
      font-weight: bold;
      font-size: 14px;
      color: #0c5460;
      margin: 0 0 4px 0;
    }
    .consult-guide-subtitle {
      font-size: 12px;
      color: #555;
      margin: 0;
    }
    .consult-guide-close {
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid #d1d5db;
      background: #ffffff;
      cursor: pointer;
      font-weight: 600;
      font-size: 12px;
    }
    .trimester-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin: 8px 0 10px 0;
    }
    .trimester-btn {
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid #0c5460;
      background: #ffffff;
      color: #0c5460;
      font-size: 12px;
      cursor: pointer;
      font-weight: 600;
    }
    .trimester-btn.active {
      background: #0c5460;
      color: #ffffff;
    }
    .consult-guide-content {
      font-size: 13px;
      color: #111827;
      line-height: 1.4;
    }
    .guide-section-title {
      font-weight: bold;
      margin: 10px 0 6px 0;
      color: #111827;
    }
    .consult-guide-content ol {
      margin: 0 0 6px 18px;
      padding: 0;
    }
    .consult-guide-content li {
      margin: 0 0 6px 0;
    }


  
    /* Padronização de botões de copiar e imprimir */
    .btn-copy {
      padding: 8px 18px;
      border-radius: 20px;
      border: 1px solid #fd7e14 !important;
      background: #fd7e14 !important;
      color: #ffffff !important;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.05s, opacity 0.15s;
    }
    .btn-copy:hover { opacity: 0.92; }
    .btn-copy:active { transform: scale(0.98); }

    .btn-print {
      padding: 8px 18px;
      border-radius: 20px;
      border: 1px solid #0d6efd !important;
      background: #0d6efd !important;
      color: #ffffff !important;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.05s, opacity 0.15s;
    }
    .btn-print:hover { opacity: 0.92; }
    .btn-print:active { transform: scale(0.98); }

    /* Botões "Copiar" por seção do SOAP (mesma identidade visual, tamanho menor) */
    .copy-soap-btn {
      border: 1px solid #fd7e14 !important;
      background: #fd7e14 !important;
      color: #ffffff !important;
      border-radius: 20px;
      padding: 4px 10px;
      font-size: 12px;
      cursor: pointer;
    }
    .copy-soap-btn:hover { opacity: 0.92; }

    /* Botão flutuante de contato via WhatsApp */
    .whatsapp-fab {
      position: fixed;
      right: 18px;
      bottom: 18px;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: none;
      background: #25D366;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 8px 18px rgba(0,0,0,0.20);
      cursor: pointer;
      text-decoration: none;
      z-index: 2000;
    }
    .whatsapp-fab:active { transform: scale(0.98); }
    .whatsapp-fab svg { width: 28px; height: 28px; fill: #ffffff; }
    .whatsapp-fab-label {
      position: fixed;
      right: 84px;
      bottom: 28px;
      background: #ffffff;
      border: 1px solid #e5e7eb;
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 12px;
      color: #111827;
      box-shadow: 0 6px 16px rgba(0,0,0,0.12);
      z-index: 2000;
      user-select: none;
    }
    @media (max-width: 520px) {
      .whatsapp-fab-label { display: none; }
    }

  
    /* =========================
       AUTENTICAÇÃO E ADMIN
       ========================= */
    .auth-shell {
      min-height: 100vh;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 20px;
    }
    .auth-card {
      width: 100%;
      max-width: 420px;
      background: #ffffff;
      border-radius: 16px;
      padding: 26px 20px 20px 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      margin-top: 40px;
    }
    .auth-subtitle {
      margin-top: 6px;
      margin-bottom: 16px;
      font-size: 13px;
      color: #555;
    }
    .auth-label {
      width: 100%;
      display: block;
      margin: 10px 0 6px 0;
      font-size: 13px;
      color: #333;
      font-weight: bold;
    }
    .auth-input {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #ddd;
      font-size: 14px;
      outline: none;
      background: #fff;
    }
    .auth-btn {
      width: 100%;
      margin-top: 14px;
      padding: 10px 12px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      background: #0c5460;
      color: #fff;
      font-size: 14px;
      font-weight: 700;
    }
    .auth-btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .auth-error {
      margin-top: 10px;
      font-size: 13px;
      color: #b00020;
      min-height: 18px;
    }
    .auth-help {
      margin-top: 12px;
      font-size: 12px;
      color: #666;
    }

    .nurse-bar {
      width: 100%;
      border: 1px solid #e5e7eb;
      border-radius: 14px;
      background: #ffffff;
      padding: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }
    .nurse-bar-line { font-size: 13px; color: #111827; }
    .nurse-bar-label { color: #6b7280; font-weight: 700; margin-right: 6px; }
    .nurse-bar-actions { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .danger-btn {
      padding: 10px 14px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      background: #dc3545;
      color: #fff;
      font-weight: 800;
      font-size: 13px;
    }
    .pill {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      border: 1px solid #ddd;
      background: #f2f2f2;
      color: #555;
      font-weight: 800;
      white-space: nowrap;
    }
    .pill.green { background: #e7f7ec; border-color: #bfe8c9; color: #145a22; }
    .pill.red { background: #fde8ea; border-color: #f3c2c7; color: #7a1420; }

    .admin-shell {
      width: 100%;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    .admin-wrap {
      width: 100%;
      max-width: 980px;
    }
    .admin-card {
      background: #ffffff;
      border-radius: 16px;
      padding: 18px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      margin-top: 14px;
    }
    .admin-row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .admin-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }
    @media (max-width: 720px) {
      .admin-grid { grid-template-columns: 1fr; }
    }
    .admin-field label {
      display: block;
      font-size: 12px;
      color: #555;
      margin: 0 0 6px 0;
      font-weight: 700;
    }
    .admin-field input {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid #ddd;
      font-size: 14px;
      outline: none;
    }
    .admin-btn {
      padding: 10px 14px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      background: #0c5460;
      color: #fff;
      font-weight: 800;
      font-size: 13px;
    }
    .admin-btn.secondary { background: #6c757d; }
    .admin-btn.danger { background: #dc3545; }
    .admin-status {
      margin-top: 10px;
      font-size: 12px;
      color: #333;
      min-height: 18px;
      white-space: pre-wrap;
    }
    .admin-table-wrap { overflow-x: auto; margin-top: 10px; }
    table.admin-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }
    table.admin-table th, table.admin-table td {
      border-bottom: 1px solid #eee;
      padding: 10px 8px;
      text-align: left;
      vertical-align: top;
      white-space: nowrap;
    }
    table.admin-table th { background: #f7f7f7; font-weight: 900; }
    .admin-actions { display: flex; gap: 8px; flex-wrap: wrap; }
    .admin-actions button { padding: 8px 10px; border-radius: 10px; font-size: 12px; }
    .modal-overlay.hidden { display: none; }


    .admin-form-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;}
    @media (max-width: 720px){.admin-form-grid{grid-template-columns:1fr;}}


    /* Ajustes visuais e responsividade (computador e celular) */
    .page { width: 100%; }
    .center-card, .results-card, .admin-card { width: 100%; }
    input, textarea, select { max-width: 100%; }

    .nurse-bar {
      width: 100%;
      max-width: 900px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      padding: 12px 14px;
      border-radius: 14px;
      background: #ffffff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.10);
      margin: 10px auto 14px auto;
    }
    .nurse-bar-line { margin: 2px 0; }

    .consult-type-btn { white-space: normal; }

    @media (max-width: 720px) {
      body { align-items: flex-start; }
      .page { padding: 12px; }
      h1 { font-size: 26px; margin-top: 14px; }
      .center-card { padding: 18px 14px; max-width: 100%; }
      .results-card { padding: 16px 14px; }
      .nurse-bar { flex-direction: column; align-items: flex-start; }
      .nurse-bar-actions { width: 100%; display: flex; justify-content: flex-end; }
      .consult-type-buttons { flex-direction: column; }
      .consult-type-btn { width: 100%; text-align: left; }
      .admin-row { flex-wrap: wrap; }
      .admin-btn { width: 100%; justify-content: center; }
      .admin-table-wrap { border: 1px solid #eee; border-radius: 12px; }
    }

    @media (max-width: 420px) {
      .page { padding: 10px; }
      h1 { font-size: 24px; }
      #recordBtn { width: 145px; height: 145px; }
    }

</style>
</head>
<body>

  <div id="loginView" class="auth-shell">
    <div class="auth-card">
      <h1>Atendimento de Enfermagem</h1>
      <p class="auth-subtitle">Acesso restrito para profissionais cadastrados.</p>

      <label class="auth-label" for="loginField">Login</label>
      <input id="loginField" class="auth-input" autocomplete="username" inputmode="text" />

      <label class="auth-label" for="passwordField">Senha</label>
      <input id="passwordField" class="auth-input" type="password" autocomplete="current-password" />

      <button id="loginBtn" class="auth-btn" type="button">Entrar</button>
      <div id="loginError" class="auth-error"></div>

      <div class="auth-help">
        Se não conseguir acessar, use o botão “Entrar em contato”.
      </div>
    </div>
  </div>


  <div id="adminView" class="admin-shell hidden">
    <div class="admin-wrap">
      <div class="admin-row" style="justify-content: space-between; align-items: flex-end;">
        <div>
          <h1 style="margin: 10px 0 4px 0;">Painel do Administrador</h1>
          <div id="adminSubtitle" style="font-size: 12px; color: #555;"></div>
          <div id="adminLocalBackupInfo" style="font-size: 12px; color: #555; margin-top: 2px;"></div>
        </div>
        <div class="admin-row">
          <button id="adminRefreshBtn" class="admin-btn secondary" type="button">Atualizar</button>
          <button id="adminBackupBtn" class="admin-btn secondary" type="button">Baixar backup</button>
          <button id="adminRestoreBtn" class="admin-btn secondary" type="button">Restaurar backup</button>
          <input id="adminRestoreFile" type="file" accept="application/json" style="display:none" />
          <button id="adminLogoutBtn" class="admin-btn danger" type="button">Sair</button>
        </div>
      </div>

      <div class="admin-card">
        <h2 style="margin: 0 0 10px 0;">Cadastrar enfermeiro(a)</h2>
        <div class="admin-grid">
          <div class="admin-field">
            <label for="newFullName">Nome completo</label>
            <input id="newFullName" type="text" />
          </div>
          <div class="admin-field">
            <label for="newDob">Data de nascimento</label>
            <input id="newDob" type="date" />
          </div>
          <div class="admin-field">
            <label for="newPhone">Telefone</label>
            <input id="newPhone" type="tel" />
          </div>
          <div class="admin-field">
            <label for="newLogin">Login</label>
            <input id="newLogin" type="text" />
          </div>
          <div class="admin-field">
            <label for="newPassword">Senha</label>
            <input id="newPassword" type="text" />
          </div>
          <div class="admin-field" style="display:flex; align-items:flex-end;">
            <button id="createUserBtn" class="admin-btn" type="button" style="width:100%;">Cadastrar</button>
          </div>
        </div>
        <div id="createUserStatus" class="admin-status"></div>
      </div>

      <div class="admin-card">
        <div class="admin-row" style="justify-content: space-between;">
          <h2 style="margin: 0;">Enfermeiros cadastrados</h2>
          <input id="adminSearch" class="auth-input" placeholder="Buscar por nome, login ou telefone" style="max-width: 360px;" />
        </div>
        <div class="admin-table-wrap">
          <table class="admin-table">
            <thead>
              <tr>
                <th>Nome</th>
                <th>Login</th>
                <th>Telefone</th>
                <th>Online</th>
                <th>Mensalidade</th>
                <th>Último login</th>
                <th>Ações</th>
              </tr>
            </thead>
            <tbody id="usersTbody"></tbody>
          </table>
        </div>
        <div id="adminStatus" class="admin-status"></div>
      </div>

      <div class="admin-card">
        <h2 style="margin: 0 0 10px 0;">Auditoria administrativa (somente leitura)</h2>
        <div class="admin-table-wrap">
          <table class="admin-table">
            <thead>
              <tr>
                <th>Data/Hora</th>
                <th>Ação</th>
                <th>Alvo</th>
                <th>Detalhes</th>
              </tr>
            </thead>
            <tbody id="auditTbody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <div id="paymentsModal" class="modal-overlay hidden">
    <div class="modal" style="max-width: 720px;">
      <h3 style="margin:0 0 8px 0;">Histórico de pagamentos</h3>
      <p id="paymentsModalSubtitle" style="margin:0 0 10px 0; font-size: 12px; color: #555;"></p>
      <div class="admin-table-wrap" style="max-height: 55vh; overflow:auto;">
        <table class="admin-table">
          <thead>
            <tr>
              <th>Mês</th>
              <th>Pago em</th>
              <th>Valor</th>
              <th>Método</th>
              <th>Observações</th>
            </tr>
          </thead>
          <tbody id="paymentsTbody"></tbody>
        </table>
      </div>
      <div class="admin-row" style="justify-content:flex-end; margin-top: 12px;">
        <button id="closePaymentsBtn" class="admin-btn secondary" type="button">Fechar</button>
      </div>
      <div style="margin-top: 10px; font-size: 12px; color: #666;">Este histórico é permanente. Não há opção de editar ou apagar registros.</div>
    </div>
    <div id="editUserModal" class="modal-overlay hidden">
    <div class="modal" style="max-width: 720px;">
      <h3 style="margin:0 0 8px 0;">Editar enfermeiro(a)</h3>
      <p id="editUserSubtitle" style="margin:0 0 10px 0; font-size: 12px; color: #555;"></p>

      <div class="admin-form-grid">
        <div>
          <label class="auth-label">Nome completo</label>
          <input id="editFullName" class="auth-input" placeholder="Nome completo" />
        </div>
        <div>
          <label class="auth-label">Data de nascimento</label>
          <input id="editDob" class="auth-input" placeholder="dd/mm/aaaa" />
        </div>
        <div>
          <label class="auth-label">Telefone</label>
          <input id="editPhone" class="auth-input" placeholder="Telefone" />
        </div>
        <div>
          <label class="auth-label">Login</label>
          <input id="editLogin" class="auth-input" placeholder="Login" />
        </div>
        <div style="grid-column: 1 / -1;">
          <label class="auth-label">Nova senha (opcional)</label>
          <input id="editPassword" class="auth-input" placeholder="Deixe em branco para não alterar" />
          <div style="margin-top:6px; font-size: 12px; color:#666;">Se preencher, a senha será atualizada. O histórico de pagamentos não é alterado.</div>
        </div>
      </div>

      <div class="admin-row" style="justify-content:flex-end; margin-top: 14px;">
        <button id="cancelEditUserBtn" class="admin-btn secondary" type="button">Cancelar</button>
        <button id="saveEditUserBtn" class="admin-btn" type="button" style="margin-left: 10px;">Salvar</button>
      </div>
    </div>
  </div>

</div>

  <div id="nurseView" class="hidden">
  <div class="page">
    <h1>Atendimento de Enfermagem</h1>


    <div class="nurse-bar" id="nurseBar">
      <div>
        <div class="nurse-bar-line"><span class="nurse-bar-label">Usuário:</span><span id="nurseUserLabel">-</span></div>
        <div class="nurse-bar-line"><span class="nurse-bar-label">Login:</span><span id="nurseLoginLabel">-</span></div>
        <div class="nurse-bar-line"><span class="nurse-bar-label">Mensalidade:</span><span id="nursePaymentLabel" class="pill">-</span></div>
      </div>
      <div class="nurse-bar-actions">
        <button id="nurseLogoutBtn" type="button" class="danger-btn">Sair</button>
      </div>
    </div>


    <div class="center-card">

      <div id="consultTypePanel" class="consult-type-panel">
        <p class="consult-type-title">Guias de consulta</p>
        <div class="consult-type-buttons">
          <button class="consult-type-btn" type="button" data-consult="prenatal">Consulta pré-natal por trimestre</button>
          <button class="consult-type-btn" type="button" data-consult="puericultura">Consulta puericultura</button>
          <button class="consult-type-btn" type="button" data-consult="planejamento">Consulta planejamento familiar</button>
          <button class="consult-type-btn" type="button" data-consult="hiperdia">Consulta hiperdia</button>
          <button class="consult-type-btn" type="button" data-consult="puerperio">Consulta de puerpério</button>
        </div>

        <div id="consultGuideDrawer" class="consult-guide-drawer hidden">
          <div class="consult-guide-header">
            <div>
              <p id="consultGuideTitle" class="consult-guide-title"></p>
              <p id="consultGuideSubtitle" class="consult-guide-subtitle"></p>
            </div>
            <button id="closeConsultGuideBtn" class="consult-guide-close" type="button">Fechar</button>
          </div>

          <div id="prenatalTrimesterRow" class="trimester-row hidden">
            <button class="trimester-btn" type="button" data-tri="1">1º trimestre</button>
            <button class="trimester-btn" type="button" data-tri="2">2º trimestre</button>
            <button class="trimester-btn" type="button" data-tri="3">3º trimestre</button>
          </div>

          <div id="consultGuideContent" class="consult-guide-content"></div>
        </div>
      </div>

      <div id="liveGuidance" class="live-guidance">
        <div class="live-guidance-header">
          <p class="live-guidance-title">Perguntas e procedimentos essenciais</p>
          <p id="liveGuidanceContext" class="live-guidance-context"></p>
        </div>
        <p id="liveGuidanceStatus" class="live-guidance-status">Inicie o atendimento para receber perguntas e procedimentos necessários em tempo real.</p>
        <div id="liveGuidanceList" class="live-guidance-list">
          <div class="live-guidance-empty">Nenhuma sugestão por enquanto.</div>
        </div>
      </div>

      <button id="recordBtn" class="start">Iniciar atendimento</button>

      <p id="startNotice">
        Assim que iniciar a gravação, informe sempre o nome completo do paciente, idade, peso e sinais vitais (PA, FC, FR, SpO2 e temperatura) para que o SOAP e a prescrição sejam gerados corretamente.
      </p>

      <div id="timer">00:00</div>
      <div id="micStatus">Clique em "Iniciar atendimento" para começar.</div>

      <div class="controls-row">
        <button id="pauseBtn">Pausar</button>
      </div>
      <div id="pauseLabel">Use o botão pequeno para pausar e retomar a consulta.</div>

      <div id="finishHint">
        Para encerrar a consulta e gerar o SOAP, clique novamente no botão grande vermelho.
      </div>

      <div id="soapError" class="error"></div>
    </div>

    <div id="resultsCard" class="results-card hidden">

      <div id="patientInfoPanel" class="patientinfo-panel">
        <div class="patientinfo-row">
          <button id="patientInfoBtn" class="small-record-btn">Coletar dados essenciais</button>
          <div id="patientInfoTimer" class="mini-timer">00:00</div>
          <div id="patientInfoStatus" class="mini-status"></div>
        </div>
        <div id="patientInfoSummary" class="patient-summary"></div>
      </div>


      <div class="section-header-row">
        <div class="soap-title-actions">
          <h2>SOAP</h2>
          <button id="copyFullSoapBtn" class="btn-copy">Copiar SOAP</button>
          <button id="printSoapBtn" class="btn-print">Imprimir SOAP</button>
        </div>
        <button id="recommendationsBtn">Perguntas essenciais</button>
      </div>

      <div class="soap-block">
        <div class="soap-block-header">
          <span class="soap-label">S</span>
          <button class="copy-soap-btn" data-part="S">Copiar</button>
        </div>
        <textarea id="soapS" class="soap-textarea"></textarea>
      </div>

      <div class="soap-block">
        <div class="soap-block-header">
          <span class="soap-label">O</span>
          <button class="copy-soap-btn" data-part="O">Copiar</button>
        </div>
        <textarea id="soapO" class="soap-textarea"></textarea>
      </div>

      <div class="soap-block">
        <div class="soap-block-header">
          <span class="soap-label">A</span>
          <button class="copy-soap-btn" data-part="A">Copiar</button>
        </div>
        <textarea id="soapA" class="soap-textarea"></textarea>
      </div>

      <div class="soap-block">
        <div class="soap-block-header">
          <span class="soap-label">P</span>
          <button class="copy-soap-btn" data-part="P">Copiar</button>
        </div>
        <textarea id="soapP" class="soap-textarea"></textarea>
      </div>

      <h2>Plano de Cuidados (Prescrição de Enfermagem)</h2>
      <textarea id="prescriptionOutput" class="prescription-textarea"></textarea>

      <div class="prescription-actions">
        <button id="copyPrescriptionBtn" class="btn-copy">Copiar plano de cuidados</button>
        <button id="printBtn" class="btn-print">Imprimir plano de cuidados</button>
      </div>

      <h2>Passagem de Plantão (SBAR)</h2>
      <textarea id="hospitalPrescriptionOutput" class="prescription-textarea"></textarea>

      <div class="prescription-actions">
        <button id="generateHospitalPrescriptionBtn">Gerar SBAR</button>
        <button id="copyHospitalPrescriptionBtn" class="btn-copy">Copiar plano de cuidados hospitalar</button>
        <button id="printHospitalPrescriptionBtn" class="btn-print">Imprimir plano de cuidados hospitalar</button>
      </div>
      <div id="hospitalPrescriptionStatus" class="mini-status"></div>


      <h2>Classificação de risco por cores</h2>
      <div class="risk-triage-box">
        <div class="risk-triage-current">
          <span id="riskTriageBadge" class="risk-badge risk-none">Não informado</span>
          <div id="riskTriageMeaning" class="risk-meaning">Nenhum conteúdo disponível.</div>
        </div>
        <div id="riskTriageLegend" class="risk-legend"></div>
      </div>
      <div class="prescription-actions">
        <button id="copyRiskTriageBtn" class="btn-copy">Copiar classificação de risco</button>
        <button id="printRiskTriageBtn" class="btn-print">Imprimir classificação de risco</button>
      </div>
      <div id="riskTriageStatus" class="mini-status"></div>

      <h2>SAE (Processo de Enfermagem)</h2>
      <div id="pregnancyBox" class="classification-box">Nenhum conteúdo disponível.</div>
      <div class="prescription-actions">
        <button id="copySaeBtn" class="btn-copy">Copiar SAE</button>
        <button id="printPregnancyBtn" class="btn-print">Imprimir SAE</button>
      </div>

      <h2>Orientações ao paciente</h2>
      <div id="lactationBox" class="classification-box">Nenhum conteúdo disponível.</div>
      <div class="prescription-actions">
        <button id="copyOrientationsBtn" class="btn-copy">Copiar orientações</button>
        <button id="printLactationBtn" class="btn-print">Imprimir orientações</button>
      </div>
<div id="classificationsStatus" class="mini-status"></div>
    </div>

    
    <div id="medSafetyCard" class="module-card">
      <h2>Administração segura de medicamentos (registro de enfermagem)</h2>
                  <p class="mini-status" style="margin-top: 0;">
        Use o botão para fotografar a prescrição médica. O sistema irá transcrever o que estiver legível, organizar os medicamentos, apontar riscos e inconsistências relevantes para a enfermagem e sinalizar interações importantes quando for possível confirmar com segurança.
      </p>
<div class="prescription-actions">
        <button id="medPhotoBtn" class="photo-btn">Tirar foto</button>
        <button id="copyMedSafetyBtn" class="btn-copy">Copiar segurança dos medicamentos</button>
        <button id="printMedSafetyBtn" class="btn-print">Imprimir segurança dos medicamentos</button>
      </div>

      <div id="interactionsStatus" class="mini-status"></div>
      <div id="interactionsBox" class="classification-box">Nenhum conteúdo disponível.</div>

      <input id="medCameraInput" class="hidden-input" type="file" accept="image/*" capture="environment" />
      <input id="medFileInput" class="hidden-input" type="file" accept="image/*" />
    </div>

    <div id="woundCard" class="module-card">
      <h2>Curativos e feridas</h2>
      <p class="mini-status" style="margin-top: 0;">
        Use o botão para fotografar a lesão. O sistema irá descrever apenas o que for visível na imagem e sugerir cuidados de enfermagem e prescrição de curativo de forma segura, sem inventar dados.
      </p>

      <div class="prescription-actions">
        <button id="woundPhotoBtn" class="photo-btn">Tirar foto</button>
        <button id="copyWoundBtn" class="btn-copy">Copiar prescrição e cuidados</button>
        <button id="printWoundBtn" class="btn-print">Imprimir prescrição e cuidados</button>
      </div>

      <div id="presentationsMaxDoseStatus" class="mini-status"></div>
      <div id="presentationsMaxDoseBox" class="classification-box">Nenhum conteúdo disponível.</div>

      <input id="woundCameraInput" class="hidden-input" type="file" accept="image/*" capture="environment" />
      <input id="woundFileInput" class="hidden-input" type="file" accept="image/*" />
    </div>

<div id="medicalDoubtsCard" class="module-card">
      <h2>Dúvidas de Enfermagem</h2>
      <p class="mini-status" style="margin-top: 0;">Digite sua dúvida e pressione Enter para obter uma resposta.</p>
      <input id="medicalDoubtInput" class="text-input" type="text" placeholder="Digite aqui sua dúvida médica e pressione Enter" autocomplete="off" />
      <div id="medicalDoubtStatus" class="mini-status"></div>
      <div id="medicalDoubtAnswer" class="answer-box"></div>
    </div>

                <div id="patientReportCard" class="module-card">
      <h2>Relatórios de Enfermagem / Encaminhamentos / Declarações / Solicitações / Comunicados / Atestado de comparecimento ou permanência / ATA reunião / Registros de procedimentos</h2>
      <p class="mini-status" style="margin-top: 0;">
        Grave em voz alta o conteúdo do documento. Diga claramente qual documento deseja produzir (por exemplo: declaração de comparecimento, relatório de curativo seriado, encaminhamento para CAPS, solicitação de insumos, comunicado para escola, ata de reunião). Ao encerrar, a gravação será usada para identificar o tipo de documento e gerar um texto padronizado pronto para colar no S.U.I.S.
      </p>

      <div class="inline-input-row">
        <label for="reportDocTypeSelect" style="font-size: 13px; color: #111827; font-weight: 600;">Tipo de documento:</label>
        <select id="reportDocTypeSelect" class="text-input" style="min-width: 260px; max-width: 100%;">          <option value="auto" selected>Auto (identificar pela gravação)</option>
          <option value="Declaração de comparecimento">Declaração de comparecimento</option>
          <option value="Declaração de permanência">Declaração de permanência</option>
          <option value="Declaração para acompanhante">Declaração para acompanhante</option>
          <option value="Declaração de recebimento de orientações">Declaração de recebimento de orientações</option>
          <option value="Declaração de recusa de procedimento/conduta">Declaração de recusa de procedimento/conduta</option>
          <option value="Termo de consentimento informado (procedimento de enfermagem)">Termo de consentimento informado (procedimento de enfermagem)</option>
          <option value="Termo de ciência e responsabilidade (orientações e riscos)">Termo de ciência e responsabilidade (orientações e riscos)</option>
          <option value="Comunicado para escola">Comunicado para escola</option>
          <option value="Relatório para escola (necessidades específicas)">Relatório para escola (necessidades específicas)</option>
          <option value="Comunicado ao Conselho Tutelar">Comunicado ao Conselho Tutelar</option>
          <option value="Relatório para Conselho Tutelar (proteção à criança/adolescente)">Relatório para Conselho Tutelar (proteção à criança/adolescente)</option>
          <option value="Relatório de curativo seriado">Relatório de curativo seriado</option>
          <option value="Registro de procedimento de curativo">Registro de procedimento de curativo</option>
          <option value="Registro de retirada de pontos/suturas">Registro de retirada de pontos/suturas</option>
          <option value="Registro de procedimento de vacinação">Registro de procedimento de vacinação</option>
          <option value="Registro de evento adverso pós-vacinação (EAPV)">Registro de evento adverso pós-vacinação (EAPV)</option>
          <option value="Registro de procedimento de administração de medicamentos">Registro de procedimento de administração de medicamentos</option>
          <option value="Registro de administração de medicamento controlado (registro interno)">Registro de administração de medicamento controlado (registro interno)</option>
          <option value="Registro de coleta de exames">Registro de coleta de exames</option>
          <option value="Registro de nebulização/oxigenoterapia">Registro de nebulização/oxigenoterapia</option>
          <option value="Registro de sondagem vesical">Registro de sondagem vesical</option>
          <option value="Registro de troca de sonda/traqueostomia/gastrostomia">Registro de troca de sonda/traqueostomia/gastrostomia</option>
          <option value="Registro de visita domiciliar">Registro de visita domiciliar</option>
          <option value="Relatório de visita domiciliar">Relatório de visita domiciliar</option>
          <option value="Relatório de adesão e educação em saúde (HAS/DM)">Relatório de adesão e educação em saúde (HAS/DM)</option>
          <option value="Relatório de acompanhamento de hipertensão (HAS)">Relatório de acompanhamento de hipertensão (HAS)</option>
          <option value="Relatório de acompanhamento de diabetes (DM)">Relatório de acompanhamento de diabetes (DM)</option>
          <option value="Relatório de acompanhamento de asma/DPOC">Relatório de acompanhamento de asma/DPOC</option>
          <option value="Relatório de acompanhamento de saúde da criança (puericultura)">Relatório de acompanhamento de saúde da criança (puericultura)</option>
          <option value="Relatório de acompanhamento de pré-natal (enfermagem)">Relatório de acompanhamento de pré-natal (enfermagem)</option>
          <option value="Relatório de puerpério (enfermagem)">Relatório de puerpério (enfermagem)</option>
          <option value="Relatório para assistência social (vulnerabilidade e insumos)">Relatório para assistência social (vulnerabilidade e insumos)</option>
          <option value="Solicitação de insumos (fraldas, curativos, suplementos)">Solicitação de insumos (fraldas, curativos, suplementos)</option>
          <option value="Solicitação de fraldas (infantil/geriátrica)">Solicitação de fraldas (infantil/geriátrica)</option>
          <option value="Solicitação de materiais para ostomia">Solicitação de materiais para ostomia</option>
          <option value="Solicitação de dieta enteral/suplementação">Solicitação de dieta enteral/suplementação</option>
          <option value="Solicitação de oxigenoterapia domiciliar">Solicitação de oxigenoterapia domiciliar</option>
          <option value="Solicitação de equipamentos de apoio (cadeira de rodas, colchão pneumático)">Solicitação de equipamentos de apoio (cadeira de rodas, colchão pneumático)</option>
          <option value="Solicitação de transporte sanitário">Solicitação de transporte sanitário</option>
          <option value="Solicitação de avaliação médica">Solicitação de avaliação médica</option>
          <option value="Encaminhamento para Médico (demanda espontânea)">Encaminhamento para Médico (demanda espontânea)</option>
          <option value="Encaminhamento para sala de vacina">Encaminhamento para sala de vacina</option>
          <option value="Encaminhamento para curativos/ambulatório de feridas">Encaminhamento para curativos/ambulatório de feridas</option>
          <option value="Encaminhamento para CAPS / saúde mental">Encaminhamento para CAPS / saúde mental</option>
          <option value="Relatório para CAPS / saúde mental (enfermagem)">Relatório para CAPS / saúde mental (enfermagem)</option>
          <option value="Encaminhamento para Serviço Social">Encaminhamento para Serviço Social</option>
          <option value="Encaminhamento para Psicologia">Encaminhamento para Psicologia</option>
          <option value="Encaminhamento para Nutrição">Encaminhamento para Nutrição</option>
          <option value="Encaminhamento para Fisioterapia">Encaminhamento para Fisioterapia</option>
          <option value="Encaminhamento para Fonoaudiologia">Encaminhamento para Fonoaudiologia</option>
          <option value="Encaminhamento para Odontologia">Encaminhamento para Odontologia</option>
          <option value="Encaminhamento para especialista / rede">Encaminhamento para especialista / rede</option>
          <option value="Encaminhamento para urgência/emergência">Encaminhamento para urgência/emergência</option>
          <option value="Relatório de evolução de enfermagem">Relatório de evolução de enfermagem</option>
          <option value="Relatório de intercorrência/ocorrência">Relatório de intercorrência/ocorrência</option>
          <option value="Ata de reunião">Ata de reunião</option>
          <option value="Registro de reunião de equipe (ATA breve)">Registro de reunião de equipe (ATA breve)</option>
          <option value="Comunicado interno da equipe">Comunicado interno da equipe</option>
          <option value="Outros">Outros</option>
</select>
      </div>

      <div class="inline-input-row">
        <button id="reportRecordBtn" class="small-record-btn start">Gravar documento</button>
        <button id="copyReportBtn" class="btn-copy" type="button">Copiar documento</button>
        <button id="printReportBtn" class="btn-print" type="button">Imprimir documento</button>
      </div>

      <div id="reportStatus" class="mini-status"></div>

      <div class="inline-input-row" style="margin-top: 6px;">
        <div style="flex: 1; min-width: 240px;">
          <div style="font-size: 12px; font-weight: 700; color: #111827; margin-bottom: 4px;">Tipo identificado</div>
          <div id="reportDocTypeDetected" class="answer-box" style="min-height: 44px;"></div>
        </div>
        <div style="flex: 1; min-width: 240px;">
          <div style="font-size: 12px; font-weight: 700; color: #111827; margin-bottom: 4px;">Campos pendentes</div>
          <div id="reportMissingFields" class="answer-box" style="min-height: 44px;"></div>
        </div>
      </div>

      <textarea id="reportOutput" class="prescription-textarea" placeholder="O documento gerado aparecerá aqui." style="margin-top: 12px;"></textarea>
    </div>

  </div>

  <div id="recommendationsPanel" class="recommendations-panel">
    <div class="recommendations-header">
      <h3>Perguntas essenciais para anamnese</h3>
      <button id="closeRecommendationsBtn" class="close-panel-btn" aria-label="Fechar painel de recomendações">X</button>
    </div>
    <div id="recommendationsStatus" class="recommendations-status">
      Clique em "Perguntas essenciais" para gerar perguntas complementares essenciais.
    </div>
    <div id="recommendationsList" class="recommendations-list"></div>
    <button id="askQuestionsBtn" class="ask-questions-btn" disabled>Complementar avaliação</button>
    <div id="questionsTimer" class="questions-timer hidden">00:00</div>
    <p class="recommendations-footer">
      Ao clicar em "Complementar avaliação", uma nova gravação será iniciada para você aplicar essas perguntas diretamente ao paciente.
      As respostas serão usadas para atualizar automaticamente o SOAP e a conduta.
    </p>
  </div>


  <div id="imageChoiceOverlay" class="modal-overlay hidden">
    <div class="modal">
      <h3>Selecionar imagem</h3>
      <p>Escolha uma opção.</p>
      <div class="modal-actions">
        <button id="chooseCameraBtn" class="danger">Tirar foto agora</button>
        <button id="chooseFileBtn" class="primary">Escolher arquivo</button>
        <button id="cancelImageChoiceBtn">Cancelar</button>
      </div>
    </div>
  </div>


  </div>

  <script>
    const BACKEND_URL = "https://consulta-enfermagem-1.onrender.com"; // usa /api (Netlify redirect) ou mesma origem no Render

    // =========================
    // AUTENTICAÇÃO (sem escolha de perfil)
    // =========================
    const TOKEN_KEY = "ae_token_v1";
    const nativeFetch = window.fetch.bind(window);

    // Backup local automático (para não perder clientes em redeploy/atualizações do backend)
    const LOCAL_BACKUP_KEY = "ae_local_backup_v1";
    const LOCAL_BACKUP_AT_KEY = "ae_local_backup_at_v1";
    let RECOVERY_TRIED = false;
    let RECOVERY_RUNNING = false;

    function setLocalBackupText(txt) {
      try {
        localStorage.setItem(LOCAL_BACKUP_KEY, txt || "");
        localStorage.setItem(LOCAL_BACKUP_AT_KEY, new Date().toISOString());
      } catch {}
    }
    function getLocalBackupText() {
      try { return localStorage.getItem(LOCAL_BACKUP_KEY) || ""; } catch { return ""; }
    }
    function getLocalBackupPayload() {
      const txt = getLocalBackupText();
      if (!txt) return null;
      try { return JSON.parse(txt); } catch { return null; }
    }
    function updateAdminLocalBackupBadge() {
      const el = document.getElementById("adminLocalBackupInfo");
      if (!el) return;
      let at = "";
      try { at = localStorage.getItem(LOCAL_BACKUP_AT_KEY) || ""; } catch {}
      if (!at) {
        el.textContent = "Backup local: não disponível";
        return;
      }
      try {
        el.textContent = "Backup local: " + new Date(at).toLocaleString("pt-BR");
      } catch {
        el.textContent = "Backup local: disponível";
      }
    }
    async function refreshLocalBackupFromServer() {
      try {
        const t = getToken();
        if (!t) return;
        const resp = await fetch(BACKEND_URL + "/api/admin/backup/export", { method: "GET" });
        if (!resp.ok) return;
        const txt = await resp.text();
        if (!txt || txt.trim().length < 2) return;
        if (!txt.trim().startsWith("{")) return;
        setLocalBackupText(txt);
        updateAdminLocalBackupBadge();
      } catch {}
    }

    function getToken() {
      try { return localStorage.getItem(TOKEN_KEY) || ""; } catch { return ""; }
    }
    function setToken(t) {
      try {
        if (t) localStorage.setItem(TOKEN_KEY, t);
        else localStorage.removeItem(TOKEN_KEY);
      } catch {}
    }

    function showLogin() {
      document.getElementById("loginView")?.classList.remove("hidden");
      document.getElementById("adminView")?.classList.add("hidden");
      document.getElementById("nurseView")?.classList.add("hidden");
      document.getElementById("paymentsModal")?.classList.add("hidden");
    }
    function showAdmin() {
      document.getElementById("loginView")?.classList.add("hidden");
      document.getElementById("adminView")?.classList.remove("hidden");
      document.getElementById("nurseView")?.classList.add("hidden");
    }
    function showNurse() {
      document.getElementById("loginView")?.classList.add("hidden");
      document.getElementById("adminView")?.classList.add("hidden");
      document.getElementById("nurseView")?.classList.remove("hidden");
    }

    // Intercepta chamadas ao backend e injeta Authorization quando for /api/
    window.fetch = async function(input, init) {
      try {
        const url = (typeof input === "string") ? input : (input && input.url) ? input.url : "";
        const isApi = typeof url === "string" && url.startsWith(BACKEND_URL + "/api/");
        if (!isApi) return nativeFetch(input, init);

        const headers = Object.assign({}, (init && init.headers) ? init.headers : {});
        const token = getToken();
        if (token) headers["Authorization"] = "Bearer " + token;
        const resp = await nativeFetch(input, Object.assign({}, init || {}, { headers }));

        if (resp && resp.status === 401) {
          setToken("");
          showLogin();
        }
        return resp;
      } catch (e) {
        return nativeFetch(input, init);
      }
    };

    async function authMe() {
      const resp = await fetch(BACKEND_URL + "/api/auth/me", { method: "GET" });
      if (!resp.ok) throw new Error("me failed");
      return await resp.json();
    }

    async function doLogin() {
      const login = (document.getElementById("loginField")?.value || "").trim();
      const senha = (document.getElementById("passwordField")?.value || "").trim();
      const errEl = document.getElementById("loginError");
      const btn = document.getElementById("loginBtn");
      if (!login || !senha) {
        if (errEl) errEl.textContent = "Informe login e senha.";
        return;
      }
      if (errEl) errEl.textContent = "";
      if (btn) btn.disabled = true;
      try {
        const resp = await nativeFetch(BACKEND_URL + "/api/auth/login", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ login, senha })
        });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) {
          if (errEl) errEl.textContent = data.error || "Falha no login.";
          return;
        }
        setToken(data.token || "");
        await restoreSession();
      } catch (e) {
        if (errEl) errEl.textContent = "Falha ao conectar no servidor.";
      } finally {
        if (btn) btn.disabled = false;
      }
    }

    function logoutAll() {
      setToken("");
      showLogin();
    }

    // Heartbeat para status online
    let heartbeatTimer = null;
    function startHeartbeat() {
      if (heartbeatTimer) clearInterval(heartbeatTimer);
      const ping = async () => {
        try {
          await fetch(BACKEND_URL + "/api/auth/heartbeat", { method: "POST" });
        } catch {}
      };
      ping();
      heartbeatTimer = setInterval(ping, 30000);
    }

    async function restoreSession() {
      const token = getToken();
      if (!token) { showLogin(); return; }
      try {
        const me = await authMe();
        if (me && me.role === "admin") {
          showAdmin();
          startHeartbeat();
          await adminLoadAll();
          updateAdminLocalBackupBadge();
          await refreshLocalBackupFromServer();
        } else if (me && me.role === "nurse") {
          showNurse();
          startHeartbeat();
          updateNurseBar(me);
        } else {
          showLogin();
        }
      } catch (e) {
        showLogin();
      }
    }

    function updateNurseBar(me) {
      // Aceita tanto o formato {role, user:{...}} quanto formato "achatado"
      const u = (me && me.user && typeof me.user === "object") ? me.user : (me || {});
      const name = (u.fullName || u.login || "-");
      const login = (u.login || "-");
      const paidFlag = (u.isPaidThisMonth !== undefined) ? !!u.isPaidThisMonth
        : (u.paidCurrentMonth !== undefined) ? !!u.paidCurrentMonth
        : (me && me.isPaidThisMonth !== undefined) ? !!me.isPaidThisMonth
        : (me && me.paidCurrentMonth !== undefined) ? !!me.paidCurrentMonth
        : false;

      const month = (me && me.currentMonth) ? me.currentMonth : (u.currentMonth || "");
      const lbl = document.getElementById("nurseUserLabel");
      const lblLogin = document.getElementById("nurseLoginLabel");
      const pay = document.getElementById("nursePaymentLabel");

      if (lbl) lbl.textContent = name;
      if (lblLogin) lblLogin.textContent = login;

      if (pay) {
        pay.textContent = paidFlag ? ("Em dia" + (month ? " (" + month + ")" : "")) : ("Em atraso" + (month ? " (" + month + ")" : ""));
        pay.classList.remove("green","red");
        pay.classList.add(paidFlag ? "green" : "red");
      }
    }
    }

    // Eventos de login/logout
    document.getElementById("loginBtn")?.addEventListener("click", doLogin);
    document.getElementById("passwordField")?.addEventListener("keydown", (e) => { if (e.key === "Enter") doLogin(); });
    document.getElementById("nurseLogoutBtn")?.addEventListener("click", logoutAll);
    document.getElementById("adminLogoutBtn")?.addEventListener("click", logoutAll);


    let recognition;
    let isRecording = false;
    let isPaused = false;
    let finalTranscript = "";
    let baseTranscript = "";
    let baseTranscriptRaw = "";
    let timerInterval = null;
    let startTime = null;
    let accumulatedSeconds = 0;
    let currentSoapRaw = "";

    // ============================
    // ============================
    // MÓDULO: Perguntas e procedimentos essenciais em tempo real (FLUXO CONTROLADO)
    // ============================
    let interimTranscript = "";

    // Fluxo: aguarda motivo -> gera até 3 perguntas -> enfermeiro marca pergunta feita -> aguarda resposta -> atualiza
    let guidanceEnabled = false;
    let guidanceStage = "aguardando_motivo"; // "aguardando_motivo" | "perguntas"
    let guidancePending = []; // array de strings
    let guidanceContextLabel = "";
    let guidanceHypothesis = "";
    let guidanceConfidence = 0; // 0..95

    let guidanceInFlight = false;
    let guidanceAskedQuestion = "";
    let guidanceAskedAtLen = 0;
    let guidanceAskedAtTs = 0;
    let guidanceAnswerDebounce = null;
    let guidanceLastPayloadHash = "";
    let guidanceTurnState = "aguardando_pergunta"; // "aguardando_pergunta" | "aguardando_resposta"
    let guidanceChunkStartLen = 0;
    let guidanceSilenceTimer = null;
    let guidanceLastChunkTs = 0;
const recordBtn = document.getElementById("recordBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const timerEl = document.getElementById("timer");
    const micStatus = document.getElementById("micStatus");
    const resultsCard = document.getElementById("resultsCard");
    const soapError = document.getElementById("soapError");
    const printBtn = document.getElementById("printBtn");

    const liveGuidance = document.getElementById("liveGuidance");
    const liveGuidanceContext = document.getElementById("liveGuidanceContext");
    const liveGuidanceStatus = document.getElementById("liveGuidanceStatus");
    const liveGuidanceList = document.getElementById("liveGuidanceList");

    const soapS = document.getElementById("soapS");
    const soapO = document.getElementById("soapO");
    const soapA = document.getElementById("soapA");
    const soapP = document.getElementById("soapP");

    const prescriptionOutput = document.getElementById("prescriptionOutput");

    const hospitalPrescriptionOutput = document.getElementById("hospitalPrescriptionOutput");
    const generateHospitalPrescriptionBtn = document.getElementById("generateHospitalPrescriptionBtn");
    const copyHospitalPrescriptionBtn = document.getElementById("copyHospitalPrescriptionBtn");
    const printHospitalPrescriptionBtn = document.getElementById("printHospitalPrescriptionBtn");
    const hospitalPrescriptionStatus = document.getElementById("hospitalPrescriptionStatus");

    const pregnancyBox = document.getElementById("pregnancyBox");
    const lactationBox = document.getElementById("lactationBox");

    const riskTriageBadge = document.getElementById("riskTriageBadge");
    const riskTriageMeaning = document.getElementById("riskTriageMeaning");
    const riskTriageLegend = document.getElementById("riskTriageLegend");
    const copyRiskTriageBtn = document.getElementById("copyRiskTriageBtn");
    const printRiskTriageBtn = document.getElementById("printRiskTriageBtn");
    const riskTriageStatus = document.getElementById("riskTriageStatus");

    const copySaeBtn = document.getElementById("copySaeBtn");
    const classificationsStatus = document.getElementById("classificationsStatus");
    const printPregnancyBtn = document.getElementById("printPregnancyBtn");
    const printLactationBtn = document.getElementById("printLactationBtn");

    const recommendationsBtn = document.getElementById("recommendationsBtn");
    const recommendationsPanel = document.getElementById("recommendationsPanel");
    const closeRecommendationsBtn = document.getElementById("closeRecommendationsBtn");
    const recommendationsStatus = document.getElementById("recommendationsStatus");
    const recommendationsList = document.getElementById("recommendationsList");
    const askQuestionsBtn = document.getElementById("askQuestionsBtn");
    const questionsTimerEl = document.getElementById("questionsTimer");

    const soapCopyButtons = document.querySelectorAll(".copy-soap-btn");
    const copyPrescriptionBtn = document.getElementById("copyPrescriptionBtn");

    const copyFullSoapBtn = document.getElementById("copyFullSoapBtn");
    const printSoapBtn = document.getElementById("printSoapBtn");

    const medicalDoubtInput = document.getElementById("medicalDoubtInput");
    const medicalDoubtStatus = document.getElementById("medicalDoubtStatus");
    const medicalDoubtAnswer = document.getElementById("medicalDoubtAnswer");


    const medPhotoBtn = document.getElementById("medPhotoBtn");
    const interactionsBox = document.getElementById("interactionsBox");
    const interactionsStatus = document.getElementById("interactionsStatus");
    const copyMedSafetyBtn = document.getElementById("copyMedSafetyBtn");
    const printMedSafetyBtn = document.getElementById("printMedSafetyBtn");
    const medCameraInput = document.getElementById("medCameraInput");
    const medFileInput = document.getElementById("medFileInput");

    const woundPhotoBtn = document.getElementById("woundPhotoBtn");
    const presentationsMaxDoseBox = document.getElementById("presentationsMaxDoseBox");
    const presentationsMaxDoseStatus = document.getElementById("presentationsMaxDoseStatus");
    const copyWoundBtn = document.getElementById("copyWoundBtn");
    const printWoundBtn = document.getElementById("printWoundBtn");
    const woundCameraInput = document.getElementById("woundCameraInput");
    const woundFileInput = document.getElementById("woundFileInput");

    const imageChoiceOverlay = document.getElementById("imageChoiceOverlay");
    const chooseCameraBtn = document.getElementById("chooseCameraBtn");
    const chooseFileBtn = document.getElementById("chooseFileBtn");
    const cancelImageChoiceBtn = document.getElementById("cancelImageChoiceBtn");

    let pendingCameraInput = null;
    let pendingFileInput = null;



    // ============================
    // MÓDULO: Coletar dados essenciais (NOVO)
    // ============================
    const patientInfoBtn = document.getElementById("patientInfoBtn");
    const patientInfoTimerEl = document.getElementById("patientInfoTimer");
    const patientInfoStatus = document.getElementById("patientInfoStatus");
    const patientInfoSummary = document.getElementById("patientInfoSummary");

    let patientContext = { nome: null, idade: null, peso_kg: null };

    let patientInfoRecognition = null;
    let patientInfoIsRecording = false;
    let patientInfoFinalTranscript = "";
    let patientInfoTimerInterval = null;
    let patientInfoStartTime = null;
    let patientInfoAccumulatedSeconds = 0;

    function resetPatientInfoTimer() {
      patientInfoAccumulatedSeconds = 0;
      patientInfoStartTime = null;
      if (patientInfoTimerInterval) clearInterval(patientInfoTimerInterval);
      patientInfoTimerInterval = null;
      if (patientInfoTimerEl) patientInfoTimerEl.textContent = "00:00";
    }

    function updatePatientInfoTimer() {
      const now = Date.now();
      const seconds = patientInfoAccumulatedSeconds + Math.floor((now - patientInfoStartTime) / 1000);
      const m = ("0" + Math.floor(seconds / 60)).slice(-2);
      const s = ("0" + (seconds % 60)).slice(-2);
      if (patientInfoTimerEl) patientInfoTimerEl.textContent = `${m}:${s}`;
    }

    function startPatientInfoTimer() {
      patientInfoStartTime = Date.now();
      if (patientInfoTimerInterval) clearInterval(patientInfoTimerInterval);
      patientInfoTimerInterval = setInterval(updatePatientInfoTimer, 200);
    }

    function stopPatientInfoTimer() {
      if (!patientInfoStartTime) return;
      const now = Date.now();
      patientInfoAccumulatedSeconds += Math.floor((now - patientInfoStartTime) / 1000);
      patientInfoStartTime = null;
      if (patientInfoTimerInterval) clearInterval(patientInfoTimerInterval);
      patientInfoTimerInterval = null;
    }

    function formatPatientSummary(ctx) {
      const parts = [];
      if (ctx?.nome) parts.push(`Nome: ${ctx.nome}`);
      if (ctx?.idade) parts.push(`Idade: ${ctx.idade}`);
      if (ctx?.peso_kg !== null && ctx?.peso_kg !== undefined) parts.push(`Peso: ${ctx.peso_kg} kg`);
      return parts.length ? parts.join(" | ") : "";
    }

    function buildTranscriptWithPatientContext(rawTranscript) {
      let t = String(rawTranscript || "").trim();
      if (!t) return "";

      t = t.replace(/^Dados do paciente:[\s\S]*?\n{2,}/i, "").trim();

      const hasAny = !!(patientContext?.nome || patientContext?.idade || (patientContext?.peso_kg !== null && patientContext?.peso_kg !== undefined));
      if (!hasAny) return t;

      const headerParts = [];
      if (patientContext.nome) headerParts.push(`Nome completo: ${patientContext.nome}.`);
      if (patientContext.idade) headerParts.push(`Idade: ${patientContext.idade}.`);
      if (patientContext.peso_kg !== null && patientContext.peso_kg !== undefined) headerParts.push(`Peso: ${patientContext.peso_kg} kg.`);

      const header = `Dados do paciente: ${headerParts.join(" ")}\n\n`;
      return header + t;
    }

    function initPatientInfoSpeech() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) return false;

      patientInfoRecognition = new SR();
      patientInfoRecognition.lang = "pt-BR";
      patientInfoRecognition.continuous = true;
      patientInfoRecognition.interimResults = true;

      patientInfoRecognition.onresult = (event) => {
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const txt = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            patientInfoFinalTranscript += txt + " ";
          }
        }
      };

      patientInfoRecognition.onerror = (e) => {
        console.warn("Erro no reconhecimento (dados do paciente):", e);
      };

      return true;
    }

    
    function getNursingContext() {
      const t = (baseTranscriptRaw || baseTranscript || finalTranscript || "").trim();
      const s = (soapS?.value || "").trim();
      const o = (soapO?.value || "").trim();
      const a = (soapA?.value || "").trim();
      const p = (soapP?.value || "").trim();
      const plano = (prescriptionOutput?.value || "").trim();
      const sbar = (hospitalPrescriptionOutput?.value || "").trim();
      const parts = [];
      if (t) parts.push("TRANSCRIÇÃO:\n" + t);
      if (s || o || a || p) parts.push("EVOLUÇÃO (SOAP):\nS: " + s + "\nO: " + o + "\nA: " + a + "\nP: " + p);
      if (plano) parts.push("PLANO DE CUIDADOS:\n" + plano);
      if (sbar) parts.push("SBAR:\n" + sbar);
      return parts.join("\n\n").trim();
    }

    // ============================
    // MÓDULO: Classificação de risco por cores (NOVO)
    // ============================
    const RISK_LEGEND_DEFAULT = [
      { cor: "Vermelho", significado: "Emergência. Atendimento imediato." },
      { cor: "Laranja", significado: "Muito urgente. Prioridade alta de atendimento." },
      { cor: "Amarelo", significado: "Urgente. Necessita avaliação em curto prazo." },
      { cor: "Verde", significado: "Pouco urgente. Pode aguardar com segurança, mantendo reavaliação se piora." },
      { cor: "Azul", significado: "Não urgente. Caso de baixa gravidade, orientar e agendar conforme necessidade." }
    ];

    function normalizeRiskColorLabel(label) {
      const t = String(label || "").trim().toLowerCase();
      if (!t) return "Não informado";
      if (t.includes("vermelh")) return "Vermelho";
      if (t.includes("laranj")) return "Laranja";
      if (t.includes("amarel")) return "Amarelo";
      if (t.includes("verd")) return "Verde";
      if (t.includes("azul")) return "Azul";
      if (t.includes("nao informado") || t.includes("não informado") || t.includes("indefin")) return "Não informado";
      return label.trim();
    }

    function applyRiskBadgeColor(cor) {
      if (!riskTriageBadge) return;
      riskTriageBadge.classList.remove("risk-none", "risk-vermelho", "risk-laranja", "risk-amarelo", "risk-verde", "risk-azul");
      const c = normalizeRiskColorLabel(cor);
      if (c === "Vermelho") riskTriageBadge.classList.add("risk-vermelho");
      else if (c === "Laranja") riskTriageBadge.classList.add("risk-laranja");
      else if (c === "Amarelo") riskTriageBadge.classList.add("risk-amarelo");
      else if (c === "Verde") riskTriageBadge.classList.add("risk-verde");
      else if (c === "Azul") riskTriageBadge.classList.add("risk-azul");
      else riskTriageBadge.classList.add("risk-none");
    }

    function renderRiskLegend(legendArr) {
      if (!riskTriageLegend) return;
      const legend = Array.isArray(legendArr) && legendArr.length ? legendArr : RISK_LEGEND_DEFAULT;

      riskTriageLegend.innerHTML = "";
      legend.forEach((item) => {
        const cor = normalizeRiskColorLabel(item?.cor || "");
        const significado = String(item?.significado || "").trim();

        const row = document.createElement("div");
        row.className = "risk-legend-row";

        const swatch = document.createElement("div");
        swatch.className = "risk-legend-swatch " + (
          cor === "Vermelho" ? "swatch-vermelho" :
          cor === "Laranja" ? "swatch-laranja" :
          cor === "Amarelo" ? "swatch-amarelo" :
          cor === "Verde" ? "swatch-verde" :
          cor === "Azul" ? "swatch-azul" : ""
        );

        const txt = document.createElement("div");
        txt.style.flex = "1";
        txt.textContent = cor + (significado ? (": " + significado) : "");

        row.appendChild(swatch);
        row.appendChild(txt);
        riskTriageLegend.appendChild(row);
      });
    }

    function buildRiskPrintText(cor, significado, legendArr) {
      const c = normalizeRiskColorLabel(cor);
      const s = String(significado || "").trim();
      const legend = Array.isArray(legendArr) && legendArr.length ? legendArr : RISK_LEGEND_DEFAULT;

      const lines = [];
      lines.push("Classificação de risco: " + c);
      if (s) lines.push("Significado: " + s);
      lines.push("");
      lines.push("Legenda:");
      legend.forEach((it) => {
        const lc = normalizeRiskColorLabel(it?.cor || "");
        const ls = String(it?.significado || "").trim();
        lines.push(lc + ": " + ls);
      });
      return lines.join("\n");
    }

    async function updateRiskTriage() {
      if (!riskTriageStatus) return;

      const contexto = getNursingContext();
      if (!contexto) {
        if (riskTriageBadge) {
          riskTriageBadge.textContent = "Não informado";
          applyRiskBadgeColor("Não informado");
        }
        if (riskTriageMeaning) riskTriageMeaning.textContent = "Nenhum conteúdo disponível.";
        renderRiskLegend(RISK_LEGEND_DEFAULT);
        riskTriageStatus.textContent = "Sem conteúdo suficiente para classificar.";
        return;
      }

      riskTriageStatus.textContent = "Gerando classificação de risco...";
      riskTriageStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/classificacao-risco", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ contexto })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (classificação de risco):", resp.status, txt);
          riskTriageStatus.classList.remove("loading-dot");
          riskTriageStatus.textContent = "Não foi possível gerar a classificação de risco.";
          return;
        }

        const data = await resp.json();

        const cor = normalizeRiskColorLabel(data?.cor || "Não informado");
        const significado = String(data?.significado || "").trim();
        const legenda = Array.isArray(data?.legenda) ? data.legenda : RISK_LEGEND_DEFAULT;

        if (riskTriageBadge) {
          riskTriageBadge.textContent = cor;
          applyRiskBadgeColor(cor);
        }
        if (riskTriageMeaning) {
          riskTriageMeaning.textContent = significado ? significado : "Sem significado disponível.";
        }
        renderRiskLegend(legenda);

        // Guarda texto para impressão
        riskTriageMeaning.dataset.printText = buildRiskPrintText(cor, significado, legenda);

        riskTriageStatus.classList.remove("loading-dot");
        riskTriageStatus.textContent = "Classificação atualizada.";
      } catch (e) {
        console.error(e);
        riskTriageStatus.classList.remove("loading-dot");
        riskTriageStatus.textContent = "Falha de rede ou backend ao gerar a classificação de risco.";
      }
    }


async function generateSoapAndPrescriptionFromTranscript(transcricao, statusText) {
      const t = String(transcricao || "").trim();
      if (!t) return;

      soapError.textContent = "";
      micStatus.innerText = statusText || "Atualizando SOAP e prescrição...";
      micStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/gerar-soap", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao: t })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend:", resp.status, txt);
          soapError.textContent = "Erro ao gerar evolução/plano de cuidados. Verifique o backend e tente novamente.";
          micStatus.innerText = "Falha ao gerar o resumo.";
          micStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const soap = data.soap || "";
        const prescricao = data.prescricao || "";

        updateSoapFromString(soap);
        prescriptionOutput.value = normalizeNumberedParagraphs(prescricao);
        printBtn.style.display = prescricao ? "inline-block" : "none";

        micStatus.innerText = "Atualização concluída.";
        micStatus.classList.remove("loading-dot");

        await updateClassifications();
        await updateRiskTriage();
        } catch (e) {
        console.error(e);
        soapError.textContent = "Erro ao gerar evolução e plano de cuidados (falha de rede ou backend).";
        micStatus.innerText = "Falha ao gerar o resumo.";
        micStatus.classList.remove("loading-dot");
      }
    }

    async function applyPatientContextAndRefreshAll() {
      const rawCandidate = (baseTranscriptRaw || "").trim() || (finalTranscript || "").trim() || (baseTranscript || "").trim();
      if (!rawCandidate) {
        patientInfoStatus.textContent = "Não há transcrição da consulta para atualizar.";
        return;
      }

      const cleanedRaw = rawCandidate.replace(/^Dados do paciente:[\s\S]*?\n{2,}/i, "").trim();
      baseTranscriptRaw = cleanedRaw;

      const transcricaoAtualizada = buildTranscriptWithPatientContext(cleanedRaw);
      baseTranscript = transcricaoAtualizada;

      await generateSoapAndPrescriptionFromTranscript(transcricaoAtualizada, "Atualizando SOAP e prescrição com nome/idade/peso...");
}

    async function startPatientInfoRecording() {
      if (!patientInfoBtn) return;

      patientInfoStatus.textContent = "Gravando... Dite nome completo, idade e peso.";
      patientInfoStatus.classList.add("loading-dot");
      patientInfoBtn.textContent = "Finalizar nome/idade/peso";

      patientInfoFinalTranscript = "";
      resetPatientInfoTimer();
      startPatientInfoTimer();

      try { if (recognition) recognition.stop(); } catch (e) {}
      try { if (questionsRecognition) questionsRecognition.stop(); } catch (e) {}
      try { if (reportRecognition) reportRecognition.stop(); } catch (e) {}

      if (!patientInfoRecognition) {
        const ok = initPatientInfoSpeech();
        if (!ok) {
          patientInfoStatus.classList.remove("loading-dot");
          patientInfoStatus.textContent = "Navegador sem suporte a reconhecimento de voz.";
          patientInfoBtn.textContent = "Coletar dados essenciais";
          stopPatientInfoTimer();
          return;
        }
      }

      patientInfoIsRecording = true;
      try {
        patientInfoRecognition.start();
      } catch (e) {
        console.warn("Erro ao iniciar reconhecimento (dados do paciente):", e);
      }
    }

    async function stopPatientInfoRecordingAndApply() {
      patientInfoIsRecording = false;
      stopPatientInfoTimer();

      patientInfoBtn.textContent = "Coletar dados essenciais";

      if (patientInfoRecognition) {
        try { patientInfoRecognition.stop(); } catch (e) {}
      }

      const transcricaoCurta = patientInfoFinalTranscript.trim();
      if (!transcricaoCurta) {
        patientInfoStatus.classList.remove("loading-dot");
        patientInfoStatus.textContent = "Nenhuma fala foi capturada.";
        return;
      }

      patientInfoStatus.textContent = "Processando nome/idade/peso...";
      patientInfoStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/extrair-dados-paciente", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao: transcricaoCurta })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (dados do paciente):", resp.status, txt);
          patientInfoStatus.classList.remove("loading-dot");
          patientInfoStatus.textContent = "Não foi possível extrair os dados do paciente.";
          return;
        }

        const data = await resp.json();
        patientContext = {
          nome: (data?.nome || null),
          idade: (data?.idade || null),
          peso_kg: (typeof data?.peso_kg === "number" && Number.isFinite(data.peso_kg)) ? data.peso_kg : null
        };

        const resumo = formatPatientSummary(patientContext);
        patientInfoSummary.textContent = resumo ? resumo : "Dados do paciente não identificados com segurança.";
        patientInfoStatus.classList.remove("loading-dot");
        patientInfoStatus.textContent = resumo ? "Dados do paciente atualizados." : "Sem dados suficientes para atualizar.";

        await applyPatientContextAndRefreshAll();
      } catch (e) {
        console.error(e);
        patientInfoStatus.classList.remove("loading-dot");
        patientInfoStatus.textContent = "Falha de rede ou backend ao extrair dados do paciente.";
      }
    }

    if (patientInfoBtn) {
      patientInfoBtn.addEventListener("click", async () => {
        if (patientInfoIsRecording) {
          await stopPatientInfoRecordingAndApply();
        } else {
          await startPatientInfoRecording();
        }
      });
    }

    const reportRecordBtn = document.getElementById("reportRecordBtn");
    const reportStatus = document.getElementById("reportStatus");
    const reportOutput = document.getElementById("reportOutput");
    const reportDocTypeSelect = document.getElementById("reportDocTypeSelect");
    const reportDocTypeDetected = document.getElementById("reportDocTypeDetected");
    const reportMissingFields = document.getElementById("reportMissingFields");
    const copyReportBtn = document.getElementById("copyReportBtn");
    const printReportBtn = document.getElementById("printReportBtn");

    let reportRecognition = null;
    let reportIsRecording = false;
    let reportIsPaused = false;
    let reportFinalTranscript = "";

    // Rodada adicional de perguntas (aba lateral)
    let questionsRecognition = null;
    let questionsIsRecording = false;
    let questionsFinalTranscript = "";
    let questionsTimerInterval = null;
    let questionsStartTime = null;
    let questionsAccumulatedSeconds = 0;

    function escapeHtml(text) {
      return String(text || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }

    function normalizeNumberedParagraphs(text) {
      let t = String(text || "");
      t = t.replace(/\r/g, "");
      // Garante que cada item numerado comece em uma nova linha (melhora leitura no S.U.I.S.)
      t = t.replace(/([^\n])\s+(\d+)\s*([\.)])\s+/g, "$1\n$2$3 ");
      t = t.replace(/([^\n])\s+(\d+)\s*[-–—]\s+/g, "$1\n$2 - ");
      t = t.replace(/\n{3,}/g, "\n\n");
      return t.trim();
    }


    // ============================
    // ============================
    // Perguntas e procedimentos essenciais em tempo real (FLUXO CONTROLADO)
    // ============================
    function renderLiveGuidance() {
      if (!liveGuidance || !liveGuidanceList || !liveGuidanceStatus || !liveGuidanceContext) return;

      if (!isRecording) {
        liveGuidanceContext.textContent = "";
        liveGuidanceStatus.textContent = "Inicie o atendimento para receber perguntas e procedimentos necessários em tempo real.";
        liveGuidanceList.innerHTML = "<div class=\"live-guidance-empty\">Nenhuma sugestão por enquanto.</div>";
        return;
      }

      const ctx = (guidanceContextLabel || "").trim();
      liveGuidanceContext.textContent = ctx ? ("Atendimento: " + ctx) : "";

      if (guidanceStage === "aguardando_motivo") {
        liveGuidanceStatus.textContent = "Aguardando o motivo da consulta. Após o paciente informar o motivo, as perguntas essenciais serão sugeridas.";
        liveGuidanceList.innerHTML = `
          <div class="live-guidance-empty">
            Oriente: acolha e pergunte o motivo da consulta. Após a resposta do paciente, as perguntas essenciais serão sugeridas automaticamente.
            <div style="margin-top:10px;">
              <button id="forceStartGuidanceBtn" class="mini-red-btn" style="background:#b00020;">Motivo já foi informado</button>
            </div>
          </div>
        `;
        const btn = document.getElementById("forceStartGuidanceBtn");
        if (btn) {
          btn.onclick = () => {
            if (guidanceStage !== "aguardando_motivo") return;
            guidanceStage = "perguntas";
            // reinicia detecção de turnos a partir do ponto atual
            guidanceTurnState = "aguardando_pergunta";
            guidanceAskedQuestion = "";
            guidanceAskedAtLen = getCombinedTranscript().length;
            guidanceAskedAtTs = Date.now();
            guidanceChunkStartLen = getCombinedTranscript().length;
            requestGuidanceFromBackend({ evento: "inicial" });
          };
        }
        return;
      }

      // estágio perguntas (controle por turnos: pergunta -> resposta -> atualizar)
      const confTxt = (typeof guidanceConfidence === "number" && guidanceConfidence > 0)
        ? ("Nível de confiança da hipótese principal: " + Math.round(guidanceConfidence) + "% (não chega a 100%).")
        : "";

      const hypo = (guidanceHypothesis || "").trim();
      const hypoTxt = hypo ? ("Hipótese principal: " + hypo + ". " + confTxt) : confTxt;

      if (guidanceTurnState === "aguardando_resposta") {
        liveGuidanceStatus.textContent = "Pergunta em andamento. Aguardando resposta do paciente para atualizar as próximas perguntas...";
      } else if (guidanceInFlight) {
        liveGuidanceStatus.textContent = "Atualizando perguntas essenciais...";
      } else {
        liveGuidanceStatus.textContent = hypoTxt || "Perguntas essenciais sugeridas. Faça uma das perguntas e aguarde a resposta do paciente.";
      }

      if (!guidancePending || !guidancePending.length) {
        liveGuidanceList.innerHTML = "<div class=\"live-guidance-empty\">Nenhuma pergunta essencial no momento.</div>";
        return;
      }

      liveGuidanceList.innerHTML = "";
      guidancePending.slice(0, 3).forEach((q, idx) => {
        const safeQ = escapeHtml(String(q || ""));
        const askedMark = (guidanceAskedQuestion && guidanceAskedQuestion.toLowerCase() === String(q || "").toLowerCase())
          ? " (pergunta feita)"
          : "";
        const el = document.createElement("div");
        el.className = "live-guidance-item";
        el.innerHTML = `<div class="live-guidance-item-text">${idx + 1}. ${safeQ}${askedMark}</div>`;
        liveGuidanceList.appendChild(el);
      });
    }

    function getCombinedTranscript() {
      const combined = ((finalTranscript || "") + " " + (interimTranscript || "")).trim();
      if (!combined) return "";
      const MAX = 8000;
      return combined.length > MAX ? combined.slice(combined.length - MAX) : combined;
    }

    function hashForGuidancePayload(obj) {
      try {
        const raw = JSON.stringify(obj || {});
        let h = 0;
        for (let i = 0; i < raw.length; i++) {
          h = ((h << 5) - h) + raw.charCodeAt(i);
          h |= 0;
        }
        return String(h);
      } catch {
        return String(Date.now());
      }
    }

    function resetLiveGuidanceState() {
      guidanceEnabled = true;
      guidanceStage = "aguardando_motivo";
      guidancePending = [];
      guidanceContextLabel = "";
      guidanceHypothesis = "";
      guidanceConfidence = 0;

      guidanceInFlight = false;

      guidanceTurnState = "aguardando_pergunta";
      guidanceAskedQuestion = "";
      guidanceAskedAtLen = 0;
      guidanceAskedAtTs = 0;

      guidanceChunkStartLen = 0;
      guidanceSilenceTimer && clearTimeout(guidanceSilenceTimer);
      guidanceSilenceTimer = null;

      guidanceLastPayloadHash = "";
      guidanceLastChunkTs = 0;

      renderLiveGuidance();
    }

    function startGuidanceLoop() {
      // Sem polling: só reage a eventos (inicial após motivo e após cada resposta)
      guidanceEnabled = true;
      renderLiveGuidance();
      maybeStartInitialGuidance(false);
    }

    function stopGuidanceLoop() {
      guidanceEnabled = false;
      guidanceInFlight = false;
      guidanceTurnState = "aguardando_pergunta";
      guidanceAskedQuestion = "";
      guidanceSilenceTimer && clearTimeout(guidanceSilenceTimer);
      guidanceSilenceTimer = null;
      renderLiveGuidance();
    }

    function hasLikelyChiefComplaint(text) {
      const t = String(text || "").toLowerCase();
      if (!t) return false;
      const kw = [
        "motivo", "queixa", "dor", "febre", "tosse", "falta de ar", "dispne", "diarre", "vômit",
        "náuse", "enjoo", "garganta", "cefale", "tont", "desmai", "urina", "ardor",
        "corrimento", "sangr", "pressão", "hipertens", "glic", "diabetes", "infec",
        "ferida", "queda", "trauma", "alerg", "coceira", "mancha"
      ];
      return kw.some(k => t.includes(k));
    }

    function maybeStartInitialGuidance(force) {
      if (!guidanceEnabled || !isRecording || isPaused) return;
      if (guidanceStage !== "aguardando_motivo") return;

      const combined = getCombinedTranscript();
      if (!combined || combined.length < 120) return;

      // Evita iniciar antes do paciente realmente falar algo clínico
      if (!force && !hasLikelyChiefComplaint(combined)) return;

      guidanceStage = "perguntas";
      guidanceTurnState = "aguardando_pergunta";
      guidanceAskedQuestion = "";
      guidanceAskedAtLen = combined.length;
      guidanceAskedAtTs = Date.now();
      guidanceChunkStartLen = combined.length;

      requestGuidanceFromBackend({ evento: "inicial" });
    }

    function onTranscriptUpdateForGuidance() {
      if (!guidanceEnabled || !isRecording || isPaused) return;

      // 1) Detecta automaticamente o momento de iniciar (após motivo)
      if (guidanceStage === "aguardando_motivo") {
        maybeStartInitialGuidance(false);
        return;
      }

      // 2) A partir daqui: está em "perguntas". Controla por turnos usando silêncio.
      scheduleGuidanceSilenceFinalize();
    }

    function scheduleGuidanceSilenceFinalize() {
      if (!guidanceEnabled || !isRecording || isPaused) return;

      if (guidanceSilenceTimer) clearTimeout(guidanceSilenceTimer);
      guidanceSilenceTimer = setTimeout(() => {
        finalizeGuidanceChunk();
      }, 1400);
    }

    function finalizeGuidanceChunk() {
      if (!guidanceEnabled || !isRecording || isPaused) return;

      const combined = getCombinedTranscript();
      if (!combined) return;

      if (guidanceChunkStartLen <= 0) {
        guidanceChunkStartLen = combined.length;
        return;
      }

      // Captura apenas o que foi acrescentado desde o último “silêncio”
      const chunk = combined.slice(guidanceChunkStartLen).trim();
      guidanceChunkStartLen = combined.length;

      if (!chunk || chunk.length < 10) return;

      // Evita processar chunks colados em sequência que são só repetição do reconhecimento
      const now = Date.now();
      if (guidanceLastChunkTs && (now - guidanceLastChunkTs) < 900) return;
      guidanceLastChunkTs = now;

      handleGuidanceUtteranceChunk(chunk);
    }

    function stripAccents(s) {
      return String(s || "")
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "");
    }

    function tokenizePt(s) {
      const t = stripAccents(String(s || "").toLowerCase())
        .replace(/[^a-z0-9\s]/g, " ")
        .replace(/\s+/g, " ")
        .trim();

      if (!t) return [];

      const stop = new Set([
        "a","o","os","as","um","uma","uns","umas","de","do","da","dos","das","no","na","nos","nas",
        "em","para","por","com","sem","e","ou","que","qual","quais","quando","como","onde","porque",
        "ao","aos","à","às","se","já","não","sim","me","te","lhe","eles","elas","você","vocês",
        "eu","tu","ele","ela","nós","vos","isso","isto","aquilo","essa","esse","este","esta",
        "tem","tá","está","foi","era","são","ser","ter","há"
      ]);

      return t.split(" ").filter(w => w && w.length > 2 && !stop.has(w));
    }

    function jaccardSimilarity(aTokens, bTokens) {
      const A = new Set(aTokens || []);
      const B = new Set(bTokens || []);
      if (!A.size || !B.size) return 0;
      let inter = 0;
      for (const w of A) if (B.has(w)) inter++;
      const union = A.size + B.size - inter;
      return union ? (inter / union) : 0;
    }

    function matchQuestionFromUtterance(utterance, questions) {
      const qs = Array.isArray(questions) ? questions : [];
      if (!qs.length) return "";
      const uTok = tokenizePt(utterance);
      if (!uTok.length) return "";

      let bestQ = "";
      let bestScore = 0;

      for (const q of qs.slice(0, 3)) {
        const score = jaccardSimilarity(uTok, tokenizePt(q));
        if (score > bestScore) {
          bestScore = score;
          bestQ = q;
        }
      }

      // Se a similaridade for baixa, não “chuta” qual foi, para não apagar/alterar errado.
      if (bestScore < 0.18) return "";
      return String(bestQ || "").trim();
    }

    function handleGuidanceUtteranceChunk(chunkText) {
      if (!chunkText) return;
      if (!guidancePending || !guidancePending.length) return;
      if (guidanceInFlight) return;

      // Turno 1: o enfermeiro faz uma pergunta (a partir das 3 sugeridas)
      if (guidanceTurnState === "aguardando_pergunta") {
        const matched = matchQuestionFromUtterance(chunkText, guidancePending);

        guidanceAskedQuestion = matched ? matched : "";
        guidanceAskedAtTs = Date.now();
        guidanceAskedAtLen = getCombinedTranscript().length;

        guidanceTurnState = "aguardando_resposta";
        renderLiveGuidance();
        return;
      }

      // Turno 2: o paciente responde -> atualiza as perguntas
      if (guidanceTurnState === "aguardando_resposta") {
        const dt = Date.now() - (guidanceAskedAtTs || 0);
        if (dt < 900) return; // evita disparo imediato

        // Atualiza com base no diálogo novo
        requestGuidanceFromBackend({ evento: "resposta", ultima_fala: chunkText });
        return;
      }
    }

    async function requestGuidanceFromBackend({ evento, ultima_fala }) {
      if (guidanceInFlight) return;
      if (!guidanceEnabled || !isRecording || isPaused) return;

      const combined = getCombinedTranscript();
      if (!combined || combined.length < 50) {
        renderLiveGuidance();
        return;
      }

      const payload = {
        transcricao: combined,
        estado: guidanceStage,
        evento: evento || "stream",
        pergunta_feita: guidanceAskedQuestion || "",
        perguntas_pendentes: Array.isArray(guidancePending) ? guidancePending.slice(0, 3) : [],
        confianca_atual: typeof guidanceConfidence === "number" ? guidanceConfidence : 0,
        hipotese_atual: guidanceHypothesis || "",
        ultima_fala: typeof ultima_fala === "string" ? ultima_fala.slice(0, 800) : ""
      };

      const h = hashForGuidancePayload(payload);
      if (h === guidanceLastPayloadHash && evento !== "inicial" && evento !== "resposta") return;
      guidanceLastPayloadHash = h;

      guidanceInFlight = true;
      renderLiveGuidance();

      try {
        const resp = await fetch(BACKEND_URL + "/api/guia-tempo-real", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        if (!resp.ok) {
          const txt = await resp.text();
          console.error("Erro HTTP do backend (guia em tempo real):", resp.status, txt);
          return;
        }

        const data = await resp.json();
        guidanceContextLabel = data.contexto || guidanceContextLabel || "";
        guidanceHypothesis = data.hipotese_principal || guidanceHypothesis || "";
        if (typeof data.confianca === "number") guidanceConfidence = data.confianca;

        const itens = Array.isArray(data.perguntas) ? data.perguntas : (Array.isArray(data.itens) ? data.itens : []);
        const normalized = itens.map(x => String(x || "").trim()).filter(Boolean);

        guidancePending = normalized.slice(0, 3);

        // Após atualizar, volta a aguardar a próxima pergunta do enfermeiro
        if (evento === "resposta") {
          guidanceTurnState = "aguardando_pergunta";
          guidanceAskedQuestion = "";
          guidanceAskedAtLen = combined.length;
          guidanceAskedAtTs = Date.now();
          guidanceChunkStartLen = combined.length;
        }

        // Após gerar as perguntas iniciais, aguarda a primeira pergunta do enfermeiro
        if (evento === "inicial") {
          guidanceTurnState = "aguardando_pergunta";
          guidanceAskedQuestion = "";
          guidanceAskedAtLen = combined.length;
          guidanceAskedAtTs = Date.now();
          guidanceChunkStartLen = combined.length;
        }
      } catch (err) {
        console.error("Falha ao buscar guia em tempo real:", err);
      } finally {
        guidanceInFlight = false;
        renderLiveGuidance();
      }
    }
function initSpeech() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        micStatus.innerText =
          "Seu navegador não suporta reconhecimento de voz. Use Google Chrome em um computador.";
        return;
      }
      recognition = new SR();
      recognition.lang = "pt-BR";
      recognition.continuous = true;
      recognition.interimResults = true;

      recognition.onresult = (event) => {
        let interim = "";
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            finalTranscript += transcript + " ";
          } else {
            interim += transcript;
          }
        }

        interimTranscript = interim.trim();
        // Atualiza o fluxo de perguntas/procedimentos (somente quando necessário)
        onTranscriptUpdateForGuidance();
      };

      recognition.onerror = (event) => {
        console.error("Erro no reconhecimento de voz:", event.error);
        if (event.error === "not-allowed" || event.error === "service-not-allowed") {
          micStatus.innerText =
            "Permita o acesso ao microfone nas configurações do navegador e tente novamente.";
        } else {
          micStatus.innerText =
            "Ocorreu um erro no reconhecimento de voz. Tente novamente.";
        }
      };

      recognition.onend = () => {
        if (isRecording && !isPaused) {
          try {
            recognition.start();
          } catch (err) {
            console.warn("Não foi possível retomar reconhecimento:", err);
          }
        }
      };
    }

    function updateTimer() {
      const now = Date.now();
      const seconds = accumulatedSeconds + Math.floor((now - startTime) / 1000);
      const m = ("0" + Math.floor(seconds / 60)).slice(-2);
      const s = ("0" + (seconds % 60)).slice(-2);
      timerEl.innerText = `${m}:${s}`;
    }

    function startTimer() {
      startTime = Date.now();
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(updateTimer, 500);
    }

    function pauseTimer() {
      if (!startTime) return;
      const now = Date.now();
      accumulatedSeconds += Math.floor((now - startTime) / 1000);
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
    }

    function resetTimer() {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
      startTime = null;
      accumulatedSeconds = 0;
      timerEl.innerText = "00:00";
    }

    function resetNewModulesUI() {
      hospitalPrescriptionOutput.value = "";
      hospitalPrescriptionStatus.textContent = "";
      classificationsStatus.textContent = "";
      pregnancyBox.textContent = "Nenhum conteúdo disponível.";
      lactationBox.textContent = "Nenhum conteúdo disponível.";
      if (interactionsBox) interactionsBox.textContent = "Nenhum conteúdo disponível.";
      if (interactionsStatus) interactionsStatus.textContent = "";
      if (presentationsMaxDoseBox) presentationsMaxDoseBox.textContent = "Nenhum conteúdo disponível.";
      if (presentationsMaxDoseStatus) presentationsMaxDoseStatus.textContent = "";
    }

    async function finalizarConsulta() {
      soapError.textContent = "";
      micStatus.innerText = "Gerando SOAP e prescrição com base na gravação...";
      micStatus.classList.add("loading-dot");

      if (recognition) {
        try {
          recognition.stop();
        } catch (e) {
          console.warn("Erro ao parar reconhecimento:", e);
        }
      }

      pauseTimer();

      const transcricao = finalTranscript.trim();
      if (!transcricao) {
        micStatus.classList.remove("loading-dot");
        micStatus.innerText =
          "Nenhuma fala foi capturada. Verifique o microfone e tente novamente.";
        return;
      }

      baseTranscriptRaw = transcricao;

      const transcricaoParaGeracao = buildTranscriptWithPatientContext(transcricao);
      baseTranscript = transcricaoParaGeracao;

      try {
        const resp = await fetch(BACKEND_URL + "/api/gerar-soap", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao: transcricaoParaGeracao })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend:", resp.status, txt);
          soapError.textContent =
            "Erro ao gerar evolução/plano de cuidados. Verifique o backend e tente novamente.";
          micStatus.innerText = "Falha ao gerar o resumo.";
          micStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const soap = data.soap || "";
        const prescricao = data.prescricao || "";

        updateSoapFromString(soap);

        prescriptionOutput.value = prescricao;
        printBtn.style.display = prescricao ? "inline-block" : "none";

        micStatus.innerText = "Consulta encerrada. SOAP e prescrição gerados.";
        micStatus.classList.remove("loading-dot");

        await updateClassifications();
        await updateRiskTriage();
        } catch (e) {
        console.error(e);
        soapError.textContent =
          "Erro ao gerar evolução e plano de cuidados (falha de rede ou backend).";
        micStatus.innerText = "Falha ao gerar o resumo.";
        micStatus.classList.remove("loading-dot");
      }
    }

    function splitSoap(soapText) {
      const sections = { S: "", O: "", A: "", P: "" };
      if (!soapText) return sections;

      const regex = /\b([SOAP])\s*:\s*([\s\S]*?)(?=\b[SOAP]\s*:|$)/g;
      let match;
      while ((match = regex.exec(soapText)) !== null) {
        const key = match[1].toUpperCase();
        sections[key] = match[2].trim();
      }
      return sections;
    }

    function updateSoapFromString(soapText) {
      currentSoapRaw = soapText || "";
      const parts = splitSoap(currentSoapRaw);

      soapS.value = parts.S || "";
      soapO.value = parts.O || "";
      soapA.value = parts.A || "";
      soapP.value = parts.P || "";

      resultsCard.classList.remove("hidden");
    }

    function getCombinedSoapFromFields() {
      const s = soapS.value.trim();
      const o = soapO.value.trim();
      const a = soapA.value.trim();
      const p = soapP.value.trim();

      let combined = "";
      if (s) combined += "S: " + s + "\n";
      if (o) combined += "O: " + o + "\n";
      if (a) combined += "A: " + a + "\n";
      if (p) combined += "P: " + p;
      currentSoapRaw = combined;
      return combined;
    }


    function formatInteractionsList(interacoes, observacoes) {
      const items = Array.isArray(interacoes) ? interacoes : [];
      if (!items.length) {
        const obs = (observacoes || "").trim();
        return obs
          ? ("Nenhuma interação clinicamente relevante identificada com segurança para os medicamentos prescritos.\n\nObservações:\n" + obs)
          : "Nenhuma interação clinicamente relevante identificada com segurança para os medicamentos prescritos.";
      }

      const parts = [];
      for (const it of items) {
        const meds = Array.isArray(it?.medicamentos) ? it.medicamentos : [];
        const a = meds[0] ? String(meds[0]) : "não informado";
        const b = meds[1] ? String(meds[1]) : "não informado";
        const grav = it?.gravidade ? String(it.gravidade) : "indeterminada";
        const desc = it?.descricao ? String(it.descricao) : "";
        const riscos = it?.riscos ? String(it.riscos) : "";
        const conduta = it?.conduta ? String(it.conduta) : "";

        let block = a + " + " + b + " (gravidade: " + grav + ")";
        if (desc.trim()) block += "\nInteração: " + desc.trim();
        if (riscos.trim()) block += "\nRiscos: " + riscos.trim();
        if (conduta.trim()) block += "\nConduta: " + conduta.trim();
        parts.push(block);
      }

      const obs = (observacoes || "").trim();
      if (obs) {
        parts.push("Observações:\n" + obs);
      }
      return parts.join("\n\n");
    }


    async function updateMedicationSafetyFromContext(contexto) {
      if (!interactionsBox || !interactionsStatus) return;

      interactionsStatus.textContent = "Gerando registro de administração segura...";
      interactionsStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/interacoes-medicamentosas", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ contexto })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP:", resp.status, txt);
          interactionsBox.textContent = "Falha ao gerar registro.";
          return;
        }

        const data = await resp.json().catch(() => ({}));
        interactionsBox.textContent = (data.registro || "").trim() || "Nenhum conteúdo disponível.";
      } catch (e) {
        console.error(e);
        interactionsBox.textContent = "Falha ao gerar registro (rede/backend).";
      } finally {
        interactionsStatus.classList.remove("loading-dot");
        interactionsStatus.textContent = "";
      }
    }

    function formatPresentationsMaxDoseList(itens) {
      const items = Array.isArray(itens) ? itens : [];
      if (!items.length) {
        return "Nenhuma informação disponível para os medicamentos prescritos.";
      }

      const lines = [];
      for (const it of items) {
        const med = it?.medicamento ? String(it.medicamento).trim() : "não informado";
        const a = it?.apresentacoes || {};
        const doseMax = it?.dosagem_maxima_diaria ? String(it.dosagem_maxima_diaria).trim() : "";

        lines.push("Medicamento: " + med);
        lines.push("Apresentações disponíveis:");

        const map = [
          ["Comprimido simples", a.comprimido_simples],
          ["Comprimido revestido", a.comprimido_revestido],
          ["Cápsula", a.capsula],
          ["Suspensão oral", a.suspensao_oral],
          ["Gotas", a.gotas],
          ["Solução oral", a.solucao_oral],
          ["Solução injetável", a.solucao_injetavel],
          ["Endovenosa", a.endovenosa],
          ["Intramuscular", a.intramuscular]
        ];

        for (const [label, val] of map) {
          const v = String(val || "").trim() || "não informado";
          lines.push("- " + label + ": " + v);
        }

        lines.push("Dosagem máxima diária: " + (doseMax || "não informado"));
        lines.push("");
      }

      return lines.join("\n").trim();
    }


    async function updateWoundCareFromContext(contexto) {
      if (!presentationsMaxDoseBox || !presentationsMaxDoseStatus) return;

      presentationsMaxDoseStatus.textContent = "Gerando registro de curativos e feridas...";
      presentationsMaxDoseStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/apresentacoes-dosagem-maxima", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ contexto })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP:", resp.status, txt);
          presentationsMaxDoseBox.textContent = "Falha ao gerar curativos.";
          return;
        }

        const data = await resp.json().catch(() => ({}));
        presentationsMaxDoseBox.textContent = (data.curativos || "").trim() || "Nenhum conteúdo disponível.";
      } catch (e) {
        console.error(e);
        presentationsMaxDoseBox.textContent = "Falha ao gerar curativos (rede/backend).";
      } finally {
        presentationsMaxDoseStatus.classList.remove("loading-dot");
        presentationsMaxDoseStatus.textContent = "";
      }
    }

    function updateQuestionsTimer() {
      const now = Date.now();
      const seconds = questionsAccumulatedSeconds + Math.floor((now - questionsStartTime) / 1000);
      const m = ("0" + Math.floor(seconds / 60)).slice(-2);
      const s = ("0" + (seconds % 60)).slice(-2);
      questionsTimerEl.innerText = `${m}:${s}`;
    }

    function startQuestionsTimer() {
      questionsStartTime = Date.now();
      if (questionsTimerInterval) clearInterval(questionsTimerInterval);
      questionsTimerInterval = setInterval(updateQuestionsTimer, 500);
    }

    function pauseQuestionsTimer() {
      if (!questionsStartTime) return;
      const now = Date.now();
      questionsAccumulatedSeconds += Math.floor((now - questionsStartTime) / 1000);
      if (questionsTimerInterval) clearInterval(questionsTimerInterval);
      questionsTimerInterval = null;
    }

    function resetQuestionsTimer() {
      if (questionsTimerInterval) clearInterval(questionsTimerInterval);
      questionsTimerInterval = null;
      questionsStartTime = null;
      questionsAccumulatedSeconds = 0;
      questionsTimerEl.innerText = "00:00";
    }

    function initQuestionsSpeech() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        return null;
      }

      const rec = new SR();
      rec.lang = "pt-BR";
      rec.continuous = true;
      rec.interimResults = true;

      rec.onresult = (event) => {
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            questionsFinalTranscript += transcript + " ";
          }
        }
      };

      rec.onerror = (event) => {
        console.error("Erro no reconhecimento das perguntas:", event.error);
        recommendationsStatus.textContent =
          "Ocorreu um erro no reconhecimento de voz das perguntas. Tente novamente.";
        recommendationsStatus.classList.remove("loading-dot");
      };

      rec.onend = () => {
        if (questionsIsRecording) {
          try {
            rec.start();
          } catch (err) {
            console.warn("Não foi possível retomar reconhecimento das perguntas:", err);
          }
        }
      };

      return rec;
    }

    function startQuestionsRecording() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        recommendationsStatus.textContent =
          "Seu navegador não suporta reconhecimento de voz. Use Google Chrome em um computador.";
        return;
      }

      if (!questionsRecognition) {
        questionsRecognition = initQuestionsSpeech();
        if (!questionsRecognition) return;
      }

      questionsIsRecording = true;
      questionsFinalTranscript = "";

      questionsTimerEl.classList.remove("hidden");
      resetQuestionsTimer();
      startQuestionsTimer();

      askQuestionsBtn.textContent = "Encerrar perguntas";
      closeRecommendationsBtn.disabled = true;
      closeRecommendationsBtn.style.opacity = "0.5";

      recommendationsStatus.textContent =
        "Gravando perguntas e respostas. Quando terminar, clique em \"Encerrar perguntas\".";
      recommendationsStatus.classList.remove("loading-dot");

      try {
        questionsRecognition.start();
      } catch (e) {
        console.warn("Erro ao iniciar reconhecimento das perguntas:", e);
      }
    }

    async function stopQuestionsRecordingAndUpdateSoap() {
      questionsIsRecording = false;

      if (questionsRecognition) {
        try {
          questionsRecognition.stop();
        } catch (e) {
          console.warn("Erro ao parar reconhecimento das perguntas:", e);
        }
      }

      pauseQuestionsTimer();

      const qa = (questionsFinalTranscript || "").trim();
      if (!qa) {
        recommendationsStatus.textContent = "Nenhuma fala foi capturada nesta rodada de perguntas.";
        askQuestionsBtn.textContent = "Complementar avaliação";
        closeRecommendationsBtn.disabled = false;
        closeRecommendationsBtn.style.opacity = "1";
        askQuestionsBtn.disabled = false;
        resetQuestionsTimer();
        questionsTimerEl.classList.add("hidden");
        return;
      }

      const soapAtual = getCombinedSoapFromFields();
      if (!soapAtual) {
        recommendationsStatus.textContent = "Não há SOAP disponível para atualizar.";
        askQuestionsBtn.textContent = "Complementar avaliação";
        closeRecommendationsBtn.disabled = false;
        closeRecommendationsBtn.style.opacity = "1";
        askQuestionsBtn.disabled = false;
        return;
      }

      askQuestionsBtn.disabled = true;
      recommendationsStatus.textContent = "Atualizando SOAP e módulos com as novas respostas...";
      recommendationsStatus.classList.add("loading-dot");

      const transcricaoBase = (baseTranscript || finalTranscript || "").trim();

      try {
        const resp = await fetch(BACKEND_URL + "/api/atualizar-soap-perguntas", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            soap_atual: soapAtual,
            perguntas_e_respostas: qa,
            transcricao_base: transcricaoBase
          })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (atualizar perguntas):", resp.status, txt);
          recommendationsStatus.textContent = "Não foi possível atualizar o SOAP com as novas respostas.";
          recommendationsStatus.classList.remove("loading-dot");
          askQuestionsBtn.disabled = false;
          return;
        }

        const data = await resp.json();
        const soap = data.soap || "";
        const prescricao = data.prescricao || "";

        if (soap) {
          updateSoapFromString(soap);
        }
        if (prescricao) {
          prescriptionOutput.value = prescricao;
          printBtn.style.display = "inline-block";
        }

        const appended =
          (transcricaoBase ? transcricaoBase + "\n\n" : "") +
          "RODADA ADICIONAL DE PERGUNTAS E RESPOSTAS:\n" +
          qa +
          "\n";
        baseTranscript = appended;
        finalTranscript = appended;

        recommendationsStatus.textContent = "SOAP atualizado com as novas respostas.";
        recommendationsStatus.classList.remove("loading-dot");

        await updateClassifications();
        await updateRiskTriage();
      } catch (err) {
        console.error("Erro geral ao atualizar SOAP com perguntas:", err);
        recommendationsStatus.textContent = "Erro ao atualizar o SOAP com as novas respostas.";
        recommendationsStatus.classList.remove("loading-dot");
      } finally {
        askQuestionsBtn.textContent = "Complementar avaliação";
        askQuestionsBtn.disabled = false;
        closeRecommendationsBtn.disabled = false;
        closeRecommendationsBtn.style.opacity = "1";
        resetQuestionsTimer();
        questionsTimerEl.classList.add("hidden");
        recommendationsPanel.classList.remove("visible");
      }
    }

    async function fetchRecommendations() {
      const combinedSoap = getCombinedSoapFromFields();
      if (!combinedSoap) {
        soapError.textContent =
          "Não há SOAP gerado ainda para sugerir perguntas complementares.";
        return;
      }

      // Reseta qualquer rodada anterior de perguntas
      if (questionsIsRecording && questionsRecognition) {
        try {
          questionsIsRecording = false;
          questionsRecognition.stop();
        } catch (e) {}
      }
      askQuestionsBtn.textContent = "Complementar avaliação";
      askQuestionsBtn.disabled = true;
      closeRecommendationsBtn.disabled = false;
      closeRecommendationsBtn.style.opacity = "1";
      resetQuestionsTimer();
      questionsTimerEl.classList.add("hidden");

      recommendationsPanel.classList.add("visible");
      recommendationsStatus.textContent =
        "Gerando perguntas complementares essenciais com base na queixa e no SOAP...";
      recommendationsStatus.classList.add("loading-dot");
      recommendationsList.innerHTML = "";


      try {
        const resp = await fetch(BACKEND_URL + "/api/recomendacoes-anamnese", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            soap: combinedSoap
          })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error(
            "Erro HTTP do backend (recomendações):",
            resp.status,
            txt
          );
          recommendationsStatus.textContent =
            "Não foi possível gerar as recomendações de perguntas.";
          recommendationsStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const perguntas = Array.isArray(data.perguntas) ? data.perguntas : [];

        if (!perguntas.length) {
          recommendationsStatus.textContent =
            "Nenhuma pergunta complementar foi sugerida para este caso.";
          recommendationsStatus.classList.remove("loading-dot");
          return;
        }

        recommendationsList.innerHTML = "";
        perguntas.forEach((q, index) => {
          const item = document.createElement("div");
          item.className = "recommendation-item";
          item.textContent = (index + 1) + ". " + q;
          recommendationsList.appendChild(item);
        });

        recommendationsStatus.textContent =
          "Use estas perguntas para aprofundar a anamnese com o paciente.";
        recommendationsStatus.classList.remove("loading-dot");
        askQuestionsBtn.disabled = false;
      } catch (err) {
        console.error("Erro geral ao buscar recomendações:", err);
        recommendationsStatus.textContent =
          "Erro ao gerar recomendações de perguntas.";
        recommendationsStatus.classList.remove("loading-dot");
      }
    }

    async function handleAskQuestionsFromPanel() {
      if (!questionsIsRecording) {
        startQuestionsRecording();
      } else {
        await stopQuestionsRecordingAndUpdateSoap();
      }
    }

    function startRecording() {
      if (!recognition) {
        initSpeech();
        if (!recognition) {
          return;
        }
      }

      isRecording = true;
      isPaused = false;
      finalTranscript = "";
      baseTranscript = "";
      resultsCard.classList.add("hidden");
      printBtn.style.display = "none";
      prescriptionOutput.value = "";
      soapS.value = "";
      soapO.value = "";
      soapA.value = "";
      soapP.value = "";
      resetNewModulesUI();

      pauseBtn.style.display = "inline-block";
      pauseBtn.innerText = "Pausar";
      recordBtn.className = "recording";
      recordBtn.innerText = "Encerrar consulta";
      micStatus.innerText = "Gravando consulta...";
      soapError.textContent = "";
      resultsCard.classList.add("hidden");

      resetLiveGuidanceState();
      renderLiveGuidance();
      startGuidanceLoop();

      resetTimer();
      startTimer();

      try {
        recognition.start();
      } catch (e) {
        console.warn("Erro ao iniciar reconhecimento:", e);
      }
    }

    function stopRecording() {
      isRecording = false;
      isPaused = false;

      stopGuidanceLoop();
      interimTranscript = "";
      renderLiveGuidance();

      if (recognition) {
        try {
          recognition.stop();
        } catch (e) {
          console.warn("Erro ao parar reconhecimento:", e);
        }
      }
      pauseTimer();
      recordBtn.className = "start";
      recordBtn.innerText = "Iniciar atendimento";
      pauseBtn.style.display = "none";
    }

    function pauseRecording() {
      if (!isRecording || isPaused) return;
      isPaused = true;

      stopGuidanceLoop();
      if (liveGuidanceStatus) liveGuidanceStatus.textContent = "Consulta pausada. As sugestões em tempo real serão retomadas ao retomar a gravação.";

      if (recognition) {
        try {
          recognition.stop();
        } catch (e) {
          console.warn("Erro ao pausar reconhecimento:", e);
        }
      }
      pauseTimer();
      pauseBtn.innerText = "Retomar";
      micStatus.innerText = "Consulta pausada.";
    }

    function resumeRecording() {
      if (!isRecording || !isPaused) return;
      isPaused = false;

      startGuidanceLoop();

      if (recognition) {
        try {
          recognition.start();
        } catch (e) {
          console.warn("Erro ao retomar reconhecimento:", e);
        }
      }
      startTimer();
      pauseBtn.innerText = "Pausar";
      micStatus.innerText = "Gravando consulta...";
    }

    
    function copyToClipboard(text) {
      if (!text) return;
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).catch(() => {
          alert("Não foi possível copiar o texto.");
        });
      } else {
        const temp = document.createElement("textarea");
        temp.value = text;
        document.body.appendChild(temp);
        temp.select();
        try {
          document.execCommand("copy");
        } catch (e) {
          alert("Não foi possível copiar o texto.");
        }
        document.body.removeChild(temp);
      }
    }

    function showImageChoice(cameraInputEl, fileInputEl) {
      pendingCameraInput = cameraInputEl || null;
      pendingFileInput = fileInputEl || null;
      if (!imageChoiceOverlay) return;
      imageChoiceOverlay.classList.remove("hidden");
    }

    function hideImageChoice() {
      if (!imageChoiceOverlay) return;
      imageChoiceOverlay.classList.add("hidden");
      pendingCameraInput = null;
      pendingFileInput = null;
    }

    async function fileToDataUrl(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(String(reader.result || ""));
        reader.onerror = () => reject(new Error("Falha ao ler a imagem."));
        reader.readAsDataURL(file);
      });
    }

    async function analyzeWoundWithImage(dataUrl) {
      if (!presentationsMaxDoseStatus || !presentationsMaxDoseBox) return;
      presentationsMaxDoseStatus.textContent = "Analisando imagem da lesão.";
      presentationsMaxDoseBox.textContent = "Processando.";
      try {
        const resp = await fetch(BACKEND_URL + "/api/analisar-lesao-imagem", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ image_data_url: dataUrl })
        });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) throw new Error(data?.error || "Falha ao analisar imagem.");
        const texto = (data?.texto || "").trim();
        presentationsMaxDoseBox.textContent = texto || "Nenhum conteúdo disponível.";
        presentationsMaxDoseStatus.textContent = "Análise concluída.";
      } catch (e) {
        presentationsMaxDoseStatus.textContent = "Falha ao analisar imagem.";
        presentationsMaxDoseBox.textContent = "Nenhum conteúdo disponível.";
      }
    }

    async function analyzePrescriptionWithImage(dataUrl) {
      if (!interactionsStatus || !interactionsBox) return;
      interactionsStatus.textContent = "Analisando prescrição.";
      interactionsBox.textContent = "Processando.";
      try {
        const resp = await fetch(BACKEND_URL + "/api/analisar-prescricao-imagem", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ image_data_url: dataUrl })
        });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) throw new Error(data?.error || "Falha ao analisar prescrição.");
        const texto = (data?.texto || "").trim();
        interactionsBox.textContent = texto || "Nenhum conteúdo disponível.";
        interactionsStatus.textContent = "Análise concluída.";
      } catch (e) {
        interactionsStatus.textContent = "Falha ao analisar prescrição.";
        interactionsBox.textContent = "Nenhum conteúdo disponível.";
      }
    }

    function getSoapSectionText(letter) {
      switch (letter) {
        case "S":
          return soapS.value.trim();
        case "O":
          return soapO.value.trim();
        case "A":
          return soapA.value.trim();
        case "P":
          return soapP.value.trim();
        default:
          return "";
      }
    }

    function openPrintWindow(title, text) {
      const content = (text || "").trim();
      if (!content) {
        alert("Não há conteúdo para imprimir.");
        return;
      }

      const w = window.open("", "_blank", "width=800,height=600");
      if (!w) {
        alert("Não foi possível abrir a janela de impressão.");
        return;
      }

      w.document.write("<html><head><title>" + escapeHtml(title) + "</title></head><body>");
      w.document.write("<pre style='font-family: Arial, sans-serif; white-space: pre-wrap;'>" +
        escapeHtml(content) +
        "</pre>");
      w.document.write("</body></html>");
      w.document.close();
      w.focus();
      w.print();
    }

    
    function extractMedicationsFromPrescriptionText(text) {
      const raw = String(text || "").replace(/\r/g, "").trim();
      if (!raw) return [];

      const lines = raw.split("\n").map(l => l.trim()).filter(Boolean);

      const meds = [];

      // Heurística principal:
      // - Prescrição ambulatorial: medicamentos aparecem em lista numerada e a seção "Orientações:" deve ser ignorada.
      // - Prescrição hospitalar: medicamentos aparecem em bullets dentro das seções
      //   "Medicamentos contínuos:" e/ou "Medicamentos se necessário:".

      const isHospital =
        lines.some(l => /^medicamentos\s+cont[ií]nuos\s*:/i.test(l)) ||
        lines.some(l => /^medicamentos\s+se\s+necess[aá]rio\s*:/i.test(l)) ||
        lines.some(l => /^medicamentos\s+se\s+necessario\s*:/i.test(l));

      if (!isHospital) {
        for (const line of lines) {
          const low = line.toLowerCase();

          // Para de coletar ao entrar em orientações/assinatura
          if (low.startsWith("orientações:") || low.startsWith("orientacoes:")) break;
          if (low.startsWith("assinatura:")) break;
          if (low.startsWith("médico") || low.startsWith("medico")) break;

          const m = line.match(/^\s*\d+\s*[\.\)]\s*([^—–-]+?)\s*(?:[—–-].*)?$/);
          if (m && m[1]) {
            const name = m[1].trim();
            if (name && name.length >= 2) meds.push(name);
          }
        }
      } else {
        let section = null; // "cont", "prn", "other"

        for (const line of lines) {
          const low = line.toLowerCase();

          if (/^medicamentos\s+cont[ií]nuos\s*:/i.test(line) || /^medicamentos\s+continuos\s*:/i.test(line)) {
            section = "cont";
            continue;
          }
          if (/^medicamentos\s+se\s+necess[aá]rio\s*:/i.test(line) || /^medicamentos\s+se\s+necessario\s*:/i.test(line)) {
            section = "prn";
            continue;
          }

          // Qualquer outro cabeçalho em formato "X:" encerra a seção de medicamentos
          if (/^[a-zA-ZÀ-ÿ].*:\s*$/.test(line) && !/^medicamentos\s+/i.test(line)) {
            section = "other";
            continue;
          }

          // Captura bullets apenas nas seções corretas
          const isBullet = /^\s*[-•]\s+/.test(line);
          if (!isBullet) continue;
          if (section !== "cont" && section !== "prn") continue;

          const m = line.match(/^\s*[-•]\s*([^—–-]+?)\s*(?:[—–-].*)?$/);
          if (!m || !m[1]) continue;

          const name = m[1].trim();
          if (!name || name.length < 2) continue;
          if (/^(n[aã]o informado)$/i.test(name)) continue;

          meds.push(name);
        }
      }

      // Deduplicação preservando ordem
      const seen = new Set();
      const unique = [];
      for (const x of meds) {
        const key = x.toLowerCase();
        if (seen.has(key)) continue;
        seen.add(key);
        unique.push(x);
      }

      return unique.slice(0, 60);
    }

    function getAllPrescribedMedications() {
      const amb = prescriptionOutput.value || "";
      const hosp = hospitalPrescriptionOutput.value || "";
      const meds = [
        ...extractMedicationsFromPrescriptionText(amb),
        ...extractMedicationsFromPrescriptionText(hosp)
      ];

      const seen = new Set();
      const unique = [];
      for (const x of meds) {
        const key = x.toLowerCase();
        if (seen.has(key)) continue;
        seen.add(key);
        unique.push(x);
      }
      return unique.slice(0, 60);
    }

    async function generateHospitalPrescription() {
      hospitalPrescriptionStatus.textContent = "";
      const transcricao = (baseTranscript || finalTranscript || "").trim();

      if (!transcricao) {
        hospitalPrescriptionStatus.textContent = "Não há transcrição disponível para gerar o SBAR.";
        return;
      }

      hospitalPrescriptionStatus.textContent = "Gerando SBAR...";
      hospitalPrescriptionStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/prescricao-hospitalar", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao, tipo_documento: (reportDocTypeSelect && reportDocTypeSelect.value && reportDocTypeSelect.value !== "auto") ? reportDocTypeSelect.value : null })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (SBAR):", resp.status, txt);
          hospitalPrescriptionStatus.textContent = "Não foi possível gerar a SBAR.";
          hospitalPrescriptionStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const presc = data.prescricao_hospitalar || "";

        hospitalPrescriptionOutput.value = presc;
        hospitalPrescriptionStatus.textContent = presc ? "Prescrição hospitalar gerada." : "Não foi possível gerar a SBAR.";
        hospitalPrescriptionStatus.classList.remove("loading-dot");

        await updateClassifications();
        await updateRiskTriage();
      } catch (err) {
        console.error("Erro ao gerar SBAR:", err);
        hospitalPrescriptionStatus.textContent = "Erro ao gerar SBAR.";
        hospitalPrescriptionStatus.classList.remove("loading-dot");
      }
    }

    function formatClassificationList(items) {
      if (!Array.isArray(items) || !items.length) {
        return "Nenhum conteúdo disponível.";
      }
      const lines = [];
      for (const it of items) {
        const med = (it && it.medicamento) ? String(it.medicamento) : "não informado";
        const cat = (it && it.categoria) ? String(it.categoria) : "NA";
        const desc = (it && it.descricao) ? String(it.descricao) : "categoria não informada (dados insuficientes)";
        if (cat === "NA") {
          lines.push(med + ": categoria não informada (dados insuficientes)");
        } else {
          lines.push(med + ": " + cat + " (" + desc + ")");
        }
      }
      return lines.join("\n");
    }

    async function updateClassifications() {
      classificationsStatus.textContent = "";

      const contexto = getNursingContext();
      if (!contexto) {
        pregnancyBox.textContent = "Nenhum conteúdo disponível.";
        lactationBox.textContent = "Nenhum conteúdo disponível.";
        return;
      }

      classificationsStatus.textContent = "Gerando SAE e orientações...";
      classificationsStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/classificar-gestacao-lactacao", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ contexto })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP:", resp.status, txt);
          pregnancyBox.textContent = "Falha ao gerar SAE.";
          lactationBox.textContent = "Falha ao gerar orientações.";
          return;
        }

        const data = await resp.json().catch(() => ({}));
        pregnancyBox.textContent = (data.sae || "").trim() || "Nenhum conteúdo disponível.";
        lactationBox.textContent = (data.orientacoes || "").trim() || "Nenhum conteúdo disponível.";
      } catch (e) {
        console.error(e);
        pregnancyBox.textContent = "Falha ao gerar SAE (rede/backend).";
        lactationBox.textContent = "Falha ao gerar orientações (rede/backend).";
      } finally {
        classificationsStatus.classList.remove("loading-dot");
        classificationsStatus.textContent = "";
      }
    }

    let reportTimerInterval = null;
    let reportTimerSeconds = 0;

    function formatSecondsMMSS(totalSeconds) {
      const secs = Math.max(0, Number(totalSeconds) || 0);
      const m = ("0" + Math.floor(secs / 60)).slice(-2);
      const s = ("0" + (secs % 60)).slice(-2);
      return `${m}:${s}`;
    }

    function updateReportStatusTimer() {
      if (!reportIsRecording) return;
      const mmss = formatSecondsMMSS(reportTimerSeconds);
      reportStatus.textContent = `Gravando relatório... ${mmss}`;
    }

    function startReportStatusTimer() {
      reportTimerSeconds = 0;
      if (reportTimerInterval) clearInterval(reportTimerInterval);
      updateReportStatusTimer();
      reportTimerInterval = setInterval(() => {
        reportTimerSeconds += 1;
        updateReportStatusTimer();
      }, 1000);
    }

    function stopReportStatusTimer() {
      if (reportTimerInterval) clearInterval(reportTimerInterval);
      reportTimerInterval = null;
    }


    function initReportSpeech() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        reportStatus.textContent =
          "Seu navegador não suporta reconhecimento de voz. Use Google Chrome em um computador.";
        return null;
      }

      const rec = new SR();
      rec.lang = "pt-BR";
      rec.continuous = true;
      rec.interimResults = true;

      rec.onresult = (event) => {
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            reportFinalTranscript += transcript + " ";
          }
        }
      };

      rec.onerror = (event) => {
        console.error("Erro no reconhecimento do relatório:", event.error);
        reportStatus.textContent =
          "Ocorreu um erro no reconhecimento de voz do relatório. Tente novamente.";
      };

      rec.onend = () => {
        if (reportIsRecording && !reportIsPaused) {
          try {
            rec.start();
          } catch (err) {
            console.warn("Não foi possível retomar reconhecimento do relatório:", err);
          }
        }
      };

      return rec;
    }

    async function startReportRecording() {
      reportStatus.textContent = "";
      reportOutput.value = "";
      reportFinalTranscript = "";
      if (reportDocTypeDetected) reportDocTypeDetected.textContent = "";
      if (reportMissingFields) reportMissingFields.textContent = "";

      if (!reportRecognition) {
        reportRecognition = initReportSpeech();
        if (!reportRecognition) return;
      }

      reportIsRecording = true;
      reportIsPaused = false;

      reportRecordBtn.className = "small-record-btn recording";
      reportRecordBtn.innerText = "Encerrar gravação";
      reportStatus.textContent = "Gravando documento...";
      reportStatus.classList.remove("loading-dot");
      reportStatus.classList.add("loading-dot");

      startReportStatusTimer();

      try {
        reportRecognition.start();
      } catch (e) {
        console.warn("Erro ao iniciar reconhecimento do relatório:", e);
      }
    }

    async function stopReportRecordingAndGenerate() {
      reportIsRecording = false;
      reportIsPaused = false;

      if (reportRecognition) {
        try {
          reportRecognition.stop();
        } catch (e) {
          console.warn("Erro ao parar reconhecimento do relatório:", e);
        }
      }

      stopReportStatusTimer();

      reportRecordBtn.className = "small-record-btn start";
      reportRecordBtn.innerText = "Gravar documento";

      const transcricao = reportFinalTranscript.trim();
      if (!transcricao) {
        reportStatus.classList.remove("loading-dot");
        reportStatus.textContent = "Nenhuma fala foi capturada no relatório.";
        return;
      }

      reportStatus.textContent = "Gerando documento...";
      reportStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/gerar-relatorio", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (relatório):", resp.status, txt);
          reportStatus.textContent = "Não foi possível gerar o relatório.";
          reportStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const documento = (data && (data.documento || data.relatorio)) ? String(data.documento || data.relatorio) : "";
        const tipoIdentificado = (data && data.tipo_documento) ? String(data.tipo_documento) : "";
        const pendentes = Array.isArray(data?.campos_pendentes) ? data.campos_pendentes : (Array.isArray(data?.campos_faltantes) ? data.campos_faltantes : []);

        if (reportDocTypeDetected) reportDocTypeDetected.textContent = tipoIdentificado ? tipoIdentificado : "não informado";
        if (reportMissingFields) reportMissingFields.textContent = pendentes.length ? pendentes.join("\n") : "Nenhum";

        reportOutput.value = normalizeNumberedParagraphs(documento);

        reportStatus.textContent = documento ? "Documento gerado." : "Não foi possível gerar o documento.";
        reportStatus.classList.remove("loading-dot");
      } catch (err) {
        console.error("Erro ao gerar relatório:", err);
        reportStatus.textContent = "Erro ao gerar relatório.";
        reportStatus.classList.remove("loading-dot");
      }
    }

    async function submitMedicalDoubt() {
      const q = (medicalDoubtInput.value || "").trim();
      if (!q) return;

      medicalDoubtStatus.textContent = "Respondendo dúvida...";
      medicalDoubtStatus.classList.add("loading-dot");
      medicalDoubtAnswer.textContent = "";

      try {
        const resp = await fetch(BACKEND_URL + "/api/duvidas-enfermagem", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ duvida: q })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (dúvidas):", resp.status, txt);
          medicalDoubtStatus.textContent = "Não foi possível responder a dúvida.";
          medicalDoubtStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const resposta = data.resposta || "";
        medicalDoubtAnswer.textContent = resposta || "Sem resposta disponível.";
        medicalDoubtStatus.textContent = "Resposta gerada.";
        medicalDoubtStatus.classList.remove("loading-dot");
      } catch (err) {
        console.error("Erro ao responder dúvida:", err);
        medicalDoubtStatus.textContent = "Erro ao responder a dúvida.";
        medicalDoubtStatus.classList.remove("loading-dot");
      }
    }

    recordBtn.onclick = () => {
      if (!isRecording) {
        startRecording();
      } else {
        stopRecording();
        finalizarConsulta();
      }
    };

    pauseBtn.onclick = () => {
      if (!isRecording) return;
      if (!isPaused) {
        pauseRecording();
      } else {
        resumeRecording();
      }
    };

    printBtn.onclick = () => {
      openPrintWindow("Plano de Cuidados (Prescrição de Enfermagem)", prescriptionOutput.value);
    };

    recommendationsBtn.addEventListener("click", () => {
      fetchRecommendations();
    });

    closeRecommendationsBtn.addEventListener("click", () => {
      if (questionsIsRecording) {
        recommendationsStatus.textContent =
          "Finalize a gravação das perguntas clicando em \"Encerrar perguntas\" antes de fechar.";
        return;
      }
      recommendationsPanel.classList.remove("visible");
    });

    askQuestionsBtn.addEventListener("click", () => {
      handleAskQuestionsFromPanel();
    });

    soapCopyButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const part = btn.getAttribute("data-part");
        const sectionText = getSoapSectionText(part);
        if (!sectionText) {
          alert("Seção " + part + " está vazia.");
          return;
        }
        copyToClipboard(part + ": " + sectionText);
      });

    if (copyFullSoapBtn) {
      copyFullSoapBtn.addEventListener("click", () => {
        const full = getCombinedSoapFromFields();
        if (!full.trim()) {
          alert("Não há SOAP disponível para copiar.");
          return;
        }
        copyToClipboard(full);
      });
    }

    if (printSoapBtn) {
      printSoapBtn.addEventListener("click", () => {
        const full = getCombinedSoapFromFields();
        openPrintWindow("SOAP", full);
      });
    }

    copyPrescriptionBtn.addEventListener("click", () => {
      const text = prescriptionOutput.value.trim();
      if (!text) {
        alert("Não há prescrição para copiar.");
        return;
      }
      copyToClipboard(text);
    });

    generateHospitalPrescriptionBtn.addEventListener("click", () => {
      generateHospitalPrescription();
    });

    copyHospitalPrescriptionBtn.addEventListener("click", () => {
      const text = hospitalPrescriptionOutput.value.trim();
      if (!text) {
        alert("Não há SBAR para copiar.");
        return;
      }
      copyToClipboard(text);
    });

    printHospitalPrescriptionBtn.addEventListener("click", () => {
      openPrintWindow("Passagem de Plantão (SBAR)", hospitalPrescriptionOutput.value);
    });

    if (printRiskTriageBtn) {
      printRiskTriageBtn.addEventListener("click", () => {
        const text = (riskTriageMeaning && riskTriageMeaning.dataset && riskTriageMeaning.dataset.printText) ? riskTriageMeaning.dataset.printText : "";
        openPrintWindow("Classificação de risco por cores", text);
      });
    }

    
    if (copySaeBtn) {
      copySaeBtn.addEventListener("click", () => {
        const text = (pregnancyBox && pregnancyBox.textContent) ? pregnancyBox.textContent.trim() : "";
        if (!text) {
          alert("Não há SAE para copiar.");
          return;
        }
        copyToClipboard(text);
      });
    }

    if (copyOrientationsBtn) {
      copyOrientationsBtn.addEventListener("click", () => {
        const text = (lactationBox && lactationBox.textContent) ? lactationBox.textContent.trim() : "";
        if (!text) {
          alert("Não há orientações para copiar.");
          return;
        }
        copyToClipboard(text);
      });
    }

    if (copyRiskTriageBtn) {
      copyRiskTriageBtn.addEventListener("click", () => {
        const text = (riskTriageMeaning && riskTriageMeaning.dataset && riskTriageMeaning.dataset.printText) ? riskTriageMeaning.dataset.printText : "";
        if (!text.trim()) {
          alert("Não há classificação de risco para copiar.");
          return;
        }
        copyToClipboard(text);
      });
    }
    });

    printPregnancyBtn.addEventListener("click", () => {
      openPrintWindow("SAE (Processo de Enfermagem)", pregnancyBox.textContent);
    });

    printLactationBtn.addEventListener("click", () => {
      openPrintWindow("Orientações ao paciente", lactationBox.textContent);
    });


    if (chooseCameraBtn) {
      chooseCameraBtn.addEventListener("click", () => {
        const input = pendingCameraInput;
        hideImageChoice();
        if (input) input.click();
      });
    }

    if (chooseFileBtn) {
      chooseFileBtn.addEventListener("click", () => {
        const input = pendingFileInput;
        hideImageChoice();
        if (input) input.click();
      });
    }

    if (cancelImageChoiceBtn) {
      cancelImageChoiceBtn.addEventListener("click", () => {
        hideImageChoice();
      });
    }

    if (imageChoiceOverlay) {
      imageChoiceOverlay.addEventListener("click", (e) => {
        if (e.target === imageChoiceOverlay) hideImageChoice();
      });
    }

    if (woundPhotoBtn) {
      woundPhotoBtn.addEventListener("click", () => {
        showImageChoice(woundCameraInput, woundFileInput);
      });
    }

    if (medPhotoBtn) {
      medPhotoBtn.addEventListener("click", () => {
        showImageChoice(medCameraInput, medFileInput);
      });
    }

    if (woundCameraInput) {
      woundCameraInput.addEventListener("change", async (e) => {
        const file = e.target.files && e.target.files[0];
        woundCameraInput.value = "";
        if (!file) return;
        const dataUrl = await fileToDataUrl(file);
        await analyzeWoundWithImage(dataUrl);
      });
    }

    if (woundFileInput) {
      woundFileInput.addEventListener("change", async (e) => {
        const file = e.target.files && e.target.files[0];
        woundFileInput.value = "";
        if (!file) return;
        const dataUrl = await fileToDataUrl(file);
        await analyzeWoundWithImage(dataUrl);
      });
    }

    if (medCameraInput) {
      medCameraInput.addEventListener("change", async (e) => {
        const file = e.target.files && e.target.files[0];
        medCameraInput.value = "";
        if (!file) return;
        const dataUrl = await fileToDataUrl(file);
        await analyzePrescriptionWithImage(dataUrl);
      });
    }

    if (medFileInput) {
      medFileInput.addEventListener("change", async (e) => {
        const file = e.target.files && e.target.files[0];
        medFileInput.value = "";
        if (!file) return;
        const dataUrl = await fileToDataUrl(file);
        await analyzePrescriptionWithImage(dataUrl);
      });
    }

    if (copyWoundBtn) {
      copyWoundBtn.addEventListener("click", () => {
        const text = (presentationsMaxDoseBox && presentationsMaxDoseBox.textContent) ? presentationsMaxDoseBox.textContent.trim() : "";
        if (!text) {
          alert("Não há prescrição e cuidados para copiar.");
          return;
        }
        copyToClipboard(text);
      });
    }

    if (printWoundBtn) {
      printWoundBtn.addEventListener("click", () => {
        openPrintWindow("Curativos e feridas", presentationsMaxDoseBox ? presentationsMaxDoseBox.textContent : "");
      });
    }

    if (copyMedSafetyBtn) {
      copyMedSafetyBtn.addEventListener("click", () => {
        const text = (interactionsBox && interactionsBox.textContent) ? interactionsBox.textContent.trim() : "";
        if (!text) {
          alert("Não há conteúdo para copiar.");
          return;
        }
        copyToClipboard(text);
      });
    }

    if (printMedSafetyBtn) {
      printMedSafetyBtn.addEventListener("click", () => {
        openPrintWindow("Administração segura de medicamentos (registro de enfermagem)", interactionsBox ? interactionsBox.textContent : "");
      });
    }



    const consultTypeButtons = Array.from(document.querySelectorAll(".consult-type-btn"));
    const consultGuideDrawer = document.getElementById("consultGuideDrawer");
    const consultGuideTitle = document.getElementById("consultGuideTitle");
    const consultGuideSubtitle = document.getElementById("consultGuideSubtitle");
    const consultGuideContent = document.getElementById("consultGuideContent");
    const closeConsultGuideBtn = document.getElementById("closeConsultGuideBtn");
    const prenatalTrimesterRow = document.getElementById("prenatalTrimesterRow");
    const trimesterButtons = Array.from(document.querySelectorAll(".trimester-btn"));

    let selectedConsultType = null;
    let selectedPrenatalTrimester = "1";

    const guideData = {
      puericultura: {
        title: "Consulta de puericultura",
        subtitle: "Sequência sugerida para orientar perguntas e procedimentos iniciais.",
        sections: [
          {
            title: "Perguntas essenciais",
            items: [
              "Identificação e contexto: idade, cuidador presente, motivo da consulta, dúvidas principais da família.",
              "História desde a última consulta: intercorrências, internações, uso de medicamentos, alergias, exposição a doentes.",
              "Alimentação: aleitamento materno (exclusivo ou não), fórmula, frequência, aceitação, introdução alimentar (se aplicável), consumo de água, ingestão de ultraprocessados.",
              "Eliminações: diurese, evacuações (frequência, consistência, sangue, dor), sinais de desidratação.",
              "Sono e rotina: padrão de sono, despertares, ambiente, segurança do sono, telas.",
              "Desenvolvimento: marcos motores e linguagem conforme idade, interação social, audição/visão percebidas, comportamento.",
              "Segurança e ambiente: quedas, engasgo, afogamento, acidentes domésticos, cadeira no carro, fumaça, violência, condições de moradia.",
              "Vacinas: conferir caderneta, doses atrasadas, reações prévias.",
              "Saúde bucal: higiene, erupção dentária, uso de flúor (conforme orientação local)."
            ]
          },
          {
            title: "Procedimentos e exame físico",
            items: [
              "Sinais vitais quando indicado: temperatura, frequência cardíaca e respiratória, saturação se sintomas respiratórios.",
              "Antropometria: peso, estatura/comprimento, perímetro cefálico (especialmente em menores), cálculo e registro na curva (OMS).",
              "Exame físico direcionado: pele e mucosas, hidratação, orofaringe, otoscopia se queixa, ausculta cardíaca e pulmonar, abdome, genitais quando indicado.",
              "Triagem de sinais de gravidade: prostração, desconforto respiratório, sinais de desidratação, febre persistente, convulsão, cianose, recusa de líquidos.",
              "Orientações finais: alimentação por faixa etária, sinais de alarme, retorno programado e vacinação."
            ]
          }
        ]
      },

      planejamento: {
        title: "Consulta de planejamento familiar",
        subtitle: "Sequência sugerida para escolha do método com segurança.",
        sections: [
          {
            title: "Perguntas essenciais",
            items: [
              "Objetivo do paciente: evitar gestação, espaçar, planejar para quando, ou tratar sintomas (sangramento, cólica).",
              "História reprodutiva: gestações, partos, abortos, complicações, lactação atual, desejo reprodutivo do casal.",
              "Data da última menstruação, regularidade do ciclo, sangramentos anormais, suspeita de gestação atual.",
              "Doenças e riscos: hipertensão, diabetes, enxaqueca com aura, trombose, doença hepática, câncer de mama, tabagismo, pós-parto recente.",
              "Medicamentos em uso e possíveis interações (ex.: indutores enzimáticos).",
              "História ginecológica: IST prévias, corrimentos, dor pélvica, última citologia conforme protocolo local.",
              "Risco de IST e necessidade de dupla proteção (preservativo).",
              "Preferências: método diário ou de longa duração, desejo de método sem hormônio, tolerância a sangramento irregular."
            ]
          },
          {
            title: "Procedimentos e orientações",
            items: [
              "Sinais vitais e avaliação clínica básica: pressão arterial e peso/IMC (essencial antes de métodos combinados).",
              "Teste de gravidez quando houver dúvida ou critério clínico.",
              "Aconselhamento estruturado: eficácia, modo de uso, efeitos adversos, contraindicações e sinais de alarme do método escolhido.",
              "Reforçar preservativo para IST e como usar corretamente.",
              "Planejar retorno: adaptação do método, manejo de efeitos e revisão de segurança."
            ]
          }
        ]
      },

      hiperdia: {
        title: "Consulta de Hiperdia (HAS e/ou DM)",
        subtitle: "Sequência sugerida para acompanhamento e segurança do cuidado.",
        sections: [
          {
            title: "Perguntas essenciais",
            items: [
              "Motivo da consulta: rotina, sintomas, aferições alteradas, falta de medicação, intercorrências recentes.",
              "Adesão ao tratamento: horários, esquecimento, efeitos adversos, dificuldades de acesso aos medicamentos.",
              "Pressão e glicemias: valores recentes, sintomas de hipo/hiperglicemia, desmaios, palpitações, cefaleia, visão turva.",
              "Estilo de vida: alimentação, sal, açúcar, atividade física, álcool, tabagismo, sono e estresse.",
              "Complicações e rastreios: dor torácica, dispneia, edema, claudicação, feridas nos pés, perda de sensibilidade, alterações visuais, sintomas urinários.",
              "Comorbidades: doença renal, AVC prévio, infarto, dislipidemia; vacinas e cuidados preventivos."
            ]
          },
          {
            title: "Procedimentos e exame físico",
            items: [
              "Aferir sinais vitais: pressão arterial, frequência cardíaca, peso, circunferência abdominal quando aplicável.",
              "Glicemia capilar quando indicado; registrar jejum/pós-prandial conforme contexto.",
              "Avaliação de pés (DM): inspeção, pulsos, sensibilidade (monofilamento se disponível), orientações de autocuidado.",
              "Sinais de gravidade: PA muito elevada com sintomas, hipoglicemia, hiperglicemia importante com sinais de desidratação, dor torácica, dispneia.",
              "Reforçar plano: metas, adesão, autocuidado, retorno e quando procurar urgência."
            ]
          }
        ]
      },


      puerperio: {
        title: "Consulta de puerpério",
        subtitle: "Avalie recuperação materna, amamentação, sinais de infecção e saúde mental no pós-parto.",
        sections: [
          {
            title: "Perguntas essenciais",
            items: [
              "Data do parto e tipo de parto (vaginal/cesárea) e intercorrências no parto e pós-parto imediato.",
              "Sangramento (lóquios): quantidade, cor e odor; presença de coágulos; piora súbita do sangramento; tontura ou fraqueza.",
              "Dor: intensidade e localização (períneo, incisão cirúrgica, abdome, mamas); necessidade e adesão a analgésicos prescritos.",
              "Febre ou calafrios; mal-estar; disúria; corrimento vaginal com odor fétido.",
              "Amamentação: pega e posição, dor/fissuras, ingurgitamento, mastite (dor localizada, rubor, febre), frequência das mamadas, dificuldades para ordenhar/armazenar.",
              "Eliminações: diurese e evacuação (constipação), dor ao evacuar, hemorroidas.",
              "Sono e suporte familiar; alimentação e hidratação; retorno às atividades e rede de apoio.",
              "Saúde mental: humor, ansiedade, irritabilidade, choro frequente, anedonia; ideias de autoagressão; percepção de vínculo com o bebê.",
              "Planejamento reprodutivo: desejo contraceptivo, método em uso, dúvidas; retorno da atividade sexual e orientações de prevenção de IST.",
              "Vacinas e consultas de seguimento; exames ou orientações dadas na alta."
            ]
          },
          {
            title: "Procedimentos e exame físico",
            items: [
              "Aferir sinais vitais; avaliar palidez, hidratação e sinais de gravidade.",
              "Avaliar útero e involução uterina quando aplicável (dor importante, sensibilidade, subinvolução suspeita).",
              "Avaliar ferida operatória (cesárea) ou períneo/episiotomia quando indicado: hiperemia, secreção, deiscência, dor desproporcional.",
              "Avaliar mamas: ingurgitamento, fissuras, áreas de rubor/calor/dor; orientar ordenha, pega correta e manejo de fissuras.",
              "Orientar sinais de alarme e encaminhar/acionar serviço de urgência quando: sangramento intenso, febre, odor fétido importante, dor intensa, sinais de trombose (dor/inchaço em perna), dispneia ou dor torácica.",
              "Reforçar cuidados gerais: higiene perineal, hidratação, alimentação, repouso possível, retorno programado e quando procurar a unidade.",
              "Registrar orientações e, se necessário, encaminhar para avaliação médica, serviço social ou saúde mental conforme achados."
            ]
          }
        ]
      },

      prenatal: {
        title: "Consulta pré-natal",
        subtitle: "Escolha o trimestre para ver perguntas e procedimentos em ordem.",
        trimesters: {
          "1": {
            subtitle: "1º trimestre (até 13 semanas e 6 dias)",
            sections: [
              {
                title: "Perguntas essenciais",
                items: [
                  "Identificação e dados essenciais: nome completo, idade, peso, sinais vitais iniciais e queixa/objetivo da consulta.",
                  "Data da última menstruação, regularidade menstrual, cálculo de idade gestacional e data provável do parto conforme rotina do serviço.",
                  "História obstétrica: gestações anteriores, partos, abortos, complicações (pré-eclâmpsia, hemorragia, prematuridade).",
                  "Sintomas atuais: náuseas/vômitos, dor abdominal, sangramento vaginal, corrimento, febre, disúria.",
                  "Comorbidades: hipertensão, diabetes, epilepsia, doença renal, tireoide, trombofilias; uso de medicamentos e suplementos.",
                  "Alergias, uso de álcool/tabaco/outras substâncias, situação social e apoio.",
                  "Vacinação e exames anteriores, histórico de IST e testagens."
                ]
              },
              {
                title: "Procedimentos e exame físico",
                items: [
                  "Aferir sinais vitais e peso; calcular IMC e registrar.",
                  "Avaliar edema, sinais de anemia/desidratação e exame clínico direcionado.",
                  "Solicitar/confirmar exames iniciais conforme rotina local: hemograma, tipagem ABO/Rh e Coombs indireto quando indicado, glicemia, sorologias (sífilis, HIV, hepatites), exame de urina e urocultura, outros conforme protocolo.",
                  "Orientações: sinais de alarme (sangramento, dor forte, febre, perda de líquidos), suplementação prescrita e hábitos saudáveis.",
                  "Se idade gestacional permitir e houver recurso, auscultar batimentos cardíacos fetais conforme prática do serviço."
                ]
              }
            ]
          },
          "2": {
            subtitle: "2º trimestre (14 a 27 semanas e 6 dias)",
            sections: [
              {
                title: "Perguntas essenciais",
                items: [
                  "Evolução desde a última consulta: intercorrências, urgências, uso e adesão a medicamentos/suplementos.",
                  "Movimentação fetal (quando aplicável): início, frequência percebida, redução de movimentos.",
                  "Sintomas de alerta: cefaleia intensa, escotomas, dor epigástrica, edema importante, sangramento, perda de líquido, febre, disúria.",
                  "Revisar exames e vacinação; reforçar orientações e plano de retorno."
                ]
              },
              {
                title: "Procedimentos e exame físico",
                items: [
                  "Aferir sinais vitais e peso; avaliar edema.",
                  "Medir altura uterina e comparar com idade gestacional; avaliar apresentação quando possível.",
                  "Auscultar batimentos cardíacos fetais conforme rotina do serviço.",
                  "Revisar/solicitar exames do período conforme rotina local (inclui rastreios de anemia e diabetes gestacional quando indicado).",
                  "Orientar sinais de trabalho de parto prematuro e quando procurar urgência."
                ]
              }
            ]
          },
          "3": {
            subtitle: "3º trimestre (28 semanas até o parto)",
            sections: [
              {
                title: "Perguntas essenciais",
                items: [
                  "Movimentos fetais e percepção materna; redução de movimentos é sinal de alerta.",
                  "Sintomas de pré-eclâmpsia e urgência: cefaleia intensa, visão turva, dor epigástrica, edema súbito, falta de ar.",
                  "Sinais de trabalho de parto: contrações ritmadas, perda de tampão mucoso, sangramento, perda de líquido.",
                  "Plano de parto e rede de referência: onde buscar assistência, transporte, acompanhante, documentação.",
                  "Revisar exames do final da gestação conforme rotina local e vacinação."
                ]
              },
              {
                title: "Procedimentos e exame físico",
                items: [
                  "Aferir sinais vitais e peso; atenção reforçada à pressão arterial e edema.",
                  "Medir altura uterina, avaliar apresentação fetal e auscultar batimentos cardíacos fetais.",
                  "Reforçar orientações: sinais de alarme, preparo para o parto, amamentação e cuidados no pós-parto imediato.",
                  "Planejar retorno mais frequente conforme idade gestacional e risco."
                ]
              }
            ]
          }
        }
      }
    };

    function renderGuideSections(sections) {
      if (!consultGuideContent) return;
      const parts = [];
      for (const section of sections || []) {
        parts.push(`<div class="guide-section-title">${escapeHtml(section.title)}</div>`);
        parts.push("<ol>");
        for (const item of section.items || []) {
          parts.push(`<li>${escapeHtml(item)}</li>`);
        }
        parts.push("</ol>");
      }
      consultGuideContent.innerHTML = parts.join("");
    }

    function openGuideFor(type) {
      selectedConsultType = type;
      consultTypeButtons.forEach(btn => {
        btn.classList.toggle("active", btn.dataset.consult === type);
      });

      if (!consultGuideDrawer || !consultGuideTitle || !consultGuideSubtitle) return;

      consultGuideDrawer.classList.remove("hidden");
      const data = guideData[type];

      if (!data) {
        consultGuideTitle.textContent = "Guia não disponível";
        consultGuideSubtitle.textContent = "";
        consultGuideContent.innerHTML = "";
        prenatalTrimesterRow?.classList.add("hidden");
        return;
      }

      consultGuideTitle.textContent = data.title || "";
      consultGuideSubtitle.textContent = data.subtitle || "";

      if (type === "prenatal") {
        prenatalTrimesterRow?.classList.remove("hidden");
        setPrenatalTrimester(selectedPrenatalTrimester);
      } else {
        prenatalTrimesterRow?.classList.add("hidden");
        renderGuideSections(data.sections || []);
      }
    }

    function setPrenatalTrimester(tri) {
      selectedPrenatalTrimester = String(tri || "1");
      trimesterButtons.forEach(b => {
        b.classList.toggle("active", b.dataset.tri === selectedPrenatalTrimester);
      });

      const data = guideData.prenatal;
      const t = data?.trimesters?.[selectedPrenatalTrimester];
      if (!t) {
        consultGuideSubtitle.textContent = guideData.prenatal.subtitle || "";
        consultGuideContent.innerHTML = "";
        return;
      }

      consultGuideSubtitle.textContent = t.subtitle || guideData.prenatal.subtitle || "";
      renderGuideSections(t.sections || []);
    }

    function closeGuide() {
      consultGuideDrawer?.classList.add("hidden");
      consultTypeButtons.forEach(btn => btn.classList.remove("active"));
      selectedConsultType = null;
    }

    if (consultTypeButtons.length) {
      consultTypeButtons.forEach(btn => {
        btn.addEventListener("click", () => openGuideFor(btn.dataset.consult || ""));
      });
    }

    if (trimesterButtons.length) {
      trimesterButtons.forEach(btn => {
        btn.addEventListener("click", () => setPrenatalTrimester(btn.dataset.tri || "1"));
      });
    }

    if (closeConsultGuideBtn) {
      closeConsultGuideBtn.addEventListener("click", closeGuide);
    }


    medicalDoubtInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        submitMedicalDoubt();
      }
    });

    reportRecordBtn.addEventListener("click", () => {
      if (!reportIsRecording) {
        startReportRecording();
      } else {
        stopReportRecordingAndGenerate();
      }
    });
  
    if (copyReportBtn) {
      copyReportBtn.addEventListener("click", () => {
        const text = (reportOutput && reportOutput.value) ? reportOutput.value.trim() : "";
        if (!text) {
          reportStatus.textContent = "Não há conteúdo para copiar.";
          return;
        }
        copyToClipboard(text);
        reportStatus.textContent = "Documento copiado.";
      });
    }

    if (printReportBtn) {
      printReportBtn.addEventListener("click", () => {
        const text = (reportOutput && reportOutput.value) ? reportOutput.value.trim() : "";
        openPrintWindow("Documento de enfermagem", text);
      });
    }



    // =========================
    // ADMIN (cadastro, mensalidade, histórico e auditoria)
    // =========================
    let ADMIN_CACHE_USERS = [];
    let ADMIN_CACHE_AUDIT = [];
    let ADMIN_SELECTED_USER_ID = null;
    let ADMIN_SELECTED_USER_LABEL = "";

    function fmtDt(iso) {
      if (!iso) return "-";
      try { return new Date(iso).toLocaleString("pt-BR"); } catch { return String(iso); }
    }

    function currentYYYYMM() {
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      return `${y}-${m}`;
    }

    async function adminFetchJson(path, options) {
      const resp = await fetch(BACKEND_URL + path, Object.assign({ method: "GET" }, options || {}));
      const data = await resp.json().catch(() => ({}));
      if (!resp.ok) throw new Error(data.error || ("Falha: " + resp.status));
      return data;
    }

    async function autoRecoverIfEmpty() {
      try {
        if (RECOVERY_RUNNING) return;
        if (RECOVERY_TRIED) return;
        const payload = getLocalBackupPayload();
        const hasUsers = payload && Array.isArray(payload.users) && payload.users.length > 0;
        if (!hasUsers) return;
        if (!Array.isArray(ADMIN_CACHE_USERS) || ADMIN_CACHE_USERS.length !== 0) return;

        RECOVERY_RUNNING = true;
        RECOVERY_TRIED = true;

        const st = document.getElementById("adminStatus");
        if (st) st.textContent = "Recuperando usuários a partir do backup local...";

        // Cria backup manual no servidor (se houver)
        try { await adminFetchJson("/api/admin/backup/create", { method: "POST" }); } catch {}

        await adminFetchJson("/api/admin/backup/import", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        await adminLoadAll();
        if (st) st.textContent = "Recuperação concluída a partir do backup local.";
      } catch (e) {
        const st = document.getElementById("adminStatus");
        if (st) st.textContent = "Falha ao recuperar do backup local: " + String(e?.message || e || "");
      } finally {
        RECOVERY_RUNNING = false;
        updateAdminLocalBackupBadge();
      }
    }

    async function adminLoadAll() {
      try {
        const [users, audit] = await Promise.all([
          adminFetchJson("/api/admin/users"),
          adminFetchJson("/api/admin/audit")
        ]);
        ADMIN_CACHE_USERS = Array.isArray(users.users) ? users.users : [];
        ADMIN_CACHE_AUDIT = Array.isArray(audit.audit) ? audit.audit : [];
        renderAdminUsers();
        renderAdminAudit();
        const sub = document.getElementById("adminSubtitle");
        if (sub) sub.textContent = `Usuários cadastrados: ${ADMIN_CACHE_USERS.length}`;
        const st = document.getElementById("adminStatus");
        if (st) st.textContent = "";
        updateAdminLocalBackupBadge();
        // Atualiza backup local com a versão do servidor (quando houver dados)
        if (ADMIN_CACHE_USERS.length > 0) { await refreshLocalBackupFromServer(); }
        // Se o servidor vier vazio (ex.: redeploy), tenta restaurar automaticamente do backup local
        await autoRecoverIfEmpty();
      } catch (e) {
        const st = document.getElementById("adminStatus");
        if (st) st.textContent = String(e.message || e);
      }
    }

    function renderAdminAudit() {
      const tbody = document.getElementById("auditTbody");
      if (!tbody) return;
      tbody.innerHTML = "";
      for (const a of ADMIN_CACHE_AUDIT.slice().reverse().slice(0, 200)) {
        const tr = document.createElement("tr");
        const tdAt = document.createElement("td");
        const tdAc = document.createElement("td");
        const tdTa = document.createElement("td");
        const tdDe = document.createElement("td");
        tdAt.textContent = fmtDt(a.at);
        tdAc.textContent = a.action || "";
        tdTa.textContent = a.target || "";
        tdDe.textContent = a.details || "";
        tr.appendChild(tdAt); tr.appendChild(tdAc); tr.appendChild(tdTa); tr.appendChild(tdDe);
        tbody.appendChild(tr);
      }
    }

    function isOnline(lastSeenAt) {
      if (!lastSeenAt) return false;
      try {
        const t = new Date(lastSeenAt).getTime();
        return (Date.now() - t) <= (2 * 60 * 1000);
      } catch {
        return false;
      }
    }

    function renderAdminUsers() {
      const tbody = document.getElementById("usersTbody");
      if (!tbody) return;
      tbody.innerHTML = "";

      const q = (document.getElementById("adminSearch")?.value || "").trim().toLowerCase();
      const rows = ADMIN_CACHE_USERS.filter(u => {
        if (!q) return true;
        const s = `${u.fullName||""} ${u.login||""} ${u.phone||""}`.toLowerCase();
        return s.includes(q);
      });

      for (const u of rows) {
        const tr = document.createElement("tr");
        const active = (u && (u.isActive !== undefined ? !!u.isActive : !!u.active));

        const tdName = document.createElement("td");
        tdName.textContent = u.fullName || "-";

        const tdLogin = document.createElement("td");
        tdLogin.textContent = u.login || "-";

        const tdPhone = document.createElement("td");
        tdPhone.textContent = u.phone || "-";

        const tdOnline = document.createElement("td");
        const on = isOnline(u.lastSeenAt);
        const pillOn = document.createElement("span");
        pillOn.className = "pill " + (on ? "green" : "gray");
        pillOn.textContent = on ? "Online" : "Offline";
        tdOnline.appendChild(pillOn);

        const tdPay = document.createElement("td");
        const paid = (u && (u.isPaidThisMonth !== undefined ? !!u.isPaidThisMonth : !!u.paidCurrentMonth));
        const pillPay = document.createElement("button");
        pillPay.type = "button";
        pillPay.className = "pill " + (paid ? "green" : "red");
        pillPay.textContent = paid ? "Em dia" : "Em atraso";
        pillPay.title = "Clique para marcar pagamento do mês";
        pillPay.addEventListener("click", async () => {
          const month = prompt("Mês no formato AAAA-MM", currentYYYYMM());
          if (!month) return;
          const amount = prompt("Valor (opcional)", "");
          const method = prompt("Método (opcional)", "PIX");
          const notes = prompt("Observações (opcional)", "");
          try {
            await adminFetchJson(`/api/admin/users/${encodeURIComponent(u.id)}/pay`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ month, amount, method, notes })
            });
            await adminLoadAll();
            await refreshLocalBackupFromServer();
          } catch (e) {
            const st = document.getElementById("adminStatus");
            if (st) st.textContent = String(e.message || e);
          }
        });
        tdPay.appendChild(pillPay);

        const tdLast = document.createElement("td");
        tdLast.textContent = u.lastLoginAt ? fmtDt(u.lastLoginAt) : "-";

        const tdActions = document.createElement("td");
        const actions = document.createElement("div");
        actions.className = "admin-actions";

        const btnEdit = document.createElement("button");
        btnEdit.className = "admin-btn secondary";
        btnEdit.type = "button";
        btnEdit.textContent = "Editar";
        btnEdit.addEventListener("click", () => {
          openEditUserModal(u);
        });

        const btnHist = document.createElement("button");
        btnHist.className = "admin-btn secondary";
        btnHist.type = "button";
        btnHist.textContent = "Histórico";
        btnHist.addEventListener("click", async () => {
          try {
            const data = await adminFetchJson(`/api/admin/users/${encodeURIComponent(u.id)}/payments`);
            openPaymentsModal(u, data.payments || []);
          } catch (e) {
            const st = document.getElementById("adminStatus");
            if (st) st.textContent = String(e.message || e);
          }
        });

        const btnActive = document.createElement("button");
        btnActive.type = "button";
        btnActive.className = "pill " + (active ? "green" : "red");
        btnActive.textContent = active ? "Ativado" : "Desativado";
        btnActive.title = "Clique para ativar/desativar. Se desativado ou em débito, o acesso do usuário será bloqueado.";
        btnActive.addEventListener("click", async () => {
          try {
            await adminFetchJson(`/api/admin/users/${encodeURIComponent(u.id)}/active`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ active: !active })
            });
            await adminLoadAll();
            await refreshLocalBackupFromServer();
          } catch (e) {
            const st = document.getElementById("adminStatus");
            if (st) st.textContent = String(e.message || e);
          }
        });

        const btnReset = document.createElement("button");
        btnReset.className = "admin-btn secondary";
        btnReset.type = "button";
        btnReset.textContent = "Reset senha";
        btnReset.addEventListener("click", async () => {
          const newPass = prompt("Nova senha (será salva)", "");
          if (!newPass) return;
          try {
            await adminFetchJson(`/api/admin/users/${encodeURIComponent(u.id)}/reset-password`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ password: newPass })
            });
            await adminLoadAll();
            await refreshLocalBackupFromServer();
          } catch (e) {
            const st = document.getElementById("adminStatus");
            if (st) st.textContent = String(e.message || e);
          }
        });

        const btnDelete = document.createElement("button");
        btnDelete.className = "admin-btn danger";
        btnDelete.type = "button";
        btnDelete.textContent = "Excluir";
        btnDelete.addEventListener("click", async () => {
          if (!confirm("Excluir este usuário? O histórico de pagamentos será preservado.")) return;
          try {
            await adminFetchJson(`/api/admin/users/${encodeURIComponent(u.id)}`, { method: "DELETE" });
            await adminLoadAll();
            await refreshLocalBackupFromServer();
          } catch (e) {
            const st = document.getElementById("adminStatus");
            if (st) st.textContent = String(e.message || e);
          }
        });

        actions.appendChild(btnEdit);
        actions.appendChild(btnHist);
        actions.appendChild(btnActive);
        actions.appendChild(btnReset);
        actions.appendChild(btnDelete);
        tdActions.appendChild(actions);

        tr.appendChild(tdName);
        tr.appendChild(tdLogin);
        tr.appendChild(tdPhone);
        tr.appendChild(tdOnline);
        tr.appendChild(tdPay);
        tr.appendChild(tdLast);
        tr.appendChild(tdActions);

        tbody.appendChild(tr);
      }
    }

    function openPaymentsModal(user, payments) {
      const modal = document.getElementById("paymentsModal");
      const subtitle = document.getElementById("paymentsModalSubtitle");
      const tbody = document.getElementById("paymentsTbody");
      if (!modal || !tbody) return;
      if (subtitle) subtitle.textContent = `${user.fullName || "-"} • ${user.login || "-"}`;

      tbody.innerHTML = "";
      const list = Array.isArray(payments) ? payments.slice().reverse() : [];
      for (const p of list) {
        const tr = document.createElement("tr");
        const tdM = document.createElement("td");
        const tdAt = document.createElement("td");
        const tdAm = document.createElement("td");
        const tdMe = document.createElement("td");
        const tdNo = document.createElement("td");
        tdM.textContent = p.month || "-";
        tdAt.textContent = fmtDt(p.paidAt);
        tdAm.textContent = (p.amount !== undefined && p.amount !== null && String(p.amount).trim() !== "") ? String(p.amount) : "-";
        tdMe.textContent = p.method || "-";
        tdNo.textContent = p.notes || "-";
        tr.appendChild(tdM); tr.appendChild(tdAt); tr.appendChild(tdAm); tr.appendChild(tdMe); tr.appendChild(tdNo);
        tbody.appendChild(tr);
      }

      modal.classList.remove("hidden");
    }

        // =========================
    // EDITAR USUÁRIO (ADMIN)
    // =========================
    let EDIT_USER_ID = null;

    function openEditUserModal(user) {
      EDIT_USER_ID = user?.id || null;
      document.getElementById("editUserSubtitle").textContent = `${user.fullName || "-"} • ${user.login || "-"}`;

      document.getElementById("editFullName").value = user.fullName || "";
      document.getElementById("editDob").value = user.dob || "";
      document.getElementById("editPhone").value = user.phone || "";
      document.getElementById("editLogin").value = user.login || "";
      document.getElementById("editPassword").value = "";

      document.getElementById("editUserModal").classList.remove("hidden");
    }

    function closeEditUserModal() {
      EDIT_USER_ID = null;
      document.getElementById("editUserModal")?.classList.add("hidden");
    }

    document.getElementById("cancelEditUserBtn")?.addEventListener("click", closeEditUserModal);

    document.getElementById("saveEditUserBtn")?.addEventListener("click", async () => {
      try {
        if (!EDIT_USER_ID) throw new Error("Usuário inválido.");
        const fullName = (document.getElementById("editFullName")?.value || "").trim();
        const dob = (document.getElementById("editDob")?.value || "").trim();
        const phone = (document.getElementById("editPhone")?.value || "").trim();
        const login = (document.getElementById("editLogin")?.value || "").trim();
        const password = (document.getElementById("editPassword")?.value || "").trim();

        if (!fullName || !dob || !phone || !login) {
          alert("Preencha: nome completo, data de nascimento, telefone e login.");
          return;
        }

        await adminFetchJson(`/api/admin/users/${encodeURIComponent(EDIT_USER_ID)}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ fullName, dob, phone, login, password })
        });

        closeEditUserModal();
        await adminLoadAll();
            await refreshLocalBackupFromServer();
      } catch (e) {
        alert(String(e?.message || e || "Falha ao editar usuário."));
      }
    });

document.getElementById("closePaymentsBtn")?.addEventListener("click", () => {
      document.getElementById("paymentsModal")?.classList.add("hidden");
    });

    document.getElementById("adminSearch")?.addEventListener("input", renderAdminUsers);

    document.getElementById("adminRefreshBtn")?.addEventListener("click", adminLoadAll);

    document.getElementById("adminBackupBtn")?.addEventListener("click", async () => {
      try {
        if (!AUTH?.token) throw new Error("Sessão inválida.");
        const resp = await fetch("/api/admin/backup/export", {
          method: "GET",
          headers: { "Authorization": `Bearer ${AUTH.token}` }
        });
        const ct = resp.headers.get("content-type") || "";
        if (!resp.ok) {
          let msg = "Falha ao exportar.";
          try { const j = ct.includes("application/json") ? await resp.json() : null; if (j?.error) msg = j.error; } catch {}
          throw new Error(msg);
        }
        const blob = await resp.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `enfermagem-backup-${new Date().toISOString().slice(0,10)}.json`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        try { await refreshLocalBackupFromServer(); } catch {}
      } catch (e) {
        alert(String(e?.message || e || "Falha ao baixar backup."));
      }
    });

    document.getElementById("adminRestoreBtn")?.addEventListener("click", async () => {
      const input = document.getElementById("adminRestoreFile");
      if (input) input.click();
    });

    document.getElementById("adminRestoreFile")?.addEventListener("change", async (ev) => {
      try {
        const file = ev.target?.files?.[0];
        if (!file) return;
        if (!confirm("Restaurar/mesclar este backup? Isso não apaga histórico; apenas recupera/mescla dados.")) {
          ev.target.value = "";
          return;
        }

        // cria um backup manual antes de restaurar
        try { await adminFetchJson("/api/admin/backup/create", { method: "POST" }); } catch {}

        const txt = await file.text();
        const payload = JSON.parse(txt);

        await adminFetchJson("/api/admin/backup/import", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        ev.target.value = "";
        await adminLoadAll();
        await refreshLocalBackupFromServer();
        alert("Backup importado/mesclado com sucesso.");
      } catch (e) {
        alert(String(e?.message || e || "Falha ao restaurar backup."));
      }
    });


    document.getElementById("createUserBtn")?.addEventListener("click", async () => {
      const fullName = (document.getElementById("newFullName")?.value || "").trim();
      const dob = (document.getElementById("newDob")?.value || "").trim();
      const phone = (document.getElementById("newPhone")?.value || "").trim();
      const login = (document.getElementById("newLogin")?.value || "").trim();
      const password = (document.getElementById("newPassword")?.value || "").trim();
      const st = document.getElementById("createUserStatus");
      if (!fullName || !dob || !phone || !login || !password) {
        if (st) st.textContent = "Preencha nome completo, data de nascimento, telefone, login e senha.";
        return;
      }
      if (st) st.textContent = "Cadastrando...";
      try {
        await adminFetchJson("/api/admin/users", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ fullName, dob, phone, login, password })
        });
        if (st) st.textContent = "Usuário cadastrado.";
        // Limpa campos
        ["newFullName","newDob","newPhone","newLogin","newPassword"].forEach(id => {
          const el = document.getElementById(id);
          if (el) el.value = "";
        });
        await adminLoadAll();
            await refreshLocalBackupFromServer();
      } catch (e) {
        if (st) st.textContent = String(e.message || e);
      }
    });

    // Inicializa a sessão ao carregar
    restoreSession();

    // Failsafe: se nenhuma view estiver visível após 1s, mostra login
    setTimeout(() => {
      const lv = document.getElementById("loginView");
      const av = document.getElementById("adminView");
      const nv = document.getElementById("nurseView");
      const anyVisible = (lv && !lv.classList.contains("hidden")) || (av && !av.classList.contains("hidden")) || (nv && !nv.classList.contains("hidden"));
      if (!anyVisible) showLogin();
    }, 1000);

</script>

  <div class="whatsapp-fab-label">Entrar em contato</div>
  <a
    class="whatsapp-fab"
    href="https://wa.me/5575981457012?text=Ol%C3%A1%21%20Gostaria%20de%20reportar%20um%20erro%2C%20tirar%20uma%20d%C3%BAvida%20ou%20enviar%20uma%20sugest%C3%A3o."
    target="_blank"
    rel="noopener"
    aria-label="Entrar em contato pelo WhatsApp"
    title="Reportar erros, dúvidas e sugestões"
  >
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M19.5 14.5c-.7 0-1.4-.1-2.1-.3a1 1 0 0 0-1 .2l-1.3 1.3a13.1 13.1 0 0 1-5.8-5.8l1.3-1.3a1 1 0 0 0 .2-1c-.2-.7-.3-1.4-.3-2.1a1 1 0 0 0-1-1H6.5a1 1 0 0 0-1 1c0 6.1 4.9 11 11 11a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1z"></path>
    </svg>
  </a>

</body>
</html>

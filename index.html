<!-- index.html -->
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Atendimento de Enfermagem</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: Arial, Helvetica, sans-serif;
      margin: 0;
      padding: 0;
      background: #f5f5f5;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    .page {
      width: 100%;
      max-width: 800px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin: 20px 0 10px 0;
      text-align: center;
    }
    .center-card {
      background: #ffffff;
      border-radius: 16px;
      padding: 30px 20px 25px 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 420px;
      margin-top: 10px;
    }

    .live-guidance {
      width: 100%;
      background: #f9fbff;
      border: 1px solid #d7e6ff;
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 14px;
    }
    .live-guidance-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }
    .live-guidance-title {
      font-weight: bold;
      font-size: 13px;
      color: #0c5460;
      margin: 0;
    }
    .live-guidance-context {
      font-size: 12px;
      color: #555;
      text-align: right;
      margin: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 55%;
    }
    .live-guidance-status {
      font-size: 12px;
      color: #555;
      margin: 0 0 8px 0;
      min-height: 16px;
    }
    .live-guidance-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .live-guidance-item {
      background: #ffffff;
      border-radius: 10px;
      border: 1px solid #e4eefc;
      padding: 8px;
      font-size: 13px;
      line-height: 1.35;
      color: #1f2937;
    }
    .live-guidance-empty {
      font-size: 12px;
      color: #666;
      background: #ffffff;
      border-radius: 10px;
      border: 1px dashed #c8d8f5;
      padding: 8px;
    }
    .live-guidance-item-text {
      margin-bottom: 6px;
    }
    .live-guidance-item-actions {
      display: flex;
      justify-content: flex-end;
    }
    .mini-red-btn {
      border: none;
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 12px;
      color: #fff;
      cursor: pointer;
    }
    .mini-red-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    #recordBtn {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      font-size: 20px;
      font-weight: bold;
      color: #fff;
      margin-bottom: 10px;
      transition: background 0.2s, transform 0.1s;
    }
    #recordBtn.start {
      background: #28a745;
    }
    #recordBtn.recording {
      background: #dc3545;
    }
    #recordBtn:active {
      transform: scale(0.97);
    }
    
    /* Triagem hospitalar: botão e separador */
    .module-divider {
      width: 100%;
      height: 1px;
      background: #e7e7e7;
      margin: 18px 0 14px 0;
    }
    .module-title {
      margin: 0 0 10px 0;
      font-size: 16px;
      font-weight: bold;
      color: #1f2937;
      text-align: center;
      width: 100%;
    }
    .module-subtitle {
      font-size: 12px;
      color: #555;
      text-align: center;
      margin: 0 0 12px 0;
      width: 100%;
    }

    #triageRecordBtn {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      color: #fff;
      margin-top: 6px;
      margin-bottom: 10px;
      transition: background 0.2s, transform 0.1s;
    }
    #triageRecordBtn.start { background: #007bff; }
    #triageRecordBtn.recording { background: #dc3545; }
    #triageRecordBtn:active { transform: scale(0.97); }

    #triagePauseBtn {
      padding: 6px 14px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: #6c757d;
      color: #fff;
      font-size: 13px;
      display: none;
    }
    #triageTimer {
      font-size: 26px;
      margin-top: 10px;
      font-family: "Courier New", monospace;
    }
    #triageMicStatus {
      margin-top: 8px;
      font-size: 14px;
      text-align: center;
      color: #333;
      min-height: 20px;
    }

    #triagePauseLabel {
      margin-top: 6px;
      font-size: 12px;
      color: #555;
      text-align: center;
    }
    #triageFinishHint {
      margin-top: 10px;
      font-size: 12px;
      color: #333;
      text-align: center;
    }

    .triage-report-panel {
      border: 1px solid #ddd;
      border-radius: 12px;
      padding: 14px;
      background: #ffffff;
      margin-bottom: 18px;
    }
    .triage-report-panel h2 {
      margin: 0 0 10px 0;
    }
    .triage-report-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    .triage-report-grid h3 {
      margin: 0 0 6px 0;
      font-size: 14px;
    }
    .triage-small-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    #triageCopyFullBtn, #triagePrintFullBtn {
      padding: 8px 18px;
      border-radius: 20px;
      border: 1px solid #0c5460;
      background: #ffffff;
      color: #0c5460;
      font-size: 14px;
      cursor: pointer;
    }
    #triageCopyFullBtn:hover, #triagePrintFullBtn:hover { background: #e6f2f5; }
#startNotice {
      font-size: 13px;
      color: #555;
      text-align: center;
      margin-top: 8px;
      margin-bottom: 8px;
    }
    #timer {
      font-size: 26px;
      margin-top: 16px;
      font-family: "Courier New", monospace;
    }
    #micStatus {
      margin-top: 8px;
      font-size: 14px;
      text-align: center;
      color: #333;
      min-height: 20px;
    }
    .controls-row {
      margin-top: 12px;
      display: flex;
      gap: 8px;
      align-items: center;
    }
    #pauseBtn {
      padding: 6px 14px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: #6c757d;
      color: #fff;
      font-size: 13px;
      display: none;
    }
    #pauseLabel {
      font-size: 12px;
      color: #555;
      margin-top: 6px;
      text-align: center;
    }
    #finishHint {
      font-size: 12px;
      color: #555;
      margin-top: 10px;
      text-align: center;
    }
    .results-card {
      background: #ffffff;
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      width: 100%;
      max-width: 800px;
      margin-top: 20px;
    }
    .results-card h2 {
      margin-top: 0;
    }
    .error {
      color: #b00020;
      margin-top: 8px;
      font-size: 13px;
      text-align: center;
    }
    .loading-dot::after {
      content: "...";
      animation: dots 1s steps(3, end) infinite;
    }
    @keyframes dots {
      0% { content: ""; }
      33% { content: "."; }
      66% { content: ".."; }
      100% { content: "..."; }
    }

    .soap-block {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 10px;
      background: #fafafa;
    }
    .soap-block-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }
    .soap-label {
      font-weight: bold;
      font-size: 14px;
    }
    .soap-textarea {
      width: 100%;
      min-height: 60px;
      resize: vertical;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #ddd;
      font-size: 14px;
      font-family: inherit;
      background: #ffffff;
    }
    .copy-soap-btn {
      padding: 4px 8px;
      border-radius: 12px;
      border: 1px solid #0c5460;
      background: #ffffff;
      color: #0c5460;
      font-size: 12px;
      cursor: pointer;
    }
    .copy-soap-btn:hover {
      background: #e6f2f5;
    }

    .prescription-textarea {
      width: 100%;
      min-height: 140px;
      resize: vertical;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #ddd;
      font-size: 14px;
      font-family: inherit;
      background: #fafafa;
      white-space: pre-wrap;
    }

    .prescription-actions {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    #copyPrescriptionBtn,
    #copySbarBtn,
    #printSbarBtn,
    #sbarRecordBtn,
    #copySaeBtn,
    #printPregnancyBtn,
    #printLactationBtn,
        #copyFullSoapBtn,
    #printSoapBtn,
    #updateInteractionsBtn,
    #printInteractionsBtn
{
      padding: 8px 18px;
      border-radius: 20px;
      border: 1px solid #0c5460;
      background: #ffffff;
      color: #0c5460;
      font-size: 14px;
      cursor: pointer;
    }
    #copyPrescriptionBtn:hover,
    #copySbarBtn:hover,
    #printSbarBtn:hover,
    #sbarRecordBtn:hover,
    #copySaeBtn:hover,
    #printPregnancyBtn:hover,
    #printLactationBtn:hover,
        #copyFullSoapBtn:hover,
    #printSoapBtn:hover,
    #updateInteractionsBtn:hover,
    #printInteractionsBtn:hover
{
      background: #e6f2f5;
    }

    #printBtn {
      margin-top: 0;
      padding: 8px 18px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: #0c5460;
      color: #fff;
      font-size: 14px;
      display: none;
    }

    #recommendationsBtn {
      margin-left: 0;
      padding: 8px 18px;
      border-radius: 20px;
      border: 1px solid #dc3545;
      background: #dc3545;
      color: #fff;
      cursor: pointer;
      font-size: 14px;
    }
    #recommendationsBtn:hover {
      background: #c82333;
      border-color: #c82333;
    }

    
    #sbarRecordBtn {
      border: 1px solid #dc3545;
      background: #dc3545;
      color: #fff;
    }
    #sbarRecordBtn:hover {
      background: #c82333;
      border-color: #c82333;
    }
.soap-title-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .recommendations-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 360px;
      max-width: 100%;
      height: 100vh;
      background: #ffffff;
      box-shadow: -2px 0 8px rgba(0,0,0,0.15);
      display: none;
      flex-direction: column;
      padding: 16px;
      z-index: 1000;
    }
    .recommendations-panel.visible {
      display: flex;
    }
    .recommendations-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .recommendations-header h3 {
      margin: 0;
      font-size: 16px;
    }
    .close-panel-btn {
      border: none;
      background: transparent;
      font-size: 18px;
      cursor: pointer;
      padding: 4px 8px;
    }
    .recommendations-status {
      font-size: 13px;
      color: #555;
      margin-bottom: 8px;
    }
    .recommendations-list {
      flex: 1;
      overflow-y: auto;
      margin-bottom: 12px;
      font-size: 14px;
    }
    .recommendation-item {
      background: #f5f5f5;
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 6px;
    }
    .ask-questions-btn {
      padding: 8px 16px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: #007bff;
      color: #fff;
      font-size: 14px;
    }
    .ask-questions-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .recommendations-footer {
      font-size: 11px;
      color: #666;
      margin-top: 8px;
    }

    .questions-timer {
      font-size: 18px;
      margin-top: 10px;
      font-family: "Courier New", monospace;
      text-align: center;
      color: #333;
    }

    .mini-status {
      margin-top: 6px;
      font-size: 12px;
      color: #555;
      min-height: 16px;
    }

    .classification-box {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 10px;
      background: #fafafa;
      white-space: pre-wrap;
      font-size: 14px;
      line-height: 1.35;
      min-height: 48px;
    }

    .risk-triage-box {
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 12px;
      background: #fafafa;
    }
    .risk-triage-current {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    .risk-badge {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      color: #fff;
      font-weight: bold;
      font-size: 13px;
      min-width: 120px;
      text-align: center;
    }
    .risk-none { background: #6c757d; }
    .risk-vermelho { background: #dc3545; }
    .risk-laranja { background: #fd7e14; }
    .risk-amarelo { background: #ffc107; color: #1f2937; }
    .risk-verde { background: #28a745; }
    .risk-azul { background: #0d6efd; }

    .risk-meaning {
      font-size: 14px;
      line-height: 1.35;
      color: #1f2937;
      white-space: pre-wrap;
      flex: 1;
      min-width: 180px;
    }

    .risk-legend {
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 13px;
      color: #1f2937;
    }
    .risk-legend-row {
      display: flex;
      align-items: flex-start;
      gap: 10px;
    }
    .risk-legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 4px;
      margin-top: 2px;
      flex: 0 0 14px;
    }
    .swatch-vermelho { background: #dc3545; }
    .swatch-laranja { background: #fd7e14; }
    .swatch-amarelo { background: #ffc107; }
    .swatch-verde { background: #28a745; }
    .swatch-azul { background: #0d6efd; }


    .section-header-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .section-header-row h2 {
      margin: 0;
    }

    .module-card {
      background: #ffffff;
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      width: 100%;
      max-width: 800px;
      margin-top: 20px;
    }
    .module-card h2 {
      margin-top: 0;
    }
    .inline-input-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 10px;
    }
    .text-input {
      flex: 1;
      min-width: 220px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #ddd;
      font-size: 14px;
      font-family: inherit;
      background: #ffffff;
    }
    .answer-box {
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 12px;
      background: #fafafa;
      white-space: pre-wrap;
      font-size: 14px;
      line-height: 1.4;
      min-height: 70px;
      margin-top: 12px;
    }
    .small-record-btn {
      padding: 10px 16px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      color: #fff;
      transition: background 0.2s, transform 0.1s;
    }
    .small-record-btn.start {
      background: #28a745;
    }
    .small-record-btn.recording {
      background: #dc3545;
    }
    .small-record-btn:active {
      transform: scale(0.98);
    }
    .report-actions {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    @media (max-width: 480px) {
      #recordBtn {
        width: 150px;
        height: 150px;
        font-size: 18px;
      }
      .prescription-actions {
        flex-direction: column;
        align-items: flex-start;
      }
    }

    
    .guide-inline {
      margin: 10px 0 12px;
      padding: 12px;
      border: 1px solid #e6e6e6;
      border-radius: 12px;
      background: #fafafa;
      color: #1f1f1f;
    }
    .guide-inline h3 {
      margin: 0 0 8px;
      font-size: 16px;
    }
    .guide-inline h4 {
      margin: 10px 0 6px;
      font-size: 14px;
    }
    .guide-inline p {
      margin: 8px 0;
    }
    .guide-inline ul {
      margin: 0 0 8px 18px;
    }
    .sbar-guide-btn {
      border-color: #0c5460;
      color: #0c5460;
      background: #ffffff;
    }

.hidden {
      display: none !important;
    }
  

    .patientinfo-panel {
      border: 1px solid #e6e6e6;
      border-radius: 10px;
      padding: 12px;
      margin-bottom: 12px;
      background: #fafafa;
    }
    .patientinfo-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .mini-timer {
      font-size: 16px;
      font-weight: bold;
      min-width: 64px;
    }
    .patient-summary {
      margin-top: 8px;
      font-size: 14px;
      color: #333;
      white-space: pre-wrap;
    }


  
    #patientInfoBtn {
      background: #b00020;
      border-color: #b00020;
    }
    #patientInfoBtn:hover {
      filter: brightness(0.95);
    }

  
    .photo-btn {
      background: #dc3545;
      border: none;
      color: #fff;
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
    }
    .photo-btn:hover {
      filter: brightness(0.95);
    }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.45);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      padding: 16px;
    }
    .modal {
      background: #fff;
      border-radius: 14px;
      width: 100%;
      max-width: 420px;
      padding: 16px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.25);
    }
    .modal h3 {
      margin: 0 0 8px 0;
      font-size: 16px;
    }
    .modal p {
      margin: 0 0 12px 0;
      font-size: 13px;
      color: #555;
    }
    .modal-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .modal-actions button {
      flex: 1 1 140px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #d1d5db;
      background: #f9fafb;
      cursor: pointer;
      font-weight: 600;
    }
    .modal-actions button.primary {
      background: #2563eb;
      color: #fff;
      border-color: #2563eb;
    }
    .modal-actions button.danger {
      background: #dc3545;
      color: #fff;
      border-color: #dc3545;
    }
        .hidden-input {
      position: absolute !important;
      left: -9999px !important;
      top: auto !important;
      width: 1px !important;
      height: 1px !important;
      opacity: 0 !important;
      overflow: hidden !important;
    }

    /* Mantém o modal antigo oculto para evitar interferência com os módulos de foto/arquivo. */
    #imageChoiceOverlay { display: none !important; }

.consult-type-panel {
      width: 100%;
      background: #ffffff;
      border-radius: 12px;
      border: 1px solid #e5e7eb;
      padding: 12px;
      margin-bottom: 12px;
    }
    .consult-type-title {
      margin: 0 0 10px 0;
      font-weight: bold;
      font-size: 13px;
      color: #111827;
    }
    .consult-type-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 10px;
    }
    .consult-type-btn {
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid #0c5460;
      background: #ffffff;
      color: #0c5460;
      font-size: 13px;
      cursor: pointer;
      flex: 1 1 160px;
      text-align: center;
      font-weight: 600;
    }
    .consult-type-btn:hover {
      background: #e6f2f5;
    }
    .consult-type-btn.active {
      background: #0c5460;
      color: #ffffff;
    }
    .consult-guide-drawer {
      width: 100%;
      background: #f9fbff;
      border: 1px solid #d7e6ff;
      border-radius: 12px;
      padding: 12px;
    }
    .consult-guide-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 10px;
      margin-bottom: 10px;
    }
    .consult-guide-title {
      font-weight: bold;
      font-size: 14px;
      color: #0c5460;
      margin: 0 0 4px 0;
    }
    .consult-guide-subtitle {
      font-size: 12px;
      color: #555;
      margin: 0;
    }
    .consult-guide-close {
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid #d1d5db;
      background: #ffffff;
      cursor: pointer;
      font-weight: 600;
      font-size: 12px;
    }
    .trimester-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin: 8px 0 10px 0;
    }
    .trimester-btn {
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid #0c5460;
      background: #ffffff;
      color: #0c5460;
      font-size: 12px;
      cursor: pointer;
      font-weight: 600;
    }
    .trimester-btn.active {
      background: #0c5460;
      color: #ffffff;
    }
    .consult-guide-content {
      font-size: 13px;
      color: #111827;
      line-height: 1.4;
    }
    .guide-section-title {
      font-weight: bold;
      margin: 10px 0 6px 0;
      color: #111827;
    }
    .consult-guide-content ol {
      margin: 0 0 6px 18px;
      padding: 0;
    }
    .consult-guide-content li {
      margin: 0 0 6px 0;
    }


  
    /* Padronização de botões de copiar e imprimir */
    .btn-copy {
      padding: 8px 18px;
      border-radius: 20px;
      border: 1px solid #fd7e14 !important;
      background: #fd7e14 !important;
      color: #ffffff !important;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.05s, opacity 0.15s;
    }
    .btn-copy:hover { opacity: 0.92; }
    .btn-copy:active { transform: scale(0.98); }

    .btn-print {
      padding: 8px 18px;
      border-radius: 20px;
      border: 1px solid #0d6efd !important;
      background: #0d6efd !important;
      color: #ffffff !important;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.05s, opacity 0.15s;
    }
    .btn-print:hover { opacity: 0.92; }
    .btn-print:active { transform: scale(0.98); }

    /* Botões "Copiar" por seção do SOAP (mesma identidade visual, tamanho menor) */
    .copy-soap-btn {
      border: 1px solid #fd7e14 !important;
      background: #fd7e14 !important;
      color: #ffffff !important;
      border-radius: 20px;
      padding: 4px 10px;
      font-size: 12px;
      cursor: pointer;
    }
    .copy-soap-btn:hover { opacity: 0.92; }

    /* Botão flutuante de contato via WhatsApp */
    .whatsapp-fab {
      position: fixed;
      right: 18px;
      bottom: 18px;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: none;
      background: #25D366;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 8px 18px rgba(0,0,0,0.20);
      cursor: pointer;
      text-decoration: none;
      z-index: 2000;
    }
    .whatsapp-fab:active { transform: scale(0.98); }
    .whatsapp-fab svg { width: 28px; height: 28px; fill: #ffffff; }
    
    .whatsapp-fab-label {
      position: fixed;
      right: 84px;
      bottom: 18px;
      background: #ffffff;
      border: 1px solid #e5e7eb;
      border-radius: 14px;
      padding: 10px 12px;
      font-size: 12px;
      color: #111827;
      box-shadow: 0 6px 16px rgba(0,0,0,0.12);
      z-index: 2000;
      user-select: none;
      max-width: 270px;
      line-height: 1.2;
    }
    .whatsapp-fab-label .wa-label-title {
      font-weight: 800;
      font-size: 12px;
      margin-bottom: 3px;
    }
    .whatsapp-fab-label .wa-label-sub {
      font-weight: 600;
      font-size: 11px;
      color: #374151;
    }
    @media (max-width: 520px) {
      .whatsapp-fab-label {
        right: 72px;
        bottom: 12px;
        padding: 8px 10px;
        max-width: 210px;
      }
      .whatsapp-fab-label .wa-label-sub {
        font-size: 10px;
      }
    }

/* =========================
       AUTENTICAÇÃO E ADMIN
       ========================= */
    .auth-shell {
      min-height: 100vh;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 20px;
    }
    .auth-card {
      width: 100%;
      max-width: 420px;
      background: #ffffff;
      border-radius: 16px;
      padding: 26px 20px 20px 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      margin-top: 40px;
    }
    .auth-subtitle {
      margin-top: 6px;
      margin-bottom: 16px;
      font-size: 13px;
      color: #555;
    }
    .auth-label {
      width: 100%;
      display: block;
      margin: 10px 0 6px 0;
      font-size: 13px;
      color: #333;
      font-weight: bold;
    }
    .auth-input {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #ddd;
      font-size: 14px;
      outline: none;
      background: #fff;
    }
    .auth-btn {
      width: 100%;
      margin-top: 14px;
      padding: 10px 12px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      background: #0c5460;
      color: #fff;
      font-size: 14px;
      font-weight: 700;
    }
    .auth-btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .auth-error {
      margin-top: 10px;
      font-size: 13px;
      color: #b00020;
      min-height: 18px;
    }
    .auth-help {
      margin-top: 12px;
      font-size: 12px;
      color: #666;
    }

    .nurse-bar {
      width: 100%;
      border: 1px solid #e5e7eb;
      border-radius: 14px;
      background: #ffffff;
      padding: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }
    .nurse-bar-line { font-size: 13px; color: #111827; }
    .nurse-bar-label { color: #6b7280; font-weight: 700; margin-right: 6px; }
    .nurse-bar-actions { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .danger-btn {
      padding: 10px 14px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      background: #dc3545;
      color: #fff;
      font-weight: 800;
      font-size: 13px;
    }
    .pill {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      border: 1px solid #ddd;
      background: #f2f2f2;
      color: #555;
      font-weight: 800;
      white-space: nowrap;
    }
    .pill.green { background: #e7f7ec; border-color: #bfe8c9; color: #145a22; }
    .pill.red { background: #fde8ea; border-color: #f3c2c7; color: #7a1420; }

    .admin-shell {
      width: 100%;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    .admin-wrap {
      width: 100%;
      max-width: 980px;
    }
    .admin-card {
      background: #ffffff;
      border-radius: 16px;
      padding: 18px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      margin-top: 14px;
    }
    .admin-row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .admin-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }
    @media (max-width: 720px) {
      .admin-grid { grid-template-columns: 1fr; }
    }
    .admin-field label {
      display: block;
      font-size: 12px;
      color: #555;
      margin: 0 0 6px 0;
      font-weight: 700;
    }
    .admin-field input {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid #ddd;
      font-size: 14px;
      outline: none;
    }
    .admin-btn {
      padding: 10px 14px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      background: #0c5460;
      color: #fff;
      font-weight: 800;
      font-size: 13px;
    }
    .admin-btn.secondary { background: #6c757d; }
    .admin-btn.danger { background: #dc3545; }
    .admin-status {
      margin-top: 10px;
      font-size: 12px;
      color: #333;
      min-height: 18px;
      white-space: pre-wrap;
    }
    .admin-table-wrap { overflow-x: auto; margin-top: 10px; }
    table.admin-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }
    table.admin-table th, table.admin-table td {
      border-bottom: 1px solid #eee;
      padding: 10px 8px;
      text-align: left;
      vertical-align: top;
      white-space: nowrap;
    }
    table.admin-table th { background: #f7f7f7; font-weight: 900; }
    .admin-actions { display: flex; gap: 8px; flex-wrap: wrap; }
    .admin-actions button { padding: 8px 10px; border-radius: 10px; font-size: 12px; }
    .modal-overlay.hidden { display: none; }


    .admin-form-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;}
    @media (max-width: 720px){.admin-form-grid{grid-template-columns:1fr;}}


    /* Ajustes visuais e responsividade (computador e celular) */
    .page { width: 100%; }
    .center-card, .results-card, .admin-card { width: 100%; }
    input, textarea, select { max-width: 100%; }

    .nurse-bar {
      width: 100%;
      max-width: 900px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      padding: 12px 14px;
      border-radius: 14px;
      background: #ffffff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.10);
      margin: 10px auto 14px auto;
    }
    .nurse-bar-line { margin: 2px 0; }

    .consult-type-btn { white-space: normal; }

    @media (max-width: 720px) {
      body { align-items: flex-start; }
      .page { padding: 12px; }
      h1 { font-size: 26px; margin-top: 14px; }
      .center-card { padding: 18px 14px; max-width: 100%; }
      .results-card { padding: 16px 14px; }
      .nurse-bar { flex-direction: column; align-items: flex-start; }
      .nurse-bar-actions { width: 100%; display: flex; justify-content: flex-end; }
      .consult-type-buttons { flex-direction: column; }
      .consult-type-btn { width: 100%; text-align: left; }
      .admin-row { flex-wrap: wrap; }
      .admin-btn { width: 100%; justify-content: center; }
      .admin-table-wrap { border: 1px solid #eee; border-radius: 12px; }
    }

    @media (max-width: 420px) {
      .page { padding: 10px; }
      h1 { font-size: 24px; }
      #recordBtn { width: 145px; height: 145px; }
    }



    /* =========================
       AJUSTES MOBILE (RESPONSIVO)
       ========================= */
    html, body {
      width: 100%;
      max-width: 100%;
      overflow-x: hidden;
    }
    body {
      display: block;
    }
    .page {
      align-items: stretch;
      margin: 0 auto;
      max-width: 980px;
      min-width: 0;
    }
    .center-card,
    .results-card,
    .module-card,
    .auth-card,
    .admin-wrap {
      min-width: 0;
      max-width: 100%;
    }

    /* Evitar cortes por itens flex/grids */
    .section-header-row > * { min-width: 0; }
    .inline-input-row > * { min-width: 0; }
    input, select, textarea, button { max-width: 100%; }
    .answer-box, .classification-box, .patient-summary {
      word-break: break-word;
      overflow-wrap: anywhere;
    }

    @media (max-width: 720px) {
      h1 { font-size: 22px; margin: 14px 0 8px 0; }
      .page { padding: 12px; }
      .center-card { padding: 16px 12px 14px 12px; }
      .results-card, .module-card { padding: 14px; }
      .nurse-bar { padding: 10px; }
      .nurse-bar-actions { width: 100%; justify-content: flex-end; }
    }

    @media (max-width: 520px) {
      .inline-input-row,
      .patientinfo-row,
      .controls-row,
      .section-header-row {
        flex-direction: column;
        align-items: stretch;
      }

      .prescription-actions,
      .report-actions {
        flex-direction: column;
        align-items: stretch;
      }
      .prescription-actions > button,
      .report-actions > button,
      .nurse-bar-actions > button,
      #recommendationsBtn {
        width: 100%;
      }

      .text-input {
        min-width: 0 !important;
        width: 100%;
      }

      /* Guias de consulta: compacto no celular */
      .consult-type-buttons {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
      }
      .consult-type-btn {
        flex: initial;
        width: 100%;
        text-align: center;
        font-size: 12px;
        padding: 8px 10px;
        border-radius: 12px;
        line-height: 1.15;
      }

      .consult-guide-header {
        flex-direction: column;
        align-items: stretch;
      }
      .consult-guide-close { width: 100%; }

      .recommendations-panel {
        width: 100%;
        right: 0;
      }

      .whatsapp-fab {
        width: 52px;
        height: 52px;
        right: 12px;
        bottom: 12px;
      }
    }

    @media (max-width: 360px) {
      .consult-type-buttons { grid-template-columns: 1fr; }
    }


    /* =========================
       MÓDULO: CALCULADORAS CLÍNICAS
       ========================= */
    .calc-panel {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #eee;
    }
    .calc-title {
      font-weight: 800;
      margin: 0 0 8px 0;
      font-size: 14px;
      color: #111827;
    }
    .calc-help {
      margin: 0 0 10px 0;
      font-size: 12px;
      color: #555;
      line-height: 1.35;
    }
    .calc-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 10px;
    }
    .calc-row .text-input {
      min-width: 160px;
    }
    .calc-link {
      display: inline-block;
      margin-top: 8px;
      font-size: 13px;
      color: #0c5460;
      text-decoration: underline;
      cursor: pointer;
    }
    .calc-muted {
      font-size: 12px;
      color: #666;
      margin-top: 8px;
      white-space: pre-wrap;
      line-height: 1.35;
    }

  

    .module-title-row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:6px;
    }
    .mini-consult-btn{
      padding:7px 12px;
      font-size:12px;
      border-radius:12px;
      white-space:nowrap;
    }

    #sbarRecordBtn{
      width:180px;
      height:180px;
      border-radius:50%;
      border:none;
      cursor:pointer;
      font-size:18px;
      font-weight:800;
      color:#fff;
      margin:10px auto 6px auto;
      display:block;
      transition:transform 0.15s ease, background-color 0.15s ease;
    }
    #sbarRecordBtn:active{
      transform:scale(0.97);
    }
    
    #sbarRecordBtn.start{
      background:#28a745;
    }
    #sbarRecordBtn.recording{
      background:#dc3545;
    }
    #sbarRecordBtn:disabled{
      opacity:0.72;
      cursor:not-allowed;
    }

#sbarRecordBtn.generating{
      background:#dc3545 !important;
    }

    .mini-timer{
      text-align:center;
      font-size:18px;
      font-weight:700;
      margin:6px 0 10px 0;
      color:#fff;
      opacity:0.92;
    }

</style>
</head>
<body>

  <div id="loginView" class="auth-shell">
    <div class="auth-card">
      <h1>Atendimento de Enfermagem</h1>
      <p class="auth-subtitle">Acesso restrito para profissionais cadastrados. Versão 2025-12-30.3</p>

      <label class="auth-label" for="loginField">Login</label>
      <input id="loginField" class="auth-input" autocomplete="username" inputmode="text" />

      <label class="auth-label" for="passwordField">Senha</label>
      <input id="passwordField" class="auth-input" type="password" autocomplete="current-password" />

      <button id="loginBtn" class="auth-btn" type="button">Entrar</button>
      <div id="loginError" class="auth-error"></div>

      <div class="auth-help">
        Se não conseguir acessar, use o botão “Entrar em contato”.
      </div>
    </div>
  </div>


  <div id="adminView" class="admin-shell hidden">
    <div class="admin-wrap">
      <div class="admin-row" style="justify-content: space-between; align-items: flex-end;">
        <div>
          <h1 style="margin: 10px 0 4px 0;">Painel do Administrador</h1>
          <div id="adminSubtitle" style="font-size: 12px; color: #555;"></div>
          <div id="adminLocalBackupInfo" style="font-size: 12px; color: #555; margin-top: 2px;"></div>
        </div>
        <div class="admin-row">
          <button id="adminRefreshBtn" class="admin-btn secondary" type="button">Atualizar</button>
          <button id="adminBackupBtn" class="admin-btn secondary" type="button">Baixar backup</button>
          <button id="adminRestoreBtn" class="admin-btn secondary" type="button">Restaurar backup</button>
          <input id="adminRestoreFile" type="file" accept="application/json" style="display:none" />
          <button id="adminLogoutBtn" class="admin-btn danger" type="button">Sair</button>
        </div>
      </div>

      <div class="admin-card">
        <h2 style="margin: 0 0 10px 0;">Cadastrar enfermeiro(a)</h2>
        <div class="admin-grid">
          <div class="admin-field">
            <label for="newFullName">Nome completo</label>
            <input id="newFullName" type="text" />
          </div>
          <div class="admin-field">
            <label for="newDob">Data de nascimento</label>
            <input id="newDob" type="date" />
          </div>
          <div class="admin-field">
            <label for="newPhone">Telefone</label>
            <input id="newPhone" type="tel" />
          </div>
          <div class="admin-field">
            <label for="newLogin">Login</label>
            <input id="newLogin" type="text" />
          </div>
          <div class="admin-field">
            <label for="newPassword">Senha</label>
            <input id="newPassword" type="text" />
          </div>
          <div class="admin-field" style="display:flex; align-items:flex-end;">
            <button id="createUserBtn" class="admin-btn" type="button" style="width:100%;">Cadastrar</button>
          </div>
        </div>
        <div id="createUserStatus" class="admin-status"></div>
      </div>

      <div class="admin-card">
        <div class="admin-row" style="justify-content: space-between;">
          <h2 style="margin: 0;">Enfermeiros cadastrados</h2>
          <input id="adminSearch" class="auth-input" placeholder="Buscar por nome, login ou telefone" style="max-width: 360px;" />
        </div>
        <div class="admin-table-wrap">
          <table class="admin-table">
            <thead>
              <tr>
                <th>Nome</th>
                <th>Login</th>
                <th>Telefone</th>
                <th>Online</th>
                <th>Mensalidade</th>
                <th>Último login</th>
                <th>Ações</th>
              </tr>
            </thead>
            <tbody id="usersTbody"></tbody>
          </table>
        </div>
        <div id="adminStatus" class="admin-status"></div>
      </div>

      <div class="admin-card">
        <h2 style="margin: 0 0 10px 0;">Auditoria administrativa (somente leitura)</h2>
        <div class="admin-table-wrap">
          <table class="admin-table">
            <thead>
              <tr>
                <th>Registro de pagamento</th>
                <th>Recebido por (Admin)</th>
              </tr>
            </thead>
            <tbody id="auditTbody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <div id="paymentsModal" class="modal-overlay hidden">
    <div class="modal" style="max-width: 720px;">
      <h3 style="margin:0 0 8px 0;">Histórico de pagamentos</h3>
      <p id="paymentsModalSubtitle" style="margin:0 0 10px 0; font-size: 12px; color: #555;"></p>
      <div class="admin-table-wrap" style="max-height: 55vh; overflow:auto;">
        <table class="admin-table">
          <thead>
            <tr>
              <th>Mês</th>
              <th>Pago em</th>
              <th>Valor</th>
              <th>Método</th>
              <th>Observações</th>
            </tr>
          </thead>
          <tbody id="paymentsTbody"></tbody>
        </table>
      </div>
      <div class="admin-row" style="justify-content:flex-end; margin-top: 12px;">
        <button id="closePaymentsBtn" class="admin-btn secondary" type="button">Fechar</button>
      </div>
      <div style="margin-top: 10px; font-size: 12px; color: #666;">Este histórico é permanente. Não há opção de editar ou apagar registros.</div>
    </div>
    <div id="editUserModal" class="modal-overlay hidden">
    <div class="modal" style="max-width: 720px;">
      <h3 style="margin:0 0 8px 0;">Editar enfermeiro(a)</h3>
      <p id="editUserSubtitle" style="margin:0 0 10px 0; font-size: 12px; color: #555;"></p>

      <div class="admin-form-grid">
        <div>
          <label class="auth-label">Nome completo</label>
          <input id="editFullName" class="auth-input" placeholder="Nome completo" />
        </div>
        <div>
          <label class="auth-label">Data de nascimento</label>
          <input id="editDob" class="auth-input" placeholder="dd/mm/aaaa" />
        </div>
        <div>
          <label class="auth-label">Telefone</label>
          <input id="editPhone" class="auth-input" placeholder="Telefone" />
        </div>
        <div>
          <label class="auth-label">Login</label>
          <input id="editLogin" class="auth-input" placeholder="Login" />
        </div>
        <div style="grid-column: 1 / -1;">
          <label class="auth-label">Nova senha (opcional)</label>
          <input id="editPassword" class="auth-input" placeholder="Deixe em branco para não alterar" />
          <div style="margin-top:6px; font-size: 12px; color:#666;">Se preencher, a senha será atualizada. O histórico de pagamentos não é alterado.</div>
        </div>
      </div>

      <div class="admin-row" style="justify-content:flex-end; margin-top: 14px;">
        <button id="cancelEditUserBtn" class="admin-btn secondary" type="button">Cancelar</button>
        <button id="saveEditUserBtn" class="admin-btn" type="button" style="margin-left: 10px;">Salvar</button>
      </div>
    </div>
  </div>

</div>

  <div id="nurseView" class="hidden">
  <div class="page">
    <h1>Atendimento de Enfermagem</h1>


    <div class="nurse-bar" id="nurseBar">
      <div>
        <div class="nurse-bar-line"><span class="nurse-bar-label">Usuário:</span><span id="nurseUserLabel">-</span></div>
        <div class="nurse-bar-line"><span class="nurse-bar-label">Login:</span><span id="nurseLoginLabel">-</span></div>
        <div class="nurse-bar-line"><span class="nurse-bar-label">Mensalidade:</span><span id="nursePaymentLabel" class="pill">-</span></div>
      </div>
      <div class="nurse-bar-actions">
        <button id="nurseLogoutBtn" type="button" class="danger-btn">Sair</button>
      </div>
    </div>


    <div class="center-card">

      <div id="consultTypePanel" class="consult-type-panel">
        <p class="consult-type-title">Guias de consulta</p>
        <div class="consult-type-buttons">
          <button class="consult-type-btn" type="button" data-consult="prenatal">Consulta pré-natal por trimestre</button>
          <button class="consult-type-btn" type="button" data-consult="puericultura">Consulta puericultura</button>
          <button class="consult-type-btn" type="button" data-consult="planejamento">Consulta planejamento familiar</button>
          <button class="consult-type-btn" type="button" data-consult="hiperdia">Consulta hiperdia</button>
          <button class="consult-type-btn" type="button" data-consult="puerperio">Consulta de puerpério</button>
        </div>

        <div id="consultGuideDrawer" class="consult-guide-drawer hidden">
          <div class="consult-guide-header">
            <div>
              <p id="consultGuideTitle" class="consult-guide-title"></p>
              <p id="consultGuideSubtitle" class="consult-guide-subtitle"></p>
            </div>
            <button id="closeConsultGuideBtn" class="consult-guide-close" type="button">Fechar</button>
          </div>

          <div id="prenatalTrimesterRow" class="trimester-row hidden">
            <button class="trimester-btn" type="button" data-tri="1">1º trimestre</button>
            <button class="trimester-btn" type="button" data-tri="2">2º trimestre</button>
            <button class="trimester-btn" type="button" data-tri="3">3º trimestre</button>
          </div>

          <div id="consultGuideContent" class="consult-guide-content"></div>
        </div>
      </div>

      <div id="liveGuidance" class="live-guidance">
        <div class="live-guidance-header">
          <p class="live-guidance-title">Perguntas e procedimentos essenciais</p>
          <p id="liveGuidanceContext" class="live-guidance-context"></p>
        </div>
        <p id="liveGuidanceStatus" class="live-guidance-status">Inicie o atendimento para receber perguntas e procedimentos necessários em tempo real.</p>
        <div id="liveGuidanceList" class="live-guidance-list">
          <div class="live-guidance-empty">Nenhuma sugestão por enquanto.</div>
        </div>
      </div>

      <button id="recordBtn" class="start">Iniciar atendimento</button>

      <p id="startNotice">
        Assim que iniciar a gravação, informe sempre o nome completo do paciente, idade, peso e sinais vitais (PA, FC, FR, SpO2 e temperatura) para que o SOAP e a prescrição sejam gerados corretamente.
      </p>

      <div id="timer">00:00</div>
      <div id="micStatus">Clique em "Iniciar atendimento" para começar.</div>

      <div class="controls-row">
        <button id="pauseBtn">Pausar</button>
      </div>
      <div id="pauseLabel">Use o botão pequeno para pausar e retomar a consulta.</div>

      <div id="finishHint">
        Para encerrar a consulta e gerar o SOAP, clique novamente no botão grande vermelho.
      </div>

      <div id="soapError" class="error"></div>

      <div class="module-divider"></div>
      <p class="module-title">Triagem hospitalar</p>
      <p class="module-subtitle">
        Use este módulo para triagem na porta do hospital. Fale identificação do paciente, queixa principal, sinais vitais, achados do ABCDE, comorbidades, alergias e medicações em uso. Ao encerrar, será gerado um relatório técnico de triagem, condutas iniciais e passagem rápida ao médico.
      </p>

      <div id="triageLiveGuidance" class="live-guidance">
        <div class="live-guidance-header">
          <p class="live-guidance-title">Perguntas e procedimentos essenciais da triagem</p>
          <p id="triageLiveGuidanceContext" class="live-guidance-context"></p>
        </div>
        <p id="triageLiveGuidanceStatus" class="live-guidance-status">Inicie a triagem para receber perguntas e procedimentos necessários em tempo real.</p>
        <div id="triageLiveGuidanceList" class="live-guidance-list">
          <div class="live-guidance-empty">Nenhuma sugestão por enquanto.</div>
        </div>
      </div>

      <button id="triageRecordBtn" class="start" type="button">Iniciar triagem hospitalar</button>

      <div id="triageTimer">00:00</div>
      <div id="triageMicStatus">Clique em "Iniciar triagem hospitalar" para começar.</div>

      <div class="controls-row">
        <button id="triagePauseBtn" type="button">Pausar</button>
      </div>
      <div id="triagePauseLabel">Use o botão pequeno para pausar e retomar a gravação da triagem.</div>

      <div id="triageFinishHint">
        Para encerrar e gerar o relatório de triagem, clique novamente no botão grande vermelho.
      </div>

      <div id="triageError" class="error"></div>

    </div>

    <div id="resultsCard" class="results-card hidden">

      <div id="patientInfoPanel" class="patientinfo-panel">
        <div class="patientinfo-row">
          <button id="patientInfoBtn" class="small-record-btn">Coletar dados essenciais</button>
          <div id="patientInfoTimer" class="mini-timer">00:00</div>
          <div id="patientInfoStatus" class="mini-status"></div>
        </div>
        <div id="patientInfoSummary" class="patient-summary"></div>
      </div>



      <div id="triageReportPanel" class="triage-report-panel hidden">
        <div class="section-header-row">
          <div class="soap-title-actions">
            <h2>Relatório de triagem hospitalar</h2>
            <button id="triageCopyFullBtn" class="btn-copy" type="button">Copiar relatório</button>
            <button id="triagePrintFullBtn" class="btn-print" type="button">Imprimir relatório</button>
          </div>
        </div>

        <div class="risk-triage-box" style="margin-bottom: 12px;">
          <div class="risk-triage-current">
            <span id="triageRiskBadge" class="risk-badge risk-none">Não informado</span>
            <div id="triageRiskMeaning" class="risk-meaning">Nenhum conteúdo disponível.</div>
          </div>
          <div id="triageRiskLegend" class="risk-legend"></div>
        </div>

        <div class="triage-report-grid">
          <div>
            <h3>Texto para prontuário</h3>
            <textarea id="triageProntuario" class="prescription-textarea"></textarea>
            <div class="prescription-actions">
              <button id="triageCopyProntuarioBtn" class="btn-copy" type="button">Copiar prontuário</button>
              <button id="triagePrintProntuarioBtn" class="btn-print" type="button">Imprimir prontuário</button>
            </div>
          </div>

          <div>
            <h3>Passagem rápida ao médico</h3>
            <textarea id="triagePassagemMedico" class="prescription-textarea"></textarea>
            <div class="prescription-actions">
              <button id="triageCopyPassagemBtn" class="btn-copy" type="button">Copiar passagem</button>
              <button id="triagePrintPassagemBtn" class="btn-print" type="button">Imprimir passagem</button>
            </div>
          </div>

          <div>
            <h3>Alertas e sinais de gravidade</h3>
            <textarea id="triageAlertas" class="prescription-textarea"></textarea>
          </div>

          <div>
            <h3>Tratamento não medicamentoso e cuidados</h3>
            <textarea id="triageCondutasNaoMed" class="prescription-textarea"></textarea>
          </div>

          <div>
            <h3>Tratamento medicamentoso sugerido (se aplicável)</h3>
            <textarea id="triageCondutasMed" class="prescription-textarea"></textarea>
          </div>

          <div>
            <h3>Medidas e exames imediatos sugeridos</h3>
            <textarea id="triageMedidasExames" class="prescription-textarea"></textarea>
          </div>

          <div>
            <h3>Pendências a checar antes de liberar ou encaminhar</h3>
            <textarea id="triagePendencias" class="prescription-textarea"></textarea>
          </div>

          <div>
            <h3>Checagem de qualidade (o que está faltando na triagem)</h3>
            <textarea id="triageQualidade" class="prescription-textarea"></textarea>
          </div>

          <div>
            <h3>Relatório completo</h3>
            <textarea id="triageFullReport" class="prescription-textarea"></textarea>
          </div>
        </div>

        <div id="triageReportStatus" class="mini-status"></div>
      </div>

      <div class="section-header-row">
        <div class="soap-title-actions">
          <h2>SOAP</h2>
          <button id="copyFullSoapBtn" class="btn-copy">Copiar SOAP</button>
          <button id="printSoapBtn" class="btn-print">Imprimir SOAP</button>
        </div>
        <button id="recommendationsBtn">Perguntas essenciais</button>
      </div>

      <div class="soap-block">
        <div class="soap-block-header">
          <span class="soap-label">S</span>
          <button class="copy-soap-btn" data-part="S">Copiar</button>
        </div>
        <textarea id="soapS" class="soap-textarea"></textarea>
      </div>

      <div class="soap-block">
        <div class="soap-block-header">
          <span class="soap-label">O</span>
          <button class="copy-soap-btn" data-part="O">Copiar</button>
        </div>
        <textarea id="soapO" class="soap-textarea"></textarea>
      </div>

      <div class="soap-block">
        <div class="soap-block-header">
          <span class="soap-label">A</span>
          <button class="copy-soap-btn" data-part="A">Copiar</button>
        </div>
        <textarea id="soapA" class="soap-textarea"></textarea>
      </div>

      <div class="soap-block">
        <div class="soap-block-header">
          <span class="soap-label">P</span>
          <button class="copy-soap-btn" data-part="P">Copiar</button>
        </div>
        <textarea id="soapP" class="soap-textarea"></textarea>
      </div>

      <h2>Plano de Cuidados (Prescrição de Enfermagem)</h2>
      <textarea id="prescriptionOutput" class="prescription-textarea"></textarea>

      <div class="prescription-actions">
        <button id="copyPrescriptionBtn" class="btn-copy">Copiar plano de cuidados</button>
        <button id="printBtn" class="btn-print">Imprimir plano de cuidados</button>
      </div>
<h2>Classificação de risco por cores</h2>
      <div class="risk-triage-box">
        <div class="risk-triage-current">
          <span id="riskTriageBadge" class="risk-badge risk-none">Não informado</span>
          <div id="riskTriageMeaning" class="risk-meaning">Nenhum conteúdo disponível.</div>
        </div>
        <div id="riskTriageLegend" class="risk-legend"></div>
      </div>
      <div class="prescription-actions">
        <button id="copyRiskTriageBtn" class="btn-copy">Copiar classificação de risco</button>
        <button id="printRiskTriageBtn" class="btn-print">Imprimir classificação de risco</button>
      </div>
      <div id="riskTriageStatus" class="mini-status"></div>

      <h2>SAE (Processo de Enfermagem)</h2>
      <div id="pregnancyBox" class="classification-box">Nenhum conteúdo disponível.</div>
      <div class="prescription-actions">
        <button id="copySaeBtn" class="btn-copy">Copiar SAE</button>
        <button id="printPregnancyBtn" class="btn-print">Imprimir SAE</button>
      </div>

      <h2>Orientações ao paciente</h2>
      <div id="lactationBox" class="classification-box">Nenhum conteúdo disponível.</div>
      <div class="prescription-actions">
        <button id="copyOrientationsBtn" class="btn-copy">Copiar orientações</button>
        <button id="printLactationBtn" class="btn-print">Imprimir orientações</button>
      </div>
<div id="classificationsStatus" class="mini-status"></div>
    </div>

    
    <div id="medSafetyCard" class="module-card">
      <h2>Administração segura de medicamentos (registro de enfermagem)</h2>
                  <p class="mini-status" style="margin-top: 0;">
        Use o botão para fotografar a prescrição médica. O sistema irá transcrever o que estiver legível, organizar os medicamentos, apontar riscos e inconsistências relevantes para a enfermagem e sinalizar interações importantes quando for possível confirmar com segurança.
      </p>
<div class="prescription-actions">
        <label for="medCameraInput" class="photo-btn">Tirar foto</label>
        <label for="medFileInput" class="photo-btn">Escolher arquivo</label>
        <button id="copyMedSafetyBtn" class="btn-copy hidden">Copiar segurança dos medicamentos</button>
        <button id="printMedSafetyBtn" class="btn-print hidden">Imprimir segurança dos medicamentos</button>
      </div>

      <div id="interactionsStatus" class="mini-status"></div>
      <div id="interactionsBox" class="classification-box">Nenhum conteúdo disponível.</div>

      <input id="medCameraInput" class="hidden-input" type="file" accept="image/*" capture="environment" />
      <input id="medFileInput" class="hidden-input" type="file" accept="image/*" multiple />
    </div>

    <div id="woundCard" class="module-card">
      <h2>Curativos e feridas</h2>
      <p class="mini-status" style="margin-top: 0;">
        Use o botão para fotografar a lesão. O sistema irá descrever a ferida em linguagem técnica, apenas com base no que estiver visível, e sugerir condutas locais, cuidados não medicamentosos e, quando aplicável, opções de tratamento medicamentoso, além de sinais de alarme e critérios de encaminhamento, sem inventar dados.
      </p>

      <div class="prescription-actions">
        <label for="woundCameraInput" class="photo-btn">Tirar foto</label>
        <label for="woundFileInput" class="photo-btn">Escolher arquivo</label>
        <button id="copyWoundBtn" class="btn-copy hidden">Copiar descrição e conduta</button>
        <button id="printWoundBtn" class="btn-print hidden">Imprimir descrição e conduta</button>
      </div>

      <div id="presentationsMaxDoseStatus" class="mini-status"></div>
      <div id="presentationsMaxDoseBox" class="classification-box">Nenhum conteúdo disponível.</div>

      <input id="woundCameraInput" class="hidden-input" type="file" accept="image/*" capture="environment" />
      <input id="woundFileInput" class="hidden-input" type="file" accept="image/*" multiple />
    </div>


    <div id="examInterpretationCard" class="module-card">
      <h2>Interpretação de resultados de exames (laboratoriais, de imagem, etc)</h2>
      <p class="mini-status" style="margin-top: 0;">
        Use os botões para fotografar o resultado do exame (ex.: laudo, tabela de laboratório, impressão do sistema). O sistema irá transcrever somente o que estiver legível, organizar achados relevantes e oferecer uma interpretação clínica didática, com hipóteses possíveis, limitações, próximos passos e sinais de alarme, sem inventar dados.
      </p>

      <div class="prescription-actions">
        <label for="examCameraInput" class="photo-btn">Tirar foto</label>
        <label for="examFileInput" class="photo-btn">Escolher arquivo</label>
        <button id="copyExamBtn" class="btn-copy hidden">Copiar análise</button>
        <button id="printExamBtn" class="btn-print hidden">Imprimir análise</button>
      </div>

      <div id="examInterpretationStatus" class="mini-status"></div>
      <div id="examInterpretationBox" class="classification-box">Nenhum conteúdo disponível.</div>

      <input id="examCameraInput" class="hidden-input" type="file" accept="image/*" capture="environment" />
      <input id="examFileInput" class="hidden-input" type="file" accept="image/*" multiple />
    </div>

<div id="medicalDoubtsCard" class="module-card">
      <h2>Dúvidas em Saúde</h2>
      <p class="mini-status" style="margin-top: 0;">Faça qualquer pergunta sobre saúde. Pressione Enter ou clique em Enviar.</p><div class="inline-input-row" style="gap: 10px; align-items: stretch;">
  <input id="medicalDoubtInput" class="text-input" type="text" placeholder="Digite sua dúvida sobre saúde e pressione Enter" autocomplete="off" style="flex: 1 1 auto; margin: 0;" />
  <button id="medicalDoubtSendBtn" class="btn-print" type="button" style="white-space: nowrap;">Enviar</button>
</div>
      <div id="medicalDoubtStatus" class="mini-status"></div>
      <div id="medicalDoubtAnswer" class="answer-box"></div>
    </div>


                <div id="calculatorsCard" class="module-card">
      <h2>Calculadoras Clínicas</h2>
      <p class="mini-status" style="margin-top: 0;">
        Selecione a calculadora, preencha os campos e veja o resultado.
      </p>

      <div class="inline-input-row">
        <select id="calcSelect" class="text-input" style="min-width: 280px;">
          <option value="imc">IMC</option>
          <option value="cv_risk">Estratificação de Risco Cardiovascular</option>
          <option value="bsa">SC (Mosteller)</option>
          <option value="gest_age">Idade gestacional</option>
          <option value="drip_pump">Gotejamento e bomba de infusão</option>
          <option value="fluid_balance">Balanço hídrico</option>
          <option value="weight_dose">Dose por peso</option>
          <option value="glasgow">Glasgow (ECG)</option>
          <option value="sedation">Ramsay / RASS</option>
          <option value="pain">Escala de dor (0 a 10)</option>
          <option value="morse">Risco de quedas (Morse)</option>
          <option value="braden">Braden (LPP)</option>
          <option value="pews">PEWS (pediatria)</option>
        </select>
      </div>

      <div id="calcPanel_imc" class="calc-panel">
        <div class="calc-title">IMC</div>
        <p class="calc-help">Como funciona: IMC = peso (kg) / altura² (m²). Informe peso (kg) e altura (cm).</p>
        <div class="calc-row">
          <input id="imcWeightKg" class="text-input" type="number" step="0.1" min="0" placeholder="Peso (kg)" />
          <input id="imcHeightCm" class="text-input" type="number" step="0.1" min="0" placeholder="Altura (cm)" />
        </div>
        <div id="imcResult" class="answer-box"></div>
      </div>

      
      <div id="calcPanel_cv_risk" class="calc-panel hidden">
        <div class="calc-title">Estratificação de Risco Cardiovascular (PREVENT)</div>
        <p class="calc-help">
          Como funciona: estima risco de eventos cardiovasculares em 10 anos (e, quando aplicável, em 30 anos) a partir de fatores clínicos e laboratoriais.
          Informe idade, sexo, pressão arterial sistólica, colesterol total e HDL, peso e altura, creatinina, tabagismo, diabetes e se usa anti-hipertensivo ou estatina.
        </p>

        <div class="calc-row" style="margin-top: 10px;">
          <input id="cvAge" class="text-input" type="number" step="1" min="0" placeholder="Idade (anos)" />
          <select id="cvSex" class="text-input">
            <option value="female">Sexo: feminino</option>
            <option value="male">Sexo: masculino</option>
          </select>
        </div>

        <div class="calc-row">
          <input id="cvWeightKg" class="text-input" type="number" step="0.1" min="0" placeholder="Peso (kg)" />
          <input id="cvHeightCm" class="text-input" type="number" step="0.1" min="0" placeholder="Altura (cm)" />
        </div>

        <div class="calc-row">
          <input id="cvSbp" class="text-input" type="number" step="1" min="0" placeholder="PAS (mmHg)" />
          <input id="cvCreatinine" class="text-input" type="number" step="0.01" min="0" placeholder="Creatinina (mg/dL)" />
        </div>

        <div class="calc-row">
          <input id="cvTotalChol" class="text-input" type="number" step="1" min="0" placeholder="Colesterol total (mg/dL)" />
          <input id="cvHdl" class="text-input" type="number" step="1" min="0" placeholder="HDL (mg/dL)" />
        </div>

        <div class="calc-row">
          <select id="cvSmoker" class="text-input">
            <option value="0">Tabagismo: não</option>
            <option value="1">Tabagismo: sim</option>
          </select>
          <select id="cvDiabetes" class="text-input">
            <option value="0">Diabetes: não</option>
            <option value="1">Diabetes: sim</option>
          </select>
        </div>

        <div class="calc-row">
          <select id="cvOnHtnMeds" class="text-input">
            <option value="0">Em uso de anti-hipertensivo: não</option>
            <option value="1">Em uso de anti-hipertensivo: sim</option>
          </select>
          <select id="cvOnStatin" class="text-input">
            <option value="0">Em uso de estatina/hipolipemiante: não</option>
            <option value="1">Em uso de estatina/hipolipemiante: sim</option>
          </select>
        </div>

        <div id="cvRiskResult" class="answer-box"></div>
      </div>

      <div id="calcPanel_bsa"
 class="calc-panel hidden">
        <div class="calc-title">SC (Mosteller)</div>
        <p class="calc-help">Como funciona: SC (Mosteller) = raiz quadrada de (altura(cm) x peso(kg) / 3600). Informe peso (kg) e altura (cm).</p>
        <div class="calc-row">
          <input id="bsaWeightKg" class="text-input" type="number" step="0.1" min="0" placeholder="Peso (kg)" />
          <input id="bsaHeightCm" class="text-input" type="number" step="0.1" min="0" placeholder="Altura (cm)" />
        </div>
        <div id="bsaResult" class="answer-box"></div>
      </div>

      <div id="calcPanel_gest_age" class="calc-panel hidden">
        <div class="calc-title">Idade gestacional</div>
        <p class="calc-help">Como funciona: calcula idade gestacional a partir da DUM e estima a DPP (DUM + 280 dias). Informe a data da DUM.</p>
        <div class="calc-row">
          <label style="font-size: 13px; color: #333; font-weight: 700;">DUM</label>
          <input id="gestDum" class="text-input" type="date" />
        </div>
        <div id="gestResult" class="answer-box"></div>
      </div>

      <div id="calcPanel_drip_pump" class="calc-panel hidden">
        <div class="calc-title">Gotejamento e bomba de infusão</div>
        <p class="calc-help">Informe volume e tempo. O sistema calcula mL/h (bomba) e gotas/min (gotejamento) conforme o fator de gotejamento.</p>
        <div class="calc-row">
          <input id="dripVolumeMl" class="text-input" type="number" step="0.1" min="0" placeholder="Volume (mL)" />
          <input id="dripTimeH" class="text-input" type="number" step="1" min="0" placeholder="Tempo (h)" />
          <input id="dripTimeMin" class="text-input" type="number" step="1" min="0" placeholder="Tempo (min)" />
          <select id="dripFactor" class="text-input">
            <option value="20">Macro 20 gotas/mL</option>
            <option value="60">Micro 60 gotas/mL</option>
            <option value="10">10 gotas/mL</option>
            <option value="15">15 gotas/mL</option>
          </select>
        </div>
        <div id="dripResult" class="answer-box"></div>
      </div>

      <div id="calcPanel_fluid_balance" class="calc-panel hidden">
        <div class="calc-title">Balanço hídrico</div>
        <p class="calc-help">Preencha entradas e saídas (mL). Opcionalmente, informe peso e tempo para estimar diurese (mL/kg/h).</p>
        <div class="calc-row">
          <input id="fbInputMl" class="text-input" type="number" step="1" min="0" placeholder="Entradas (mL)" />
          <input id="fbOutputMl" class="text-input" type="number" step="1" min="0" placeholder="Saídas (mL)" />
          <input id="fbWeightKg" class="text-input" type="number" step="0.1" min="0" placeholder="Peso (kg, opcional)" />
          <input id="fbHours" class="text-input" type="number" step="0.1" min="0" placeholder="Tempo (h, opcional)" />
        </div>
        <div id="fbResult" class="answer-box"></div>
      </div>

      <div id="calcPanel_weight_dose" class="calc-panel hidden">
        <div class="calc-title">Dose por peso</div>
        <p class="calc-help">Calcula a dose por tomada (mg) a partir de mg/kg. Se houver concentração (mg/mL), calcula volume (mL).</p>
        <div class="calc-row">
          <input id="wdWeightKg" class="text-input" type="number" step="0.1" min="0" placeholder="Peso (kg)" />
          <input id="wdDoseMgKg" class="text-input" type="number" step="0.01" min="0" placeholder="Dose (mg/kg)" />
          <input id="wdMaxDoseMg" class="text-input" type="number" step="0.1" min="0" placeholder="Dose máx (mg, opcional)" />
          <input id="wdConcMgMl" class="text-input" type="number" step="0.01" min="0" placeholder="Concentração (mg/mL, opcional)" />
        </div>
        <div id="wdResult" class="answer-box"></div>
      </div>

      <div id="calcPanel_glasgow" class="calc-panel hidden">
        <div class="calc-title">Escala de Coma de Glasgow (ECG)</div>
        <p class="calc-help">Selecione os componentes. Total varia de 3 a 15.</p>

        <div class="calc-row">
          <select id="gcsEye" class="text-input">
            <option value="4">Abertura ocular: espontânea (4)</option>
            <option value="3">Abertura ocular: ao som (3)</option>
            <option value="2">Abertura ocular: à dor (2)</option>
            <option value="1">Abertura ocular: nenhuma (1)</option>
          </select>

          <select id="gcsVerbal" class="text-input">
            <option value="5">Resposta verbal: orientado (5)</option>
            <option value="4">Resposta verbal: confuso (4)</option>
            <option value="3">Resposta verbal: palavras inapropriadas (3)</option>
            <option value="2">Resposta verbal: sons incompreensíveis (2)</option>
            <option value="1">Resposta verbal: nenhuma (1)</option>
          </select>

          <select id="gcsMotor" class="text-input">
            <option value="6">Resposta motora: obedece comandos (6)</option>
            <option value="5">Resposta motora: localiza dor (5)</option>
            <option value="4">Resposta motora: retira à dor (4)</option>
            <option value="3">Resposta motora: flexão anormal (3)</option>
            <option value="2">Resposta motora: extensão (2)</option>
            <option value="1">Resposta motora: nenhuma (1)</option>
          </select>
        </div>

        <div id="gcsResult" class="answer-box"></div>
      </div>

      <div id="calcPanel_sedation" class="calc-panel hidden">
        <div class="calc-title">Ramsay / RASS</div>
        <p class="calc-help">Selecione a pontuação e veja a interpretação resumida.</p>

        <div class="calc-row">
          <select id="ramsay" class="text-input">
            <option value="1">Ramsay 1: ansioso/agitado</option>
            <option value="2">Ramsay 2: cooperativo/orientado/tranquilo</option>
            <option value="3">Ramsay 3: responde a comandos</option>
            <option value="4">Ramsay 4: resposta rápida a estímulo (tátil/sonoro)</option>
            <option value="5">Ramsay 5: resposta lenta a estímulo</option>
            <option value="6">Ramsay 6: sem resposta</option>
          </select>

          <select id="rass" class="text-input">
            <option value="4">RASS +4: combativo</option>
            <option value="3">RASS +3: muito agitado</option>
            <option value="2">RASS +2: agitado</option>
            <option value="1">RASS +1: inquieto</option>
            <option value="0">RASS 0: alerta e calmo</option>
            <option value="-1">RASS -1: sonolento</option>
            <option value="-2">RASS -2: sedação leve</option>
            <option value="-3">RASS -3: sedação moderada</option>
            <option value="-4">RASS -4: sedação profunda</option>
            <option value="-5">RASS -5: não desperta</option>
          </select>
        </div>

        <div id="sedationResult" class="answer-box"></div>
      </div>

      <div id="calcPanel_pain" class="calc-panel hidden">
        <div class="calc-title">Escala de dor (0 a 10)</div>
        <p class="calc-help">Informe a pontuação referida. Interpretação usual: 1-3 leve, 4-6 moderada, 7-10 intensa.</p>
        <div class="calc-row">
          <input id="painScore" class="text-input" type="number" step="1" min="0" max="10" placeholder="Dor (0-10)" />
        </div>
        <div id="painResult" class="answer-box"></div>
      </div>

      <div id="calcPanel_morse" class="calc-panel hidden">
        <div class="calc-title">Risco de quedas (Morse)</div>
        <p class="calc-help">Selecione cada item e o sistema soma a pontuação.</p>

        <div class="calc-row">
          <select id="morseFallHx" class="text-input">
            <option value="0">Histórico de quedas: não (0)</option>
            <option value="25">Histórico de quedas: sim (25)</option>
          </select>

          <select id="morseSecondaryDx" class="text-input">
            <option value="0">Diagnóstico secundário: não (0)</option>
            <option value="15">Diagnóstico secundário: sim (15)</option>
          </select>

          <select id="morseAid" class="text-input">
            <option value="0">Auxílio à deambulação: nenhum/repouso/leito/ajuda profissional (0)</option>
            <option value="15">Auxílio à deambulação: muletas/bengala/andador (15)</option>
            <option value="30">Auxílio à deambulação: apoia-se em móveis (30)</option>
          </select>

          <select id="morseIv" class="text-input">
            <option value="0">Terapia endovenosa (soro/heparina lock): não (0)</option>
            <option value="20">Terapia endovenosa (soro/heparina lock): sim (20)</option>
          </select>

          <select id="morseGait" class="text-input">
            <option value="0">Marcha/transferência: normal/repouso/uso de cadeira (0)</option>
            <option value="10">Marcha/transferência: fraca (10)</option>
            <option value="20">Marcha/transferência: prejudicada (20)</option>
          </select>

          <select id="morseMental" class="text-input">
            <option value="0">Estado mental: reconhece limitações (0)</option>
            <option value="15">Estado mental: esquece limitações (15)</option>
          </select>
        </div>

        <div id="morseResult" class="answer-box"></div>
      </div>

      <div id="calcPanel_braden" class="calc-panel hidden">
        <div class="calc-title">Braden (risco de LPP)</div>
        <p class="calc-help">Selecione cada subescala (valores usuais). Total varia de 6 a 23.</p>

        <div class="calc-row">
          <select id="brSensory" class="text-input">
            <option value="4">Percepção sensorial: sem limitação (4)</option>
            <option value="3">Percepção sensorial: levemente limitada (3)</option>
            <option value="2">Percepção sensorial: muito limitada (2)</option>
            <option value="1">Percepção sensorial: completamente limitada (1)</option>
          </select>

          <select id="brMoisture" class="text-input">
            <option value="4">Umidade: raramente úmido (4)</option>
            <option value="3">Umidade: ocasionalmente úmido (3)</option>
            <option value="2">Umidade: frequentemente úmido (2)</option>
            <option value="1">Umidade: constantemente úmido (1)</option>
          </select>

          <select id="brActivity" class="text-input">
            <option value="4">Atividade: anda frequentemente (4)</option>
            <option value="3">Atividade: anda ocasionalmente (3)</option>
            <option value="2">Atividade: restrito à cadeira (2)</option>
            <option value="1">Atividade: acamado (1)</option>
          </select>

          <select id="brMobility" class="text-input">
            <option value="4">Mobilidade: sem limitação (4)</option>
            <option value="3">Mobilidade: levemente limitada (3)</option>
            <option value="2">Mobilidade: muito limitada (2)</option>
            <option value="1">Mobilidade: completamente imóvel (1)</option>
          </select>

          <select id="brNutrition" class="text-input">
            <option value="4">Nutrição: excelente (4)</option>
            <option value="3">Nutrição: adequada (3)</option>
            <option value="2">Nutrição: provavelmente inadequada (2)</option>
            <option value="1">Nutrição: muito pobre (1)</option>
          </select>

          <select id="brFriction" class="text-input">
            <option value="3">Fricção/cisalhamento: nenhum problema aparente (3)</option>
            <option value="2">Fricção/cisalhamento: problema potencial (2)</option>
            <option value="1">Fricção/cisalhamento: problema (1)</option>
          </select>
        </div>

        <div id="bradenResult" class="answer-box"></div>
      </div>

      <div id="calcPanel_pews" class="calc-panel hidden">
        <div class="calc-title">PEWS (pediatria)</div>
        <p class="calc-help">Modelo baseado no Brighton PEWS: comportamento, cardiovascular e respiratório (0 a 3 cada). Use junto ao protocolo institucional de escalonamento.</p>

        <div class="calc-row">
          <select id="pewsBehavior" class="text-input">
            <option value="0">Comportamento: responsivo/apropriado (0)</option>
            <option value="1">Comportamento: sonolento/agitado, consolável (1)</option>
            <option value="2">Comportamento: irritado/agitado, não consolável (2)</option>
            <option value="3">Comportamento: letárgico/confuso ou pouca resposta à dor (3)</option>
          </select>

          <select id="pewsCardio" class="text-input">
            <option value="0">Cardiovascular: cor normal ou TPC 1-2s (0)</option>
            <option value="1">Cardiovascular: pálido ou TPC 3s (1)</option>
            <option value="2">Cardiovascular: acinzentado/cianótico ou TPC 4s, ou FC &gt; 20 acima do normal (2)</option>
            <option value="3">Cardiovascular: moteado/TPC ≥ 5s, ou FC &gt; 30 acima do normal, ou bradicardia (3)</option>
          </select>

          <select id="pewsResp" class="text-input">
            <option value="0">Respiratório: sem desconforto (0)</option>
            <option value="1">Respiratório: FR &gt; 10 acima do normal ou uso leve de musculatura acessória (1)</option>
            <option value="2">Respiratório: FR &gt; 20 acima do normal ou retrações marcadas (2)</option>
            <option value="3">Respiratório: FR &gt; 30 acima do normal ou desconforto grave (3)</option>
          </select>
        </div>

        <div id="pewsResult" class="answer-box"></div>
      </div>

    </div>

    <div id="sbarCard" class="module-card">
      <div class="module-title-row">
        <h2>Passagem de Plantão (SBAR)</h2>
        <button id="openSbarGuideBtn" class="mini-consult-btn sbar-guide-btn" type="button">Guia</button>
      </div>
      <p class="module-subtitle">Use este módulo para gravar rapidamente (no momento do plantão) e gerar uma passagem de plantão no padrão SBAR (Situação, Background, Avaliação, Recomendação).</p>

      <div id="sbarGuidePanel" class="guide-inline hidden">
        <h3>Guia rápido para Passagem de Plantão (SBAR)</h3>
        <p>Use este roteiro para lembrar as perguntas essenciais. Você pode seguir na ordem SBAR, mas adapte ao caso.</p>

        <h4>Situação (S)</h4>
        <ul>
          <li>Quem é o paciente (nome/idade/leito) e por que está internado/atendido agora?</li>
          <li>Qual é o problema principal neste momento? O que mudou nas últimas horas?</li>
          <li>Há alguma urgência imediata (via aérea, respiração, circulação, sangramento, dor intensa, rebaixamento)?</li>
        </ul>

        <h4>Background (B)</h4>
        <ul>
          <li>Diagnóstico(s) principal(is) e tempo de evolução/internação.</li>
          <li>Comorbidades relevantes (HAS, DM, DPOC/asma, IRC, cardiopatia, anticoagulação, etc.).</li>
          <li>Alergias, medicamentos em uso e antibióticos (dose/horário da próxima dose).</li>
          <li>Procedimentos/dispositivos: acesso venoso, sonda vesical, SNG, drenos, oxigênio, ventilação, curativos.</li>
          <li>Isolamento/precauções, histórico recente de febre, quedas, delirium, convulsões.</li>
        </ul>

        <h4>Avaliação (A)</h4>
        <ul>
          <li>Sinais vitais atuais e tendência (PA, FC, FR, SpO2, temperatura), diurese e balanço hídrico quando aplicável.</li>
          <li>Estado geral e exame dirigido (consciência, perfusão, dispneia, dor, sangramentos, feridas, edema).</li>
          <li>Resultados relevantes: glicemias, hemograma, eletrólitos, função renal, gasometria, culturas, imagem recente.</li>
          <li>Risco e segurança: risco de queda/lesão por pressão, risco de broncoaspiração, escala de dor, sedação.</li>
        </ul>

        <h4>Recomendação (R)</h4>
        <ul>
          <li>O que precisa ser feito no próximo turno? Liste tarefas e prioridades.</li>
          <li>Metas e monitorização: parâmetros-alvo, frequência de checagens, quando reavaliar.</li>
          <li>Exames pendentes e o que fazer com o resultado (conduta se alterar).</li>
          <li>Sinais de alarme e quando acionar o médico/plantonista.</li>
          <li>Plano de alta/transferência se aplicável.</li>
        </ul>

        <p><strong>Dica prática:</strong> se faltar alguma informação, pergunte e registre durante a própria gravação do SBAR. Quanto mais completo o relato, melhor a passagem de plantão.</p>
      </div>

      <button id="sbarRecordBtn" class="start" type="button">Iniciar passagem de plantão (SBAR)</button>
      <div id="sbarTimer" class="mini-timer hidden">00:00</div>
      <div id="sbarStatus" class="mini-status">Clique em "Iniciar passagem de plantão (SBAR)" para começar.</div>

      <textarea id="sbarOutput" class="output-textarea" placeholder="O SBAR gerado aparecerá aqui..." spellcheck="false"></textarea>

      <div class="prescription-actions">
        <button id="copySbarBtn" class="btn-copy" type="button">Copiar</button>
        <button id="printSbarBtn" class="btn-print" type="button">Imprimir</button>
      </div>
    </div>




                <div id="patientReportCard" class="module-card">
      <h2>Relatórios de Enfermagem / Encaminhamentos / Declarações / Solicitações / Comunicados / Atestado de comparecimento ou permanência / ATA reunião / Registros de procedimentos</h2>
      <p class="mini-status" style="margin-top: 0;">
        Grave em voz alta o conteúdo do documento. Diga claramente qual documento deseja produzir (por exemplo: declaração de comparecimento, relatório de curativo seriado, encaminhamento para CAPS, solicitação de insumos, comunicado para escola, ata de reunião). Ao encerrar
    

, a gravação será usada para identificar o tipo de documento e gerar um texto padronizado pronto para colar no S.U.I.S.
      </p>

      <div class="inline-input-row">
        <label for="reportDocTypeSelect" style="font-size: 13px; color: #111827; font-weight: 600;">Tipo de documento:</label>
        <select id="reportDocTypeSelect" class="text-input" style="min-width: 260px; max-width: 100%;">          <option value="auto" selected>Auto (identificar pela gravação)</option>
          <option value="Declaração de comparecimento">Declaração de comparecimento</option>
          <option value="Declaração de permanência">Declaração de permanência</option>
          <option value="Declaração para acompanhante">Declaração para acompanhante</option>
          <option value="Declaração de recebimento de orientações">Declaração de recebimento de orientações</option>
          <option value="Declaração de recusa de procedimento/conduta">Declaração de recusa de procedimento/conduta</option>
          <option value="Termo de consentimento informado (procedimento de enfermagem)">Termo de consentimento informado (procedimento de enfermagem)</option>
          <option value="Termo de ciência e responsabilidade (orientações e riscos)">Termo de ciência e responsabilidade (orientações e riscos)</option>
          <option value="Comunicado para escola">Comunicado para escola</option>
          <option value="Relatório para escola (necessidades específicas)">Relatório para escola (necessidades específicas)</option>
          <option value="Comunicado ao Conselho Tutelar">Comunicado ao Conselho Tutelar</option>
          <option value="Relatório para Conselho Tutelar (proteção à criança/adolescente)">Relatório para Conselho Tutelar (proteção à criança/adolescente)</option>
          <option value="Relatório de curativo seriado">Relatório de curativo seriado</option>
          <option value="Registro de procedimento de curativo">Registro de procedimento de curativo</option>
          <option value="Registro de retirada de pontos/suturas">Registro de retirada de pontos/suturas</option>
          <option value="Registro de procedimento de vacinação">Registro de procedimento de vacinação</option>
          <option value="Registro de evento adverso pós-vacinação (EAPV)">Registro de evento adverso pós-vacinação (EAPV)</option>
          <option value="Registro de procedimento de administração de medicamentos">Registro de procedimento de administração de medicamentos</option>
          <option value="Registro de administração de medicamento controlado (registro interno)">Registro de administração de medicamento controlado (registro interno)</option>
          <option value="Registro de coleta de exames">Registro de coleta de exames</option>
          <option value="Registro de nebulização/oxigenoterapia">Registro de nebulização/oxigenoterapia</option>
          <option value="Registro de sondagem vesical">Registro de sondagem vesical</option>
          <option value="Registro de troca de sonda/traqueostomia/gastrostomia">Registro de troca de sonda/traqueostomia/gastrostomia</option>
          <option value="Registro de visita domiciliar">Registro de visita domiciliar</option>
          <option value="Relatório de visita domiciliar">Relatório de visita domiciliar</option>
          <option value="Relatório de adesão e educação em saúde (HAS/DM)">Relatório de adesão e educação em saúde (HAS/DM)</option>
          <option value="Relatório de acompanhamento de hipertensão (HAS)">Relatório de acompanhamento de hipertensão (HAS)</option>
          <option value="Relatório de acompanhamento de diabetes (DM)">Relatório de acompanhamento de diabetes (DM)</option>
          <option value="Relatório de acompanhamento de asma/DPOC">Relatório de acompanhamento de asma/DPOC</option>
          <option value="Relatório de acompanhamento de saúde da criança (puericultura)">Relatório de acompanhamento de saúde da criança (puericultura)</option>
          <option value="Relatório de acompanhamento de pré-natal (enfermagem)">Relatório de acompanhamento de pré-natal (enfermagem)</option>
          <option value="Relatório de puerpério (enfermagem)">Relatório de puerpério (enfermagem)</option>
          <option value="Relatório para assistência social (vulnerabilidade e insumos)">Relatório para assistência social (vulnerabilidade e insumos)</option>
          <option value="Solicitação de insumos (fraldas, curativos, suplementos)">Solicitação de insumos (fraldas, curativos, suplementos)</option>
          <option value="Solicitação de fraldas (infantil/geriátrica)">Solicitação de fraldas (infantil/geriátrica)</option>
          <option value="Solicitação de materiais para ostomia">Solicitação de materiais para ostomia</option>
          <option value="Solicitação de dieta enteral/suplementação">Solicitação de dieta enteral/suplementação</option>
          <option value="Solicitação de oxigenoterapia domiciliar">Solicitação de oxigenoterapia domiciliar</option>
          <option value="Solicitação de equipamentos de apoio (cadeira de rodas, colchão pneumático)">Solicitação de equipamentos de apoio (cadeira de rodas, colchão pneumático)</option>
          <option value="Solicitação de transporte sanitário">Solicitação de transporte sanitário</option>
          <option value="Solicitação de avaliação médica">Solicitação de avaliação médica</option>
          <option value="Encaminhamento para Médico (demanda espontânea)">Encaminhamento para Médico (demanda espontânea)</option>
          <option value="Encaminhamento para sala de vacina">Encaminhamento para sala de vacina</option>
          <option value="Encaminhamento para curativos/ambulatório de feridas">Encaminhamento para curativos/ambulatório de feridas</option>
          <option value="Encaminhamento para CAPS / saúde mental">Encaminhamento para CAPS / saúde mental</option>
          <option value="Relatório para CAPS / saúde mental (enfermagem)">Relatório para CAPS / saúde mental (enfermagem)</option>
          <option value="Encaminhamento para Serviço Social">Encaminhamento para Serviço Social</option>
          <option value="Encaminhamento para Psicologia">Encaminhamento para Psicologia</option>
          <option value="Encaminhamento para Nutrição">Encaminhamento para Nutrição</option>
          <option value="Encaminhamento para Fisioterapia">Encaminhamento para Fisioterapia</option>
          <option value="Encaminhamento para Fonoaudiologia">Encaminhamento para Fonoaudiologia</option>
          <option value="Encaminhamento para Odontologia">Encaminhamento para Odontologia</option>
          <option value="Encaminhamento para especialista / rede">Encaminhamento para especialista / rede</option>
          <option value="Encaminhamento para urgência/emergência">Encaminhamento para urgência/emergência</option>
          <option value="Relatório de evolução de enfermagem">Relatório de evolução de enfermagem</option>
          <option value="Relatório de intercorrência/ocorrência">Relatório de intercorrência/ocorrência</option>
          <option value="Ata de reunião">Ata de reunião</option>
          <option value="Registro de reunião de equipe (ATA breve)">Registro de reunião de equipe (ATA breve)</option>
          <option value="Comunicado interno da equipe">Comunicado interno da equipe</option>
          <option value="Outros">Outros</option>
</select>
      </div>

      <div class="inline-input-row">
        <button id="reportRecordBtn" class="small-record-btn start" type="button">Gravar documento</button>
        <button id="copyReportBtn" class="btn-copy hidden" type="button">Copiar documento</button>
        <button id="printReportBtn" class="btn-print hidden" type="button">Imprimir documento</button>
      </div>

      <div id="reportStatus" class="mini-status"></div>

      <div class="inline-input-row" style="margin-top: 6px;">
        <div style="flex: 1; min-width: 240px;">
          <div style="font-size: 12px; font-weight: 700; color: #111827; margin-bottom: 4px;">Tipo identificado</div>
          <div id="reportDocTypeDetected" class="answer-box" style="min-height: 44px;"></div>
        </div>
        <div style="flex: 1; min-width: 240px;">
          <div style="font-size: 12px; font-weight: 700; color: #111827; margin-bottom: 4px;">Campos pendentes</div>
          <div id="reportMissingFields" class="answer-box" style="min-height: 44px;"></div>
        </div>
      </div>

      <textarea id="reportOutput" class="prescription-textarea" placeholder="O documento gerado aparecerá aqui." style="margin-top: 12px;"></textarea>
    </div>

  </div>

  <div id="recommendationsPanel" class="recommendations-panel">
    <div class="recommendations-header">
      <h3>Perguntas essenciais para anamnese</h3>
      <button id="closeRecommendationsBtn" class="close-panel-btn" aria-label="Fechar painel de recomendações">X</button>
    </div>
    <div id="recommendationsStatus" class="recommendations-status">
      Clique em "Perguntas essenciais" para gerar perguntas complementares essenciais.
    </div>
    <div id="recommendationsList" class="recommendations-list"></div>
    <button id="askQuestionsBtn" class="ask-questions-btn" disabled>Complementar avaliação</button>
    <div id="questionsTimer" class="questions-timer hidden">00:00</div>
    <p class="recommendations-footer">
      Ao clicar em "Complementar avaliação", uma nova gravação será iniciada para você aplicar essas perguntas diretamente ao paciente.
      As respostas serão usadas para atualizar automaticamente o SOAP e a conduta.
    </p>
  </div>


  <div id="imageChoiceOverlay" class="modal-overlay hidden">
  <div class="modal" style="max-width: 560px;">
    <h3 id="imageChoiceTitle">Imagens para análise</h3>
    <p id="imageChoiceHint">Selecione uma ou mais imagens. Você pode adicionar várias antes de analisar.</p>

    <div id="imageChoicePreview" class="image-preview-grid" aria-label="Pré-visualização das imagens selecionadas"></div>
    <div id="imageChoiceCount" style="margin-top: 8px; font-size: 12px; color: #374151;"></div>

    <div class="modal-actions" style="flex-wrap: wrap;">
      <button id="chooseCameraBtn" class="danger">Tirar foto agora</button>
      <button id="chooseFileBtn" class="primary">Escolher arquivo</button>
      <button id="clearChosenImagesBtn">Limpar</button>
      <button id="runImageAnalysisBtn" class="primary" disabled>Analisar</button>
      <button id="cancelImageChoiceBtn">Cancelar</button>
    </div>
  </div>
</div>
  </div>


  </div>

  <script>

    const DEFAULT_BACKEND_URL = "https://consulta-enfermagem-1.onrender.com";
    // Backend principal (Render). Pode ser sobrescrito por:
    // 1) Querystring ?backend=https://...  (útil para testes)
    // 2) localStorage BACKEND_URL_OVERRIDE
    // Se estiver rodando localmente, usa http://localhost:3000
    const BACKEND_URL = (() => {
      const qp = new URLSearchParams(window.location.search);
      const fromQuery = (qp.get("backend") || "").trim();
      const fromStorage = (localStorage.getItem("BACKEND_URL_OVERRIDE") || "").trim();
      const raw = (fromQuery || fromStorage || "").trim();
      const norm = (v) => String(v || "").trim().replace(/\/+$/g, "");
      if (raw) return norm(raw);
      const host = String(window.location.hostname || "");
      if (host === "localhost" || host === "127.0.0.1") return "http://localhost:3000";
      return norm(DEFAULT_BACKEND_URL);
    })();

    // =========================
    // IMAGENS (Curativos e Prescrição) - estado por módulo (até 4 fotos)
    // =========================
    let woundImages = [];
    let medImages = [];
    let examImages = [];
    let woundAnalyzeTimer = null;
    let medAnalyzeTimer = null;
    let examAnalyzeTimer = null;

    function scheduleWoundAnalysis() {
      if (woundAnalyzeTimer) clearTimeout(woundAnalyzeTimer);
      woundAnalyzeTimer = setTimeout(() => {
        if (woundImages && woundImages.length) analyzeWoundWithImages(woundImages.slice());
      }, 180);
    }

    function scheduleMedAnalysis() {
      if (medAnalyzeTimer) clearTimeout(medAnalyzeTimer);
      medAnalyzeTimer = setTimeout(() => {
        if (medImages && medImages.length) analyzePrescriptionWithImages(medImages.slice());
      }, 180);
    }

    function scheduleExamAnalysis() {
      if (examAnalyzeTimer) clearTimeout(examAnalyzeTimer);
      examAnalyzeTimer = setTimeout(() => {
        if (examImages && examImages.length) analyzeExamWithImages(examImages.slice());
      }, 180);
    }

// =========================
    // ADMIN (caches globais - sem TDZ)
    // =========================
    var ADMIN_CACHE_USERS = [];
    var ADMIN_CACHE_AUDIT = [];
    var ADMIN_SELECTED_USER_ID = null;
    var ADMIN_SELECTED_USER_LABEL = "";

    // =========================
    // AUTENTICAÇÃO (sem escolha de perfil)
    // =========================
    const TOKEN_KEY = "ae_token_v1";

    // Diagnóstico visível: se algum erro de JS impedir o login, ele aparece aqui
    function showFatalError(msg) {
      const el = document.getElementById("loginError");
      if (el && msg) el.textContent = String(msg);
    }
    window.addEventListener("error", (ev) => {
      try {
        const m = (ev && ev.message) ? ev.message : "Erro inesperado";
        showFatalError("Erro no sistema: " + m);
      } catch {}
    });
    window.addEventListener("unhandledrejection", (ev) => {
      try {
        const r = ev && ev.reason;
        const m = (r && r.message) ? r.message : (typeof r === "string" ? r : "Falha inesperada");
        showFatalError("Erro no sistema: " + m);
      } catch {}
    });


    // Mostra erros de script diretamente na tela de login (evita sensação de "não acontece nada")
    window.addEventListener('error', (ev) => {
      try {
        const el = document.getElementById('loginError');
        if (el && ev && ev.message) el.textContent = 'Erro no sistema: ' + ev.message;
      } catch {}
    });
    window.addEventListener('unhandledrejection', (ev) => {
      try {
        const el = document.getElementById('loginError');
        const msg = (ev && ev.reason && (ev.reason.message || String(ev.reason))) ? (ev.reason.message || String(ev.reason)) : 'Erro inesperado.';
        if (el) el.textContent = 'Erro no sistema: ' + msg;
      } catch {}
    });

    const nativeFetch = window.fetch.bind(window);

    // Backup local automático (para não perder clientes em redeploy/atualizações do backend)
    const LOCAL_BACKUP_KEY = "ae_local_backup_v1";
    const LOCAL_BACKUP_AT_KEY = "ae_local_backup_at_v1";
    let RECOVERY_TRIED = false;
    let RECOVERY_RUNNING = false;

    function setLocalBackupText(txt) {
      try {
        localStorage.setItem(LOCAL_BACKUP_KEY, txt || "");
        localStorage.setItem(LOCAL_BACKUP_AT_KEY, new Date().toISOString());
      } catch {}
    }
    function getLocalBackupText() {
      try { return localStorage.getItem(LOCAL_BACKUP_KEY) || ""; } catch { return ""; }
    }
    function getLocalBackupPayload() {
      const txt = getLocalBackupText();
      if (!txt) return null;
      try { return JSON.parse(txt); } catch { return null; }
    }
    function updateAdminLocalBackupBadge() {
      const el = document.getElementById("adminLocalBackupInfo");
      if (!el) return;
      let at = "";
      try { at = localStorage.getItem(LOCAL_BACKUP_AT_KEY) || ""; } catch {}
      if (!at) {
        el.textContent = "Backup local: não disponível";
        return;
      }
      try {
        el.textContent = "Backup local: " + new Date(at).toLocaleString("pt-BR");
      } catch {
        el.textContent = "Backup local: disponível";
      }
    }
    async function refreshLocalBackupFromServer() {
      try {
        const t = getToken();
        if (!t) return;
        const resp = await fetch(BACKEND_URL + "/api/admin/backup/export", { method: "GET" });
        if (!resp.ok) return;
        const txt = await resp.text();
        if (!txt || txt.trim().length < 2) return;
        if (!txt.trim().startsWith("{")) return;
        setLocalBackupText(txt);
        updateAdminLocalBackupBadge();
      } catch {}
    }

    function getToken() {
      try { return localStorage.getItem(TOKEN_KEY) || ""; } catch { return ""; }
    }
    function setToken(t) {
      try {
        if (t) localStorage.setItem(TOKEN_KEY, t);
        else localStorage.removeItem(TOKEN_KEY);
      } catch {}
    }

    function showLogin() {
      document.getElementById("loginView")?.classList.remove("hidden");
      document.getElementById("adminView")?.classList.add("hidden");
      document.getElementById("nurseView")?.classList.add("hidden");
      document.getElementById("paymentsModal")?.classList.add("hidden");
    }
    function showAdmin() {
      document.getElementById("loginView")?.classList.add("hidden");
      document.getElementById("adminView")?.classList.remove("hidden");
      document.getElementById("nurseView")?.classList.add("hidden");
    }
    function showNurse() {
      document.getElementById("loginView")?.classList.add("hidden");
      document.getElementById("adminView")?.classList.add("hidden");
      document.getElementById("nurseView")?.classList.remove("hidden");
    }

    // Intercepta chamadas ao backend e injeta Authorization quando for /api/
    window.fetch = async function(input, init) {
      try {
        const url = (typeof input === "string") ? input : (input && input.url) ? input.url : "";
        const isApi = (() => {
        if (typeof url !== "string") return false;
        const u = url;
        const p1 = BACKEND_URL + "/api/";
        const p2 = "/api/";
        const p3 = window.location.origin + "/api/";
        return u.startsWith(p1) || u.startsWith(p2) || u.startsWith(p3);
      })();
        if (!isApi) return nativeFetch(input, init);

        const headers = Object.assign({}, (init && init.headers) ? init.headers : {});
        const token = getToken();
        if (token) headers["Authorization"] = "Bearer " + token;
        const resp = await nativeFetch(input, Object.assign({}, init || {}, { headers }));

        if (resp && resp.status === 401) {
          setToken("");
          showLogin();
        }
        return resp;
      } catch (e) {
        return nativeFetch(input, init);
      }
    };

    async function authMe() {
      const resp = await fetch(BACKEND_URL + "/api/auth/me", { method: "GET" });
      if (!resp.ok) throw new Error("me failed");
      return await resp.json();
    }

    async function doLogin() {
      const login = (document.getElementById("loginField")?.value || "").trim();
      const senha = (document.getElementById("passwordField")?.value || "").trim();
      const errEl = document.getElementById("loginError");
      const btn = document.getElementById("loginBtn");
      if (!login || !senha) {
        if (errEl) errEl.textContent = "Informe login e senha.";
        return;
      }
      if (errEl) errEl.textContent = "Conectando...";
      if (btn) btn.disabled = true;
      try {
        const resp = await nativeFetch(BACKEND_URL + "/api/auth/login", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ login, senha })
        });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) {
          if (errEl) errEl.textContent = data.error || "Falha no login.";
          return;
        }
        setToken(data.token || "");
        await restoreSession();
      } catch (e) {
        if (errEl) errEl.textContent = "Falha ao conectar no servidor.";
      } finally {
        if (btn) btn.disabled = false;
      }
    }

    function logoutAll() {
      setToken("");
      showLogin();
    }

    // Heartbeat para status online
    let heartbeatTimer = null;
    function startHeartbeat() {
      if (heartbeatTimer) clearInterval(heartbeatTimer);
      const ping = async () => {
        try {
          await fetch(BACKEND_URL + "/api/auth/heartbeat", { method: "POST" });
        } catch {}
      };
      ping();
      heartbeatTimer = setInterval(ping, 30000);
    }

    async function restoreSession() {
      const token = getToken();
      if (!token) { showLogin(); return; }
      try {
        const me = await authMe();
        if (me && me.role === "admin") {
          showAdmin();
          startHeartbeat();
          await adminLoadAll();
          updateAdminLocalBackupBadge();
          await refreshLocalBackupFromServer();
        } else if (me && me.role === "nurse") {
          showNurse();
          startHeartbeat();
          updateNurseBar(me);
        } else {
          showLogin();
        }
      } catch (e) {
        showLogin();
        const errEl = document.getElementById("loginError");
        if (errEl) errEl.textContent = "Falha ao validar a sessão no servidor. Verifique se o backend está ativo e tente novamente.";
      }
    }

    function updateNurseBar(me) {
      // Aceita tanto o formato {role, user:{...}} quanto formato "achatado"
      const u = (me && me.user && typeof me.user === "object") ? me.user : (me || {});
      const name = (u.fullName || u.login || "-");
      const login = (u.login || "-");
      const paidFlag = (u.isPaidThisMonth !== undefined) ? !!u.isPaidThisMonth
        : (u.paidCurrentMonth !== undefined) ? !!u.paidCurrentMonth
        : (me && me.isPaidThisMonth !== undefined) ? !!me.isPaidThisMonth
        : (me && me.paidCurrentMonth !== undefined) ? !!me.paidCurrentMonth
        : false;

      const month = (me && me.currentMonth) ? me.currentMonth : (u.currentMonth || "");
      const lbl = document.getElementById("nurseUserLabel");
      const lblLogin = document.getElementById("nurseLoginLabel");
      const pay = document.getElementById("nursePaymentLabel");

      if (lbl) lbl.textContent = name;
      if (lblLogin) lblLogin.textContent = login;

      if (pay) {
        pay.textContent = paidFlag ? ("Em dia" + (month ? " (" + month + ")" : "")) : ("Em atraso" + (month ? " (" + month + ")" : ""));
        pay.classList.remove("green","red");
        pay.classList.add(paidFlag ? "green" : "red");
      }
    }

    // Eventos de login/logout
    document.getElementById("loginBtn")?.addEventListener("click", doLogin);
    document.getElementById("loginField")?.addEventListener("keydown", (e) => { if (e.key === "Enter") doLogin(); });
    document.getElementById("passwordField")?.addEventListener("keydown", (e) => { if (e.key === "Enter") doLogin(); });
    document.getElementById("nurseLogoutBtn")?.addEventListener("click", logoutAll);
    document.getElementById("adminLogoutBtn")?.addEventListener("click", logoutAll);


    let recognition;
    let isRecording = false;
    let isPaused = false;
    let finalTranscript = "";
    let baseTranscript = "";
    let baseTranscriptRaw = "";
    let timerInterval = null;
    let startTime = null;
    let accumulatedSeconds = 0;
    let currentSoapRaw = "";

    // ============================
    // ============================
    // MÓDULO: Perguntas e procedimentos essenciais em tempo real (FLUXO CONTROLADO)
    // ============================
    let interimTranscript = "";

    // Fluxo: aguarda motivo -> gera até 3 perguntas -> enfermeiro marca pergunta feita -> aguarda resposta -> atualiza
    let guidanceEnabled = false;
    let guidanceStage = "aguardando_motivo"; // "aguardando_motivo" | "perguntas"
    let guidancePending = []; // array de strings
    let guidanceContextLabel = "";
    let guidanceHypothesis = "";
    let guidanceConfidence = 0; // 0..95

    let guidanceInFlight = false;
    let guidanceAskedQuestion = "";
    let guidanceAskedAtLen = 0;
    let guidanceAskedAtTs = 0;
    let guidanceAnswerDebounce = null;
    let guidanceLastPayloadHash = "";
    let guidanceTurnState = "aguardando_pergunta"; // "aguardando_pergunta" | "aguardando_resposta"
    let guidanceChunkStartLen = 0;
    let guidanceSilenceTimer = null;
    let guidanceLastChunkTs = 0;

    // ============================
    // MÓDULO: Triagem hospitalar (gravação + guia em tempo real)
    // ============================
    let triageRecognition = null;
    let triageIsRecording = false;
    let triageIsPaused = false;
    let triageFinalTranscript = "";
    let triageInterimTranscript = "";

    let triageStartTime = null;
    let triageAccumulatedSeconds = 0;
    let triageTimerInterval = null;

    // Guia em tempo real da triagem (até 3 itens por vez)
    let triageGuidanceEnabled = false;
    let triageGuidanceStage = "aguardando_motivo";
    let triageGuidancePending = [];
    let triageGuidanceContextLabel = "";
    let triageGuidanceHypothesis = "";
    let triageGuidanceConfidence = 0;

    let triageGuidanceInFlight = false;
    let triageGuidanceAskedQuestion = "";
    let triageGuidanceAskedAtLen = 0;
    let triageGuidanceAskedAtTs = 0;
    let triageGuidanceLastPayloadHash = "";
    let triageGuidanceTurnState = "aguardando_pergunta";
    let triageGuidanceChunkStartLen = 0;
    let triageGuidanceSilenceTimer = null;
    let triageGuidanceLastChunkTs = 0;

const recordBtn = document.getElementById("recordBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const timerEl = document.getElementById("timer");
    const micStatus = document.getElementById("micStatus");
    const resultsCard = document.getElementById("resultsCard");
    const soapError = document.getElementById("soapError");
    const printBtn = document.getElementById("printBtn");

    const triageRecordBtn = document.getElementById("triageRecordBtn");
    const triagePauseBtn = document.getElementById("triagePauseBtn");
    const triageTimerEl = document.getElementById("triageTimer");
    const triageMicStatus = document.getElementById("triageMicStatus");
    const triageError = document.getElementById("triageError");

    const triageLiveGuidance = document.getElementById("triageLiveGuidance");
    const triageLiveGuidanceContext = document.getElementById("triageLiveGuidanceContext");
    const triageLiveGuidanceStatus = document.getElementById("triageLiveGuidanceStatus");
    const triageLiveGuidanceList = document.getElementById("triageLiveGuidanceList");

    const triageReportPanel = document.getElementById("triageReportPanel");
    const triageRiskBadge = document.getElementById("triageRiskBadge");
    const triageRiskMeaning = document.getElementById("triageRiskMeaning");
    const triageRiskLegend = document.getElementById("triageRiskLegend");

    const triageProntuario = document.getElementById("triageProntuario");
    const triagePassagemMedico = document.getElementById("triagePassagemMedico");
    const triageAlertas = document.getElementById("triageAlertas");
    const triageCondutasNaoMed = document.getElementById("triageCondutasNaoMed");
    const triageCondutasMed = document.getElementById("triageCondutasMed");
    const triageMedidasExames = document.getElementById("triageMedidasExames");
    const triagePendencias = document.getElementById("triagePendencias");
    const triageQualidade = document.getElementById("triageQualidade");
    const triageFullReport = document.getElementById("triageFullReport");
    const triageReportStatus = document.getElementById("triageReportStatus");

    const triageCopyFullBtn = document.getElementById("triageCopyFullBtn");
    const triagePrintFullBtn = document.getElementById("triagePrintFullBtn");
    const triageCopyProntuarioBtn = document.getElementById("triageCopyProntuarioBtn");
    const triagePrintProntuarioBtn = document.getElementById("triagePrintProntuarioBtn");
    const triageCopyPassagemBtn = document.getElementById("triageCopyPassagemBtn");
    const triagePrintPassagemBtn = document.getElementById("triagePrintPassagemBtn");

    const liveGuidance = document.getElementById("liveGuidance");
    const liveGuidanceContext = document.getElementById("liveGuidanceContext");
    const liveGuidanceStatus = document.getElementById("liveGuidanceStatus");
    const liveGuidanceList = document.getElementById("liveGuidanceList");

    const soapS = document.getElementById("soapS");
    const soapO = document.getElementById("soapO");
    const soapA = document.getElementById("soapA");
    const soapP = document.getElementById("soapP");

    const prescriptionOutput = document.getElementById("prescriptionOutput");

    const sbarOutput = document.getElementById("sbarOutput");
    const sbarRecordBtn = document.getElementById("sbarRecordBtn");
    const copySbarBtn = document.getElementById("copySbarBtn");
    const printSbarBtn = document.getElementById("printSbarBtn");
    const sbarStatus = document.getElementById("sbarStatus");
    const sbarTimer = document.getElementById("sbarTimer");
    const openSbarGuideBtn = document.getElementById("openSbarGuideBtn");
    const sbarGuidePanel = document.getElementById("sbarGuidePanel");


    const pregnancyBox = document.getElementById("pregnancyBox");
    const lactationBox = document.getElementById("lactationBox");

    const riskTriageBadge = document.getElementById("riskTriageBadge");
    const riskTriageMeaning = document.getElementById("riskTriageMeaning");
    const riskTriageLegend = document.getElementById("riskTriageLegend");
    const copyRiskTriageBtn = document.getElementById("copyRiskTriageBtn");
    const printRiskTriageBtn = document.getElementById("printRiskTriageBtn");
    const riskTriageStatus = document.getElementById("riskTriageStatus");

    const copySaeBtn = document.getElementById("copySaeBtn");
    const classificationsStatus = document.getElementById("classificationsStatus");
    const printPregnancyBtn = document.getElementById("printPregnancyBtn");
    const printLactationBtn = document.getElementById("printLactationBtn");

    const recommendationsBtn = document.getElementById("recommendationsBtn");
    const recommendationsPanel = document.getElementById("recommendationsPanel");
    const closeRecommendationsBtn = document.getElementById("closeRecommendationsBtn");
    const recommendationsStatus = document.getElementById("recommendationsStatus");
    const recommendationsList = document.getElementById("recommendationsList");
    const askQuestionsBtn = document.getElementById("askQuestionsBtn");
    const questionsTimerEl = document.getElementById("questionsTimer");

    const soapCopyButtons = document.querySelectorAll(".copy-soap-btn");
    const copyPrescriptionBtn = document.getElementById("copyPrescriptionBtn");

    const copyFullSoapBtn = document.getElementById("copyFullSoapBtn");
    const printSoapBtn = document.getElementById("printSoapBtn");

    const medicalDoubtInput = document.getElementById("medicalDoubtInput");
    const medicalDoubtStatus = document.getElementById("medicalDoubtStatus");
    const medicalDoubtAnswer = document.getElementById("medicalDoubtAnswer");
    const medicalDoubtSendBtn = document.getElementById("medicalDoubtSendBtn");


    const medPhotoBtn = document.getElementById("medPhotoBtn");
    const medFileBtn = document.getElementById("medFileBtn");
const interactionsBox = document.getElementById("interactionsBox");
    const interactionsStatus = document.getElementById("interactionsStatus");
    const copyMedSafetyBtn = document.getElementById("copyMedSafetyBtn");
    const printMedSafetyBtn = document.getElementById("printMedSafetyBtn");
    const medCameraInput = document.getElementById("medCameraInput");
    const medFileInput = document.getElementById("medFileInput");

    const woundPhotoBtn = document.getElementById("woundPhotoBtn");
    const woundFileBtn = document.getElementById("woundFileBtn");
const presentationsMaxDoseBox = document.getElementById("presentationsMaxDoseBox");
    const presentationsMaxDoseStatus = document.getElementById("presentationsMaxDoseStatus");
    const copyWoundBtn = document.getElementById("copyWoundBtn");
    const printWoundBtn = document.getElementById("printWoundBtn");
    const woundCameraInput = document.getElementById("woundCameraInput");
    const woundFileInput = document.getElementById("woundFileInput");

        const examInterpretationBox = document.getElementById("examInterpretationBox");
    const examInterpretationStatus = document.getElementById("examInterpretationStatus");
    const copyExamBtn = document.getElementById("copyExamBtn");
    const printExamBtn = document.getElementById("printExamBtn");
    const examCameraInput = document.getElementById("examCameraInput");
    const examFileInput = document.getElementById("examFileInput");

const imageChoiceOverlay = document.getElementById("imageChoiceOverlay");
    const chooseCameraBtn = document.getElementById("chooseCameraBtn");
    const chooseFileBtn = document.getElementById("chooseFileBtn");
    const cancelImageChoiceBtn = document.getElementById("cancelImageChoiceBtn");

    const runImageAnalysisBtn = document.getElementById("runImageAnalysisBtn");
    const clearChosenImagesBtn = document.getElementById("clearChosenImagesBtn");
    const imageChoicePreview = document.getElementById("imageChoicePreview");
    const imageChoiceCount = document.getElementById("imageChoiceCount");
    const imageChoiceTitle = document.getElementById("imageChoiceTitle");
    const imageChoiceHint = document.getElementById("imageChoiceHint");

    let pendingCameraInput = null;
    let pendingFileInput = null;

    let pendingImages = [];
    let pendingAnalysisFn = null;
    let pendingOverlayTitle = "";
    let pendingOverlayHint = "";

    // ============================
    // VISIBILIDADE – botões de copiar/imprimir (foto/áudio)
    // ============================
    function setVisible(el, visible) {
      if (!el) return;
      if (visible) el.classList.remove("hidden");
      else el.classList.add("hidden");
    }

    function isMeaningfulText(t) {
      const s = String(t || "").trim();
      if (!s) return false;
      const low = s.toLowerCase();
      if (low === "nenhum conteúdo disponível." || low === "nenhum conteudo disponivel.") return false;
      if (low === "processando." || low === "processando") return false;
      return true;
    }

    function updateMedSafetyActions() {
      const has = isMeaningfulText(interactionsBox ? interactionsBox.textContent : "");
      setVisible(copyMedSafetyBtn, has);
      setVisible(printMedSafetyBtn, has);
    }

    function updateWoundActions() {
      const has = isMeaningfulText(presentationsMaxDoseBox ? presentationsMaxDoseBox.textContent : "");
      setVisible(copyWoundBtn, has);
      setVisible(printWoundBtn, has);
    }

    function updateExamActions() {
      const has = isMeaningfulText(examInterpretationBox ? examInterpretationBox.textContent : "");
      setVisible(copyExamBtn, has);
      setVisible(printExamBtn, has);
    }

    function updateReportActions() {
      const has = isMeaningfulText(reportOutput ? reportOutput.value : "");
      setVisible(copyReportBtn, has);
      setVisible(printReportBtn, has);
    }




    // ============================
    // MÓDULO: Coletar dados essenciais (NOVO)
    // ============================
    const patientInfoBtn = document.getElementById("patientInfoBtn");
    const patientInfoTimerEl = document.getElementById("patientInfoTimer");
    const patientInfoStatus = document.getElementById("patientInfoStatus");
    const patientInfoSummary = document.getElementById("patientInfoSummary");

    let patientContext = { nome: null, idade: null, peso_kg: null };

    let patientInfoRecognition = null;
    let patientInfoIsRecording = false;
    let patientInfoFinalTranscript = "";
    let patientInfoTimerInterval = null;
    let patientInfoStartTime = null;
    let patientInfoAccumulatedSeconds = 0;

    function resetPatientInfoTimer() {
      patientInfoAccumulatedSeconds = 0;
      patientInfoStartTime = null;
      if (patientInfoTimerInterval) clearInterval(patientInfoTimerInterval);
      patientInfoTimerInterval = null;
      if (patientInfoTimerEl) patientInfoTimerEl.textContent = "00:00";
    }

    function updatePatientInfoTimer() {
      const now = Date.now();
      const seconds = patientInfoAccumulatedSeconds + Math.floor((now - patientInfoStartTime) / 1000);
      const m = ("0" + Math.floor(seconds / 60)).slice(-2);
      const s = ("0" + (seconds % 60)).slice(-2);
      if (patientInfoTimerEl) patientInfoTimerEl.textContent = `${m}:${s}`;
    }

    function startPatientInfoTimer() {
      patientInfoStartTime = Date.now();
      if (patientInfoTimerInterval) clearInterval(patientInfoTimerInterval);
      patientInfoTimerInterval = setInterval(updatePatientInfoTimer, 200);
    }

    function stopPatientInfoTimer() {
      if (!patientInfoStartTime) return;
      const now = Date.now();
      patientInfoAccumulatedSeconds += Math.floor((now - patientInfoStartTime) / 1000);
      patientInfoStartTime = null;
      if (patientInfoTimerInterval) clearInterval(patientInfoTimerInterval);
      patientInfoTimerInterval = null;
    }

    function formatPatientSummary(ctx) {
      const parts = [];
      if (ctx?.nome) parts.push(`Nome: ${ctx.nome}`);
      if (ctx?.idade) parts.push(`Idade: ${ctx.idade}`);
      if (ctx?.peso_kg !== null && ctx?.peso_kg !== undefined) parts.push(`Peso: ${ctx.peso_kg} kg`);
      return parts.length ? parts.join(" | ") : "";
    }

    function buildTranscriptWithPatientContext(rawTranscript) {
      let t = String(rawTranscript || "").trim();
      if (!t) return "";

      t = t.replace(/^Dados do paciente:[\s\S]*?\n{2,}/i, "").trim();

      const hasAny = !!(patientContext?.nome || patientContext?.idade || (patientContext?.peso_kg !== null && patientContext?.peso_kg !== undefined));
      if (!hasAny) return t;

      const headerParts = [];
      if (patientContext.nome) headerParts.push(`Nome completo: ${patientContext.nome}.`);
      if (patientContext.idade) headerParts.push(`Idade: ${patientContext.idade}.`);
      if (patientContext.peso_kg !== null && patientContext.peso_kg !== undefined) headerParts.push(`Peso: ${patientContext.peso_kg} kg.`);

      const header = `Dados do paciente: ${headerParts.join(" ")}\n\n`;
      return header + t;
    }

    function initPatientInfoSpeech() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) return false;

      patientInfoRecognition = new SR();
      patientInfoRecognition.lang = "pt-BR";
      patientInfoRecognition.continuous = true;
      patientInfoRecognition.interimResults = true;

      patientInfoRecognition.onresult = (event) => {
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const txt = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            patientInfoFinalTranscript += txt + " ";
          }
        }
      };

      patientInfoRecognition.onerror = (e) => {
        console.warn("Erro no reconhecimento (dados do paciente):", e);
      };

      return true;
    }

    
    function getNursingContext() {
      const t = (baseTranscriptRaw || baseTranscript || finalTranscript || "").trim();
      const s = (soapS?.value || "").trim();
      const o = (soapO?.value || "").trim();
      const a = (soapA?.value || "").trim();
      const p = (soapP?.value || "").trim();
      const plano = (prescriptionOutput?.value || "").trim();
      const sbar = (sbarOutput?.value || "").trim();
      const parts = [];
      if (t) parts.push("TRANSCRIÇÃO:\n" + t);
      if (s || o || a || p) parts.push("EVOLUÇÃO (SOAP):\nS: " + s + "\nO: " + o + "\nA: " + a + "\nP: " + p);
      if (plano) parts.push("PLANO DE CUIDADOS:\n" + plano);
      if (sbar) parts.push("SBAR:\n" + sbar);
      return parts.join("\n\n").trim();
    }

    // ============================
    // MÓDULO: Classificação de risco por cores (NOVO)
    // ============================
    const RISK_LEGEND_DEFAULT = [
      { cor: "Vermelho", significado: "Emergência. Atendimento imediato." },
      { cor: "Laranja", significado: "Muito urgente. Prioridade alta de atendimento." },
      { cor: "Amarelo", significado: "Urgente. Necessita avaliação em curto prazo." },
      { cor: "Verde", significado: "Pouco urgente. Pode aguardar com segurança, mantendo reavaliação se piora." },
      { cor: "Azul", significado: "Não urgente. Caso de baixa gravidade, orientar e agendar conforme necessidade." }
    ];

    function normalizeRiskColorLabel(label) {
      const t = String(label || "").trim().toLowerCase();
      if (!t) return "Não informado";
      if (t.includes("vermelh")) return "Vermelho";
      if (t.includes("laranj")) return "Laranja";
      if (t.includes("amarel")) return "Amarelo";
      if (t.includes("verd")) return "Verde";
      if (t.includes("azul")) return "Azul";
      if (t.includes("nao informado") || t.includes("não informado") || t.includes("indefin")) return "Não informado";
      return label.trim();
    }

    function applyRiskBadgeColor(cor) {
      if (!riskTriageBadge) return;
      riskTriageBadge.classList.remove("risk-none", "risk-vermelho", "risk-laranja", "risk-amarelo", "risk-verde", "risk-azul");
      const c = normalizeRiskColorLabel(cor);
      if (c === "Vermelho") riskTriageBadge.classList.add("risk-vermelho");
      else if (c === "Laranja") riskTriageBadge.classList.add("risk-laranja");
      else if (c === "Amarelo") riskTriageBadge.classList.add("risk-amarelo");
      else if (c === "Verde") riskTriageBadge.classList.add("risk-verde");
      else if (c === "Azul") riskTriageBadge.classList.add("risk-azul");
      else riskTriageBadge.classList.add("risk-none");
    }

    function renderRiskLegend(legendArr) {
      if (!riskTriageLegend) return;
      const legend = Array.isArray(legendArr) && legendArr.length ? legendArr : RISK_LEGEND_DEFAULT;

      riskTriageLegend.innerHTML = "";
      legend.forEach((item) => {
        const cor = normalizeRiskColorLabel(item?.cor || "");
        const significado = String(item?.significado || "").trim();

        const row = document.createElement("div");
        row.className = "risk-legend-row";

        const swatch = document.createElement("div");
        swatch.className = "risk-legend-swatch " + (
          cor === "Vermelho" ? "swatch-vermelho" :
          cor === "Laranja" ? "swatch-laranja" :
          cor === "Amarelo" ? "swatch-amarelo" :
          cor === "Verde" ? "swatch-verde" :
          cor === "Azul" ? "swatch-azul" : ""
        );

        const txt = document.createElement("div");
        txt.style.flex = "1";
        txt.textContent = cor + (significado ? (": " + significado) : "");

        row.appendChild(swatch);
        row.appendChild(txt);
        riskTriageLegend.appendChild(row);
      });
    }

    function buildRiskPrintText(cor, significado, legendArr) {
      const c = normalizeRiskColorLabel(cor);
      const s = String(significado || "").trim();
      const legend = Array.isArray(legendArr) && legendArr.length ? legendArr : RISK_LEGEND_DEFAULT;

      const lines = [];
      lines.push("Classificação de risco: " + c);
      if (s) lines.push("Significado: " + s);
      lines.push("");
      lines.push("Legenda:");
      legend.forEach((it) => {
        const lc = normalizeRiskColorLabel(it?.cor || "");
        const ls = String(it?.significado || "").trim();
        lines.push(lc + ": " + ls);
      });
      return lines.join("\n");
    }

    async function updateRiskTriage() {
      if (!riskTriageStatus) return;

      const contexto = getNursingContext();
      if (!contexto) {
        if (riskTriageBadge) {
          riskTriageBadge.textContent = "Não informado";
          applyRiskBadgeColor("Não informado");
        }
        if (riskTriageMeaning) riskTriageMeaning.textContent = "Nenhum conteúdo disponível.";
        renderRiskLegend(RISK_LEGEND_DEFAULT);
        riskTriageStatus.textContent = "Sem conteúdo suficiente para classificar.";
        return;
      }

      riskTriageStatus.textContent = "Gerando classificação de risco...";
      riskTriageStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/classificacao-risco", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ contexto })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (classificação de risco):", resp.status, txt);
          riskTriageStatus.classList.remove("loading-dot");
          riskTriageStatus.textContent = "Não foi possível gerar a classificação de risco.";
          return;
        }

        const data = await resp.json();

        const cor = normalizeRiskColorLabel(data?.cor || "Não informado");
        const significado = String(data?.significado || "").trim();
        const legenda = Array.isArray(data?.legenda) ? data.legenda : RISK_LEGEND_DEFAULT;

        if (riskTriageBadge) {
          riskTriageBadge.textContent = cor;
          applyRiskBadgeColor(cor);
        }
        if (riskTriageMeaning) {
          riskTriageMeaning.textContent = significado ? significado : "Sem significado disponível.";
        }
        renderRiskLegend(legenda);

        // Guarda texto para impressão
        riskTriageMeaning.dataset.printText = buildRiskPrintText(cor, significado, legenda);

        riskTriageStatus.classList.remove("loading-dot");
        riskTriageStatus.textContent = "Classificação atualizada.";
      } catch (e) {
        console.error(e);
        riskTriageStatus.classList.remove("loading-dot");
        riskTriageStatus.textContent = "Falha de rede ou backend ao gerar a classificação de risco.";
      }
    }


async function generateSoapAndPrescriptionFromTranscript(transcricao, statusText) {
      const t = String(transcricao || "").trim();
      if (!t) return;

      soapError.textContent = "";
      micStatus.innerText = statusText || "Atualizando SOAP e prescrição...";
      micStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/gerar-soap", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao: t })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend:", resp.status, txt);
          soapError.textContent = "Erro ao gerar evolução/plano de cuidados. Verifique o backend e tente novamente.";
          micStatus.innerText = "Falha ao gerar o resumo.";
          micStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const soap = data.soap || "";
        const prescricao = data.prescricao || "";

        updateSoapFromString(soap);
        prescriptionOutput.value = normalizeNumberedParagraphs(prescricao);
        printBtn.style.display = prescricao ? "inline-block" : "none";

        micStatus.innerText = "Atualização concluída.";
        micStatus.classList.remove("loading-dot");

        await updateClassifications();
        await updateRiskTriage();
        } catch (e) {
        console.error(e);
        soapError.textContent = "Erro ao gerar evolução e plano de cuidados (falha de rede ou backend).";
        micStatus.innerText = "Falha ao gerar o resumo.";
        micStatus.classList.remove("loading-dot");
      }
    }

    async function applyPatientContextAndRefreshAll() {
      const rawCandidate = (baseTranscriptRaw || "").trim() || (finalTranscript || "").trim() || (baseTranscript || "").trim();
      if (!rawCandidate) {
        patientInfoStatus.textContent = "Não há transcrição da consulta para atualizar.";
        return;
      }

      const cleanedRaw = rawCandidate.replace(/^Dados do paciente:[\s\S]*?\n{2,}/i, "").trim();
      baseTranscriptRaw = cleanedRaw;

      const transcricaoAtualizada = buildTranscriptWithPatientContext(cleanedRaw);
      baseTranscript = transcricaoAtualizada;

      await generateSoapAndPrescriptionFromTranscript(transcricaoAtualizada, "Atualizando SOAP e prescrição com nome/idade/peso...");
}

    async function startPatientInfoRecording() {
      if (!patientInfoBtn) return;

      patientInfoStatus.textContent = "Gravando... Dite nome completo, idade e peso.";
      patientInfoStatus.classList.add("loading-dot");
      patientInfoBtn.textContent = "Finalizar nome/idade/peso";

      patientInfoFinalTranscript = "";
      resetPatientInfoTimer();
      startPatientInfoTimer();

      try { if (recognition) recognition.stop(); } catch (e) {}
      try { if (questionsRecognition) questionsRecognition.stop(); } catch (e) {}
      try { if (reportRecognition) reportRecognition.stop(); } catch (e) {}

      if (!patientInfoRecognition) {
        const ok = initPatientInfoSpeech();
        if (!ok) {
          patientInfoStatus.classList.remove("loading-dot");
          patientInfoStatus.textContent = "Navegador sem suporte a reconhecimento de voz.";
          patientInfoBtn.textContent = "Coletar dados essenciais";
          stopPatientInfoTimer();
          return;
        }
      }

      patientInfoIsRecording = true;
      try {
        patientInfoRecognition.start();
      } catch (e) {
        console.warn("Erro ao iniciar reconhecimento (dados do paciente):", e);
      }
    }

    async function stopPatientInfoRecordingAndApply() {
      patientInfoIsRecording = false;
      stopPatientInfoTimer();

      patientInfoBtn.textContent = "Coletar dados essenciais";

      if (patientInfoRecognition) {
        try { patientInfoRecognition.stop(); } catch (e) {}
      }

      const transcricaoCurta = patientInfoFinalTranscript.trim();
      if (!transcricaoCurta) {
        patientInfoStatus.classList.remove("loading-dot");
        patientInfoStatus.textContent = "Nenhuma fala foi capturada.";
        return;
      }

      patientInfoStatus.textContent = "Processando nome/idade/peso...";
      patientInfoStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/extrair-dados-paciente", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao: transcricaoCurta })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (dados do paciente):", resp.status, txt);
          patientInfoStatus.classList.remove("loading-dot");
          patientInfoStatus.textContent = "Não foi possível extrair os dados do paciente.";
          return;
        }

        const data = await resp.json();
        patientContext = {
          nome: (data?.nome || null),
          idade: (data?.idade || null),
          peso_kg: (typeof data?.peso_kg === "number" && Number.isFinite(data.peso_kg)) ? data.peso_kg : null
        };

        const resumo = formatPatientSummary(patientContext);
        patientInfoSummary.textContent = resumo ? resumo : "Dados do paciente não identificados com segurança.";
        patientInfoStatus.classList.remove("loading-dot");
        patientInfoStatus.textContent = resumo ? "Dados do paciente atualizados." : "Sem dados suficientes para atualizar.";

        await applyPatientContextAndRefreshAll();
      } catch (e) {
        console.error(e);
        patientInfoStatus.classList.remove("loading-dot");
        patientInfoStatus.textContent = "Falha de rede ou backend ao extrair dados do paciente.";
      }
    }

    if (patientInfoBtn) {
      patientInfoBtn.addEventListener("click", async () => {
        if (patientInfoIsRecording) {
          await stopPatientInfoRecordingAndApply();
        } else {
          await startPatientInfoRecording();
        }
      });
    }

    const reportRecordBtn = document.getElementById("reportRecordBtn");
    const reportStatus = document.getElementById("reportStatus");
    const reportOutput = document.getElementById("reportOutput");
    const reportDocTypeSelect = document.getElementById("reportDocTypeSelect");
    const reportDocTypeDetected = document.getElementById("reportDocTypeDetected");
    const reportMissingFields = document.getElementById("reportMissingFields");
    const copyReportBtn = document.getElementById("copyReportBtn");
    const printReportBtn = document.getElementById("printReportBtn");

    let reportRecognition = null;
    let reportIsRecording = false;
    let reportIsPaused = false;
    let reportFinalTranscript = "";

    // Rodada adicional de perguntas (aba lateral)
    let questionsRecognition = null;
    let questionsIsRecording = false;
    let questionsFinalTranscript = "";
    let questionsTimerInterval = null;
    let questionsStartTime = null;
    let questionsAccumulatedSeconds = 0;

    function escapeHtml(text) {
      return String(text || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }

    function normalizeNumberedParagraphs(text) {
      let t = String(text || "");
      t = t.replace(/\r/g, "");
      // Garante que cada item numerado comece em uma nova linha (melhora leitura no S.U.I.S.)
      t = t.replace(/([^\n])\s+(\d+)\s*([\.)])\s+/g, "$1\n$2$3 ");
      t = t.replace(/([^\n])\s+(\d+)\s*[-–—]\s+/g, "$1\n$2 - ");
      t = t.replace(/\n{3,}/g, "\n\n");
      return t.trim();
    }


    // ============================
    // ============================
    // Perguntas e procedimentos essenciais em tempo real (FLUXO CONTROLADO)
    // ============================
    function renderLiveGuidance() {
      if (!liveGuidance || !liveGuidanceList || !liveGuidanceStatus || !liveGuidanceContext) return;

      if (!isRecording) {
        liveGuidanceContext.textContent = "";
        liveGuidanceStatus.textContent = "Inicie o atendimento para receber perguntas e procedimentos necessários em tempo real.";
        liveGuidanceList.innerHTML = "<div class=\"live-guidance-empty\">Nenhuma sugestão por enquanto.</div>";
        return;
      }

      const ctx = (guidanceContextLabel || "").trim();
      liveGuidanceContext.textContent = ctx ? ("Atendimento: " + ctx) : "";

      if (guidanceStage === "aguardando_motivo") {
        liveGuidanceStatus.textContent = "Aguardando o motivo da consulta. Após o paciente informar o motivo, as perguntas essenciais serão sugeridas.";
        liveGuidanceList.innerHTML = `
          <div class="live-guidance-empty">
            Oriente: acolha e pergunte o motivo da consulta. Após a resposta do paciente, as perguntas essenciais serão sugeridas automaticamente.
            <div style="margin-top:10px;">
              <button id="forceStartGuidanceBtn" class="mini-red-btn" style="background:#b00020;">Motivo já foi informado</button>
            </div>
          </div>
        `;
        const btn = document.getElementById("forceStartGuidanceBtn");
        if (btn) {
          btn.onclick = () => {
            if (guidanceStage !== "aguardando_motivo") return;
            guidanceStage = "perguntas";
            // reinicia detecção de turnos a partir do ponto atual
            guidanceTurnState = "aguardando_pergunta";
            guidanceAskedQuestion = "";
            guidanceAskedAtLen = getCombinedTranscript().length;
            guidanceAskedAtTs = Date.now();
            guidanceChunkStartLen = getCombinedTranscript().length;
            requestGuidanceFromBackend({ evento: "inicial" });
          };
        }
        return;
      }

      // estágio perguntas (controle por turnos: pergunta -> resposta -> atualizar)
      const confTxt = (typeof guidanceConfidence === "number" && guidanceConfidence > 0)
        ? ("Nível de confiança da hipótese principal: " + Math.round(guidanceConfidence) + "% (não chega a 100%).")
        : "";

      const hypo = (guidanceHypothesis || "").trim();
      const hypoTxt = hypo ? ("Hipótese principal: " + hypo + ". " + confTxt) : confTxt;

      if (guidanceTurnState === "aguardando_resposta") {
        liveGuidanceStatus.textContent = "Pergunta em andamento. Aguardando resposta do paciente para atualizar as próximas perguntas...";
      } else if (guidanceInFlight) {
        liveGuidanceStatus.textContent = "Atualizando perguntas essenciais...";
      } else {
        liveGuidanceStatus.textContent = hypoTxt || "Perguntas essenciais sugeridas. Faça uma das perguntas e aguarde a resposta do paciente.";
      }

      if (!guidancePending || !guidancePending.length) {
        liveGuidanceList.innerHTML = "<div class=\"live-guidance-empty\">Nenhuma pergunta essencial no momento.</div>";
        return;
      }

      liveGuidanceList.innerHTML = "";
      guidancePending.slice(0, 3).forEach((q, idx) => {
        const safeQ = escapeHtml(String(q || ""));
        const askedMark = (guidanceAskedQuestion && guidanceAskedQuestion.toLowerCase() === String(q || "").toLowerCase())
          ? " (pergunta feita)"
          : "";
        const el = document.createElement("div");
        el.className = "live-guidance-item";
        el.innerHTML = `<div class="live-guidance-item-text">${idx + 1}. ${safeQ}${askedMark}</div>`;
        liveGuidanceList.appendChild(el);
      });
    }

    function getCombinedTranscript() {
      const combined = ((finalTranscript || "") + " " + (interimTranscript || "")).trim();
      if (!combined) return "";
      const MAX = 8000;
      return combined.length > MAX ? combined.slice(combined.length - MAX) : combined;
    }

    function hashForGuidancePayload(obj) {
      try {
        const raw = JSON.stringify(obj || {});
        let h = 0;
        for (let i = 0; i < raw.length; i++) {
          h = ((h << 5) - h) + raw.charCodeAt(i);
          h |= 0;
        }
        return String(h);
      } catch {
        return String(Date.now());
      }
    }

    function resetLiveGuidanceState() {
      guidanceEnabled = true;
      guidanceStage = "aguardando_motivo";
      guidancePending = [];
      guidanceContextLabel = "";
      guidanceHypothesis = "";
      guidanceConfidence = 0;

      guidanceInFlight = false;

      guidanceTurnState = "aguardando_pergunta";
      guidanceAskedQuestion = "";
      guidanceAskedAtLen = 0;
      guidanceAskedAtTs = 0;

      guidanceChunkStartLen = 0;
      guidanceSilenceTimer && clearTimeout(guidanceSilenceTimer);
      guidanceSilenceTimer = null;

      guidanceLastPayloadHash = "";
      guidanceLastChunkTs = 0;

      renderLiveGuidance();
    }

    function startGuidanceLoop() {
      // Sem polling: só reage a eventos (inicial após motivo e após cada resposta)
      guidanceEnabled = true;
      renderLiveGuidance();
      maybeStartInitialGuidance(false);
    }

    function stopGuidanceLoop() {
      guidanceEnabled = false;
      guidanceInFlight = false;
      guidanceTurnState = "aguardando_pergunta";
      guidanceAskedQuestion = "";
      guidanceSilenceTimer && clearTimeout(guidanceSilenceTimer);
      guidanceSilenceTimer = null;
      renderLiveGuidance();
    }

    function triageRenderLiveGuidance() {
      if (!triageLiveGuidance || !triageLiveGuidanceStatus || !triageLiveGuidanceList || !triageLiveGuidanceContext) return;

      if (!triageGuidanceEnabled || !triageIsRecording) {
        triageLiveGuidanceContext.textContent = "";
        triageLiveGuidanceStatus.textContent = "Inicie a triagem para receber perguntas e procedimentos necessários em tempo real.";
        triageLiveGuidanceList.innerHTML = "<div class=\"live-guidance-empty\">Nenhuma sugestão por enquanto.</div>";
        return;
      }

      const ctx = (triageGuidanceContextLabel || "").trim();
      triageLiveGuidanceContext.textContent = ctx ? ("Triagem: " + ctx) : "";

      if (triageGuidanceStage === "aguardando_motivo") {
        triageLiveGuidanceStatus.textContent = "Aguardando a queixa principal. Após o paciente informar o motivo, serão sugeridas perguntas e procedimentos essenciais para classificar risco e iniciar condutas.";
        triageLiveGuidanceList.innerHTML = `
          <div class="live-guidance-empty">
            Oriente: acolha e registre a queixa principal. Em seguida, descreva sinais vitais e achados do ABCDE.
            <div style="margin-top:10px;">
              <button id="triageForceStartGuidanceBtn" class="mini-red-btn" style="background:#b00020;">Queixa já foi informada</button>
            </div>
          </div>
        `;
        const btn = document.getElementById("triageForceStartGuidanceBtn");
        if (btn) {
          btn.onclick = () => {
            if (triageGuidanceStage !== "aguardando_motivo") return;
            triageGuidanceStage = "perguntas";
            triageGuidanceTurnState = "aguardando_pergunta";
            triageGuidanceAskedQuestion = "";
            triageGuidanceAskedAtLen = triageGetCombinedTranscript().length;
            triageGuidanceAskedAtTs = Date.now();
            triageGuidanceChunkStartLen = triageGetCombinedTranscript().length;
            triageRequestGuidanceFromBackend({ evento: "inicial" });
          };
        }
        return;
      }

      const confTxt = (typeof triageGuidanceConfidence === "number" && triageGuidanceConfidence > 0)
        ? ("Nível de confiança do cenário principal: " + Math.round(triageGuidanceConfidence) + "% (não chega a 100%).")
        : "";

      const hypo = (triageGuidanceHypothesis || "").trim();
      const hypoTxt = hypo ? ("Cenário principal: " + hypo + ". " + confTxt) : confTxt;

      if (triageGuidanceTurnState === "aguardando_resposta") {
        triageLiveGuidanceStatus.textContent = "Item em andamento. Aguardando informação do paciente para atualizar os próximos itens...";
      } else if (triageGuidanceInFlight) {
        triageLiveGuidanceStatus.textContent = "Atualizando itens essenciais da triagem...";
      } else {
        triageLiveGuidanceStatus.textContent = hypoTxt || "Itens essenciais sugeridos. Execute um item e aguarde a resposta para atualizar.";
      }

      if (!triageGuidancePending || !triageGuidancePending.length) {
        triageLiveGuidanceList.innerHTML = "<div class=\"live-guidance-empty\">Nenhum item essencial no momento.</div>";
        return;
      }

      triageLiveGuidanceList.innerHTML = "";
      triageGuidancePending.slice(0, 3).forEach((q, idx) => {
        const safeQ = escapeHtml(String(q || ""));
        const askedMark = (triageGuidanceAskedQuestion && triageGuidanceAskedQuestion.toLowerCase() === String(q || "").toLowerCase())
          ? " (item executado)"
          : "";
        const el = document.createElement("div");
        el.className = "live-guidance-item";
        el.innerHTML = `<div class="live-guidance-item-text">${idx + 1}. ${safeQ}${askedMark}</div>`;
        triageLiveGuidanceList.appendChild(el);
      });
    }

    function triageGetCombinedTranscript() {
      const combined = ((triageFinalTranscript || "") + " " + (triageInterimTranscript || "")).trim();
      if (!combined) return "";
      const MAX = 8000;
      return combined.length > MAX ? combined.slice(combined.length - MAX) : combined;
    }

    function triageResetLiveGuidanceState() {
      triageGuidanceEnabled = true;
      triageGuidanceStage = "aguardando_motivo";
      triageGuidancePending = [];
      triageGuidanceContextLabel = "";
      triageGuidanceHypothesis = "";
      triageGuidanceConfidence = 0;

      triageGuidanceInFlight = false;

      triageGuidanceTurnState = "aguardando_pergunta";
      triageGuidanceAskedQuestion = "";
      triageGuidanceAskedAtLen = 0;
      triageGuidanceAskedAtTs = 0;

      triageGuidanceChunkStartLen = 0;
      triageGuidanceSilenceTimer && clearTimeout(triageGuidanceSilenceTimer);
      triageGuidanceSilenceTimer = null;

      triageGuidanceLastPayloadHash = "";
      triageGuidanceLastChunkTs = 0;

      triageRenderLiveGuidance();
    }

    function triageStartGuidanceLoop() {
      triageGuidanceEnabled = true;
      triageRenderLiveGuidance();
      triageMaybeStartInitialGuidance(false);
    }

    function triageStopGuidanceLoop() {
      triageGuidanceEnabled = false;
      triageGuidanceInFlight = false;
      triageGuidanceTurnState = "aguardando_pergunta";
      triageGuidanceAskedQuestion = "";
      triageGuidanceSilenceTimer && clearTimeout(triageGuidanceSilenceTimer);
      triageGuidanceSilenceTimer = null;
      triageRenderLiveGuidance();
    }

    function triageMaybeStartInitialGuidance(force) {
      if (!triageGuidanceEnabled || !triageIsRecording || triageIsPaused) return;
      if (triageGuidanceStage !== "aguardando_motivo") return;

      const combined = triageGetCombinedTranscript();
      if (!combined || combined.length < 120) return;

      if (!force && !hasLikelyChiefComplaint(combined)) return;

      triageGuidanceStage = "perguntas";
      triageGuidanceTurnState = "aguardando_pergunta";
      triageGuidanceAskedQuestion = "";
      triageGuidanceAskedAtLen = combined.length;
      triageGuidanceAskedAtTs = Date.now();
      triageGuidanceChunkStartLen = combined.length;

      triageRequestGuidanceFromBackend({ evento: "inicial" });
    }

    function triageOnTranscriptUpdateForGuidance() {
      if (!triageGuidanceEnabled || !triageIsRecording || triageIsPaused) return;

      if (triageGuidanceStage === "aguardando_motivo") {
        triageMaybeStartInitialGuidance(false);
        return;
      }

      triageScheduleGuidanceSilenceFinalize();
    }

    function triageScheduleGuidanceSilenceFinalize() {
      if (!triageGuidanceEnabled || !triageIsRecording || triageIsPaused) return;

      if (triageGuidanceSilenceTimer) clearTimeout(triageGuidanceSilenceTimer);
      triageGuidanceSilenceTimer = setTimeout(() => {
        triageFinalizeGuidanceChunk();
      }, 1400);
    }

    function triageFinalizeGuidanceChunk() {
      if (!triageGuidanceEnabled || !triageIsRecording || triageIsPaused) return;

      const combined = triageGetCombinedTranscript();
      if (!combined) return;

      if (triageGuidanceChunkStartLen <= 0) {
        triageGuidanceChunkStartLen = combined.length;
        return;
      }

      const chunk = combined.slice(triageGuidanceChunkStartLen).trim();
      triageGuidanceChunkStartLen = combined.length;

      if (!chunk || chunk.length < 10) return;

      const now = Date.now();
      if (triageGuidanceLastChunkTs && (now - triageGuidanceLastChunkTs) < 900) return;
      triageGuidanceLastChunkTs = now;

      triageHandleGuidanceUtteranceChunk(chunk);
    }

    function triageHandleGuidanceUtteranceChunk(chunkText) {
      if (!chunkText) return;
      if (!triageGuidancePending || !triageGuidancePending.length) return;
      if (triageGuidanceInFlight) return;

      if (triageGuidanceTurnState === "aguardando_pergunta") {
        const matched = matchQuestionFromUtterance(chunkText, triageGuidancePending);

        triageGuidanceAskedQuestion = matched ? matched : "";
        triageGuidanceAskedAtTs = Date.now();
        triageGuidanceAskedAtLen = triageGetCombinedTranscript().length;

        triageGuidanceTurnState = "aguardando_resposta";
        triageRenderLiveGuidance();
        return;
      }

      if (triageGuidanceTurnState === "aguardando_resposta") {
        const dt = Date.now() - (triageGuidanceAskedAtTs || 0);
        if (dt < 900) return;

        triageRequestGuidanceFromBackend({ evento: "resposta", ultima_fala: chunkText });
        return;
      }
    }

    async function triageRequestGuidanceFromBackend({ evento, ultima_fala }) {
      if (triageGuidanceInFlight) return;
      if (!triageGuidanceEnabled || !triageIsRecording || triageIsPaused) return;

      const combined = triageGetCombinedTranscript();
      if (!combined || combined.length < 50) {
        triageRenderLiveGuidance();
        return;
      }

      const payload = {
        modo: "triagem_hospitalar",
        transcricao: combined,
        estado: triageGuidanceStage,
        evento: evento || "stream",
        pergunta_feita: triageGuidanceAskedQuestion || "",
        perguntas_pendentes: Array.isArray(triageGuidancePending) ? triageGuidancePending.slice(0, 3) : [],
        confianca_atual: typeof triageGuidanceConfidence === "number" ? triageGuidanceConfidence : 0,
        hipotese_atual: triageGuidanceHypothesis || "",
        ultima_fala: typeof ultima_fala === "string" ? ultima_fala.slice(0, 800) : ""
      };

      const h = hashForGuidancePayload(payload);
      if (h === triageGuidanceLastPayloadHash && evento !== "inicial" && evento !== "resposta") return;
      triageGuidanceLastPayloadHash = h;

      triageGuidanceInFlight = true;
      triageRenderLiveGuidance();

      try {
        const resp = await fetch(BACKEND_URL + "/api/guia-tempo-real", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        if (!resp.ok) {
          const txt = await resp.text();
          console.error("Erro HTTP do backend (guia triagem):", resp.status, txt);
          return;
        }

        const data = await resp.json();
        triageGuidanceContextLabel = data.contexto || triageGuidanceContextLabel || "";
        triageGuidanceHypothesis = data.hipotese_principal || triageGuidanceHypothesis || "";
        if (typeof data.confianca === "number") triageGuidanceConfidence = data.confianca;

        const itens = Array.isArray(data.perguntas) ? data.perguntas : (Array.isArray(data.itens) ? data.itens : []);
        const normalized = itens.map(x => String(x || "").trim()).filter(Boolean);

        triageGuidancePending = normalized.slice(0, 3);

        if (evento === "resposta" || evento === "inicial") {
          triageGuidanceTurnState = "aguardando_pergunta";
          triageGuidanceAskedQuestion = "";
          triageGuidanceAskedAtLen = combined.length;
          triageGuidanceAskedAtTs = Date.now();
          triageGuidanceChunkStartLen = combined.length;
        }
      } catch (err) {
        console.error("Falha ao buscar guia triagem:", err);
      } finally {
        triageGuidanceInFlight = false;
        triageRenderLiveGuidance();
      }
    }

    function initTriageSpeech() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        if (triageMicStatus) triageMicStatus.innerText = "Seu navegador não suporta reconhecimento de voz. Use Google Chrome em um computador.";
        return;
      }
      triageRecognition = new SR();
      triageRecognition.lang = "pt-BR";
      triageRecognition.continuous = true;
      triageRecognition.interimResults = true;

      triageRecognition.onresult = (event) => {
        let interim = "";
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            triageFinalTranscript += transcript + " ";
          } else {
            interim += transcript;
          }
        }
        triageInterimTranscript = interim.trim();
        triageOnTranscriptUpdateForGuidance();
      };

      triageRecognition.onerror = (event) => {
        console.error("Erro no reconhecimento de voz (triagem):", event.error);
        if (triageMicStatus) {
          if (event.error === "not-allowed" || event.error === "service-not-allowed") {
            triageMicStatus.innerText = "Permita o acesso ao microfone nas configurações do navegador e tente novamente.";
          } else {
            triageMicStatus.innerText = "Ocorreu um erro no reconhecimento de voz. Tente novamente.";
          }
        }
      };

      triageRecognition.onend = () => {
        if (triageIsRecording && !triageIsPaused) {
          try { triageRecognition.start(); } catch (err) {}
        }
      };
    }

    function triageUpdateTimer() {
      const now = Date.now();
      const seconds = triageAccumulatedSeconds + Math.floor((now - triageStartTime) / 1000);
      const m = ("0" + Math.floor(seconds / 60)).slice(-2);
      const s = ("0" + (seconds % 60)).slice(-2);
      if (triageTimerEl) triageTimerEl.innerText = `${m}:${s}`;
    }

    function triageStartTimer() {
      triageStartTime = Date.now();
      if (triageTimerInterval) clearInterval(triageTimerInterval);
      triageTimerInterval = setInterval(triageUpdateTimer, 500);
    }

    function triagePauseTimer() {
      if (!triageStartTime) return;
      const now = Date.now();
      triageAccumulatedSeconds += Math.floor((now - triageStartTime) / 1000);
      if (triageTimerInterval) clearInterval(triageTimerInterval);
      triageTimerInterval = null;
    }

    function triageResetTimer() {
      if (triageTimerInterval) clearInterval(triageTimerInterval);
      triageTimerInterval = null;
      triageStartTime = null;
      triageAccumulatedSeconds = 0;
      if (triageTimerEl) triageTimerEl.innerText = "00:00";
    }

    function applyRiskBadgeColorTo(el, cor) {
      if (!el) return;
      el.classList.remove("risk-none", "risk-vermelho", "risk-laranja", "risk-amarelo", "risk-verde", "risk-azul");
      const c = normalizeRiskColorLabel(cor);
      if (c === "Vermelho") el.classList.add("risk-vermelho");
      else if (c === "Laranja") el.classList.add("risk-laranja");
      else if (c === "Amarelo") el.classList.add("risk-amarelo");
      else if (c === "Verde") el.classList.add("risk-verde");
      else if (c === "Azul") el.classList.add("risk-azul");
      else el.classList.add("risk-none");
    }

    function renderRiskLegendInto(container, legendArr) {
      if (!container) return;
      const legend = Array.isArray(legendArr) && legendArr.length ? legendArr : RISK_LEGEND_DEFAULT;
      container.innerHTML = "";
      legend.slice(0, 5).forEach((item) => {
        const cor = normalizeRiskColorLabel(item?.cor || "");
        const tempo = String(item?.tempo || "").trim();
        const label = String(item?.descricao || "").trim();
        const row = document.createElement("div");
        row.className = "risk-legend-row";
        const badge = document.createElement("span");
        badge.className = "risk-badge";
        applyRiskBadgeColorTo(badge, cor);
        badge.textContent = cor || "Não informado";
        const txt = document.createElement("div");
        txt.className = "risk-legend-text";
        txt.textContent = (tempo ? (tempo + " - ") : "") + (label || "");
        row.appendChild(badge);
        row.appendChild(txt);
        container.appendChild(row);
      });
    }

    function triageClearReportUI() {
      if (triageReportPanel) triageReportPanel.classList.add("hidden");
      if (triageReportStatus) triageReportStatus.textContent = "";
      if (triageRiskBadge) { triageRiskBadge.textContent = "Não informado"; applyRiskBadgeColorTo(triageRiskBadge, "Não informado"); }
      if (triageRiskMeaning) { triageRiskMeaning.textContent = "Nenhum conteúdo disponível."; triageRiskMeaning.dataset.printText = ""; }
      if (triageRiskLegend) renderRiskLegendInto(triageRiskLegend, RISK_LEGEND_DEFAULT);

      if (triageProntuario) triageProntuario.value = "";
      if (triagePassagemMedico) triagePassagemMedico.value = "";
      if (triageAlertas) triageAlertas.value = "";
      if (triageCondutasNaoMed) triageCondutasNaoMed.value = "";
      if (triageCondutasMed) triageCondutasMed.value = "";
      if (triageMedidasExames) triageMedidasExames.value = "";
      if (triagePendencias) triagePendencias.value = "";
      if (triageQualidade) triageQualidade.value = "";
      if (triageFullReport) triageFullReport.value = "";
    }

    function startTriageRecording() {
      if (isRecording) {
        alert("Finalize a consulta antes de iniciar a triagem hospitalar.");
        return;
      }
      if (!triageRecognition) {
        initTriageSpeech();
        if (!triageRecognition) return;
      }

      triageIsRecording = true;
      triageIsPaused = false;
      triageFinalTranscript = "";
      triageInterimTranscript = "";

      if (triageError) triageError.textContent = "";
      triageClearReportUI();

      if (triagePauseBtn) {
        triagePauseBtn.style.display = "inline-block";
        triagePauseBtn.innerText = "Pausar";
      }

      if (triageRecordBtn) {
        triageRecordBtn.className = "recording";
        triageRecordBtn.innerText = "Encerrar triagem";
      }

      if (triageMicStatus) triageMicStatus.innerText = "Gravando triagem...";
      if (recordBtn) recordBtn.disabled = true;

      triageResetLiveGuidanceState();
      triageRenderLiveGuidance();
      triageStartGuidanceLoop();

      triageResetTimer();
      triageStartTimer();

      try { triageRecognition.start(); } catch (e) {}
    }

    function stopTriageRecording() {
      triageIsRecording = false;
      triageIsPaused = false;

      triageStopGuidanceLoop();
      triageInterimTranscript = "";
      triageRenderLiveGuidance();

      if (triageRecognition) {
        try { triageRecognition.stop(); } catch (e) {}
      }
      triagePauseTimer();

      if (triageRecordBtn) {
        triageRecordBtn.className = "start";
        triageRecordBtn.innerText = "Iniciar triagem hospitalar";
      }

      if (triagePauseBtn) triagePauseBtn.style.display = "none";
      if (recordBtn) recordBtn.disabled = false;
    }

    function pauseTriageRecording() {
      if (!triageIsRecording || triageIsPaused) return;
      triageIsPaused = true;

      triageStopGuidanceLoop();
      if (triageLiveGuidanceStatus) triageLiveGuidanceStatus.textContent = "Triagem pausada. As sugestões em tempo real serão retomadas ao retomar a gravação.";

      if (triageRecognition) {
        try { triageRecognition.stop(); } catch (e) {}
      }
      triagePauseTimer();

      if (triagePauseBtn) triagePauseBtn.innerText = "Retomar";
      if (triageMicStatus) triageMicStatus.innerText = "Triagem pausada.";
    }

    function resumeTriageRecording() {
      if (!triageIsRecording || !triageIsPaused) return;
      triageIsPaused = false;

      triageStartGuidanceLoop();

      if (triageRecognition) {
        try { triageRecognition.start(); } catch (e) {}
      }
      triageStartTimer();

      if (triagePauseBtn) triagePauseBtn.innerText = "Pausar";
      if (triageMicStatus) triageMicStatus.innerText = "Gravando triagem...";
    }

    async function finalizarTriagemHospitalar() {
      const combined = triageGetCombinedTranscript();
      const txt = (combined || "").trim();

      if (!txt || txt.length < 40) {
        if (triageError) triageError.textContent = "A transcrição da triagem ficou muito curta. Tente novamente, falando mais próximo ao microfone.";
        return;
      }

      if (resultsCard) resultsCard.classList.remove("hidden");
      if (triageReportPanel) triageReportPanel.classList.remove("hidden");
      if (triageReportStatus) {
        triageReportStatus.textContent = "Gerando relatório de triagem...";
        triageReportStatus.classList.add("loading-dot");
      }

      triageClearReportUI();
      if (triageReportPanel) triageReportPanel.classList.remove("hidden");

      try {
        const resp = await fetch(BACKEND_URL + "/api/gerar-triagem-hospitalar", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao: txt })
        });

        if (!resp.ok) {
          const t = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (triagem):", resp.status, t);
          if (triageReportStatus) {
            triageReportStatus.textContent = "Não foi possível gerar a triagem.";
            triageReportStatus.classList.remove("loading-dot");
          }
          return;
        }

        const data = await resp.json();

        const nivel = (data?.nivel_risco || "").trim() || "Não informado";
        const tempo = (data?.tempo_maximo || "").trim();
        const just = (data?.justificativa_risco || "").trim();
        const meaning = (tempo ? ("Tempo máximo: " + tempo + ". ") : "") + (just || "");

        if (triageRiskBadge) {
          triageRiskBadge.textContent = normalizeRiskColorLabel(nivel) || nivel || "Não informado";
          applyRiskBadgeColorTo(triageRiskBadge, nivel);
        }
        if (triageRiskMeaning) {
          triageRiskMeaning.textContent = meaning || "Nenhum conteúdo disponível.";
          triageRiskMeaning.dataset.printText = [
            "Classificação de risco: " + (normalizeRiskColorLabel(nivel) || nivel || "Não informado"),
            tempo ? ("Tempo máximo: " + tempo) : "",
            just ? ("Justificativa: " + just) : ""
          ].filter(Boolean).join("\n");
        }
        renderRiskLegendInto(triageRiskLegend, RISK_LEGEND_DEFAULT);

        if (triageProntuario) triageProntuario.value = (data?.texto_prontuario || "").trim();
        if (triagePassagemMedico) triagePassagemMedico.value = (data?.passagem_medico || "").trim();
        if (triageAlertas) triageAlertas.value = (data?.alertas_red_flags || "").trim();
        if (triageCondutasNaoMed) triageCondutasNaoMed.value = (data?.condutas_nao_medicamentosas || "").trim();
        if (triageCondutasMed) triageCondutasMed.value = (data?.condutas_medicamentosas || "").trim();
        if (triageMedidasExames) triageMedidasExames.value = (data?.medidas_exames_imediatos || "").trim();
        if (triagePendencias) triagePendencias.value = (data?.pendencias_checar || "").trim();
        if (triageQualidade) triageQualidade.value = (data?.checagem_qualidade || "").trim();
        if (triageFullReport) triageFullReport.value = (data?.relatorio_completo || "").trim();

        if (triageReportStatus) {
          triageReportStatus.textContent = "Triagem gerada.";
          triageReportStatus.classList.remove("loading-dot");
        }
      } catch (e) {
        console.error("Erro ao gerar triagem:", e);
        if (triageReportStatus) {
          triageReportStatus.textContent = "Erro ao gerar triagem.";
          triageReportStatus.classList.remove("loading-dot");
        }
      }
    }

    function hasLikelyChiefComplaint(text) {
      const t = String(text || "").toLowerCase();
      if (!t) return false;
      const kw = [
        "motivo", "queixa", "dor", "febre", "tosse", "falta de ar", "dispne", "diarre", "vômit",
        "náuse", "enjoo", "garganta", "cefale", "tont", "desmai", "urina", "ardor",
        "corrimento", "sangr", "pressão", "hipertens", "glic", "diabetes", "infec",
        "ferida", "queda", "trauma", "alerg", "coceira", "mancha"
      ];
      return kw.some(k => t.includes(k));
    }

    function maybeStartInitialGuidance(force) {
      if (!guidanceEnabled || !isRecording || isPaused) return;
      if (guidanceStage !== "aguardando_motivo") return;

      const combined = getCombinedTranscript();
      if (!combined || combined.length < 120) return;

      // Evita iniciar antes do paciente realmente falar algo clínico
      if (!force && !hasLikelyChiefComplaint(combined)) return;

      guidanceStage = "perguntas";
      guidanceTurnState = "aguardando_pergunta";
      guidanceAskedQuestion = "";
      guidanceAskedAtLen = combined.length;
      guidanceAskedAtTs = Date.now();
      guidanceChunkStartLen = combined.length;

      requestGuidanceFromBackend({ evento: "inicial" });
    }

    function onTranscriptUpdateForGuidance() {
      if (!guidanceEnabled || !isRecording || isPaused) return;

      // 1) Detecta automaticamente o momento de iniciar (após motivo)
      if (guidanceStage === "aguardando_motivo") {
        maybeStartInitialGuidance(false);
        return;
      }

      // 2) A partir daqui: está em "perguntas". Controla por turnos usando silêncio.
      scheduleGuidanceSilenceFinalize();
    }

    function scheduleGuidanceSilenceFinalize() {
      if (!guidanceEnabled || !isRecording || isPaused) return;

      if (guidanceSilenceTimer) clearTimeout(guidanceSilenceTimer);
      guidanceSilenceTimer = setTimeout(() => {
        finalizeGuidanceChunk();
      }, 1400);
    }

    function finalizeGuidanceChunk() {
      if (!guidanceEnabled || !isRecording || isPaused) return;

      const combined = getCombinedTranscript();
      if (!combined) return;

      if (guidanceChunkStartLen <= 0) {
        guidanceChunkStartLen = combined.length;
        return;
      }

      // Captura apenas o que foi acrescentado desde o último “silêncio”
      const chunk = combined.slice(guidanceChunkStartLen).trim();
      guidanceChunkStartLen = combined.length;

      if (!chunk || chunk.length < 10) return;

      // Evita processar chunks colados em sequência que são só repetição do reconhecimento
      const now = Date.now();
      if (guidanceLastChunkTs && (now - guidanceLastChunkTs) < 900) return;
      guidanceLastChunkTs = now;

      handleGuidanceUtteranceChunk(chunk);
    }

    function stripAccents(s) {
      return String(s || "")
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "");
    }

    function tokenizePt(s) {
      const t = stripAccents(String(s || "").toLowerCase())
        .replace(/[^a-z0-9\s]/g, " ")
        .replace(/\s+/g, " ")
        .trim();

      if (!t) return [];

      const stop = new Set([
        "a","o","os","as","um","uma","uns","umas","de","do","da","dos","das","no","na","nos","nas",
        "em","para","por","com","sem","e","ou","que","qual","quais","quando","como","onde","porque",
        "ao","aos","à","às","se","já","não","sim","me","te","lhe","eles","elas","você","vocês",
        "eu","tu","ele","ela","nós","vos","isso","isto","aquilo","essa","esse","este","esta",
        "tem","tá","está","foi","era","são","ser","ter","há"
      ]);

      return t.split(" ").filter(w => w && w.length > 2 && !stop.has(w));
    }

    function jaccardSimilarity(aTokens, bTokens) {
      const A = new Set(aTokens || []);
      const B = new Set(bTokens || []);
      if (!A.size || !B.size) return 0;
      let inter = 0;
      for (const w of A) if (B.has(w)) inter++;
      const union = A.size + B.size - inter;
      return union ? (inter / union) : 0;
    }

    function matchQuestionFromUtterance(utterance, questions) {
      const qs = Array.isArray(questions) ? questions : [];
      if (!qs.length) return "";
      const uTok = tokenizePt(utterance);
      if (!uTok.length) return "";

      let bestQ = "";
      let bestScore = 0;

      for (const q of qs.slice(0, 3)) {
        const score = jaccardSimilarity(uTok, tokenizePt(q));
        if (score > bestScore) {
          bestScore = score;
          bestQ = q;
        }
      }

      // Se a similaridade for baixa, não “chuta” qual foi, para não apagar/alterar errado.
      if (bestScore < 0.18) return "";
      return String(bestQ || "").trim();
    }

    function handleGuidanceUtteranceChunk(chunkText) {
      if (!chunkText) return;
      if (!guidancePending || !guidancePending.length) return;
      if (guidanceInFlight) return;

      // Turno 1: o enfermeiro faz uma pergunta (a partir das 3 sugeridas)
      if (guidanceTurnState === "aguardando_pergunta") {
        const matched = matchQuestionFromUtterance(chunkText, guidancePending);

        guidanceAskedQuestion = matched ? matched : "";
        guidanceAskedAtTs = Date.now();
        guidanceAskedAtLen = getCombinedTranscript().length;

        guidanceTurnState = "aguardando_resposta";
        renderLiveGuidance();
        return;
      }

      // Turno 2: o paciente responde -> atualiza as perguntas
      if (guidanceTurnState === "aguardando_resposta") {
        const dt = Date.now() - (guidanceAskedAtTs || 0);
        if (dt < 900) return; // evita disparo imediato

        // Atualiza com base no diálogo novo
        requestGuidanceFromBackend({ evento: "resposta", ultima_fala: chunkText });
        return;
      }
    }

    async function requestGuidanceFromBackend({ evento, ultima_fala }) {
      if (guidanceInFlight) return;
      if (!guidanceEnabled || !isRecording || isPaused) return;

      const combined = getCombinedTranscript();
      if (!combined || combined.length < 50) {
        renderLiveGuidance();
        return;
      }

      const payload = {
        transcricao: combined,
        estado: guidanceStage,
        evento: evento || "stream",
        pergunta_feita: guidanceAskedQuestion || "",
        perguntas_pendentes: Array.isArray(guidancePending) ? guidancePending.slice(0, 3) : [],
        confianca_atual: typeof guidanceConfidence === "number" ? guidanceConfidence : 0,
        hipotese_atual: guidanceHypothesis || "",
        ultima_fala: typeof ultima_fala === "string" ? ultima_fala.slice(0, 800) : ""
      };

      const h = hashForGuidancePayload(payload);
      if (h === guidanceLastPayloadHash && evento !== "inicial" && evento !== "resposta") return;
      guidanceLastPayloadHash = h;

      guidanceInFlight = true;
      renderLiveGuidance();

      try {
        const resp = await fetch(BACKEND_URL + "/api/guia-tempo-real", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        if (!resp.ok) {
          const txt = await resp.text();
          console.error("Erro HTTP do backend (guia em tempo real):", resp.status, txt);
          return;
        }

        const data = await resp.json();
        guidanceContextLabel = data.contexto || guidanceContextLabel || "";
        guidanceHypothesis = data.hipotese_principal || guidanceHypothesis || "";
        if (typeof data.confianca === "number") guidanceConfidence = data.confianca;

        const itens = Array.isArray(data.perguntas) ? data.perguntas : (Array.isArray(data.itens) ? data.itens : []);
        const normalized = itens.map(x => String(x || "").trim()).filter(Boolean);

        guidancePending = normalized.slice(0, 3);

        // Após atualizar, volta a aguardar a próxima pergunta do enfermeiro
        if (evento === "resposta") {
          guidanceTurnState = "aguardando_pergunta";
          guidanceAskedQuestion = "";
          guidanceAskedAtLen = combined.length;
          guidanceAskedAtTs = Date.now();
          guidanceChunkStartLen = combined.length;
        }

        // Após gerar as perguntas iniciais, aguarda a primeira pergunta do enfermeiro
        if (evento === "inicial") {
          guidanceTurnState = "aguardando_pergunta";
          guidanceAskedQuestion = "";
          guidanceAskedAtLen = combined.length;
          guidanceAskedAtTs = Date.now();
          guidanceChunkStartLen = combined.length;
        }
      } catch (err) {
        console.error("Falha ao buscar guia em tempo real:", err);
      } finally {
        guidanceInFlight = false;
        renderLiveGuidance();
      }
    }
function initSpeech() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        micStatus.innerText =
          "Seu navegador não suporta reconhecimento de voz. Use Google Chrome em um computador.";
        return;
      }
      recognition = new SR();
      recognition.lang = "pt-BR";
      recognition.continuous = true;
      recognition.interimResults = true;

      recognition.onresult = (event) => {
        let interim = "";
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            finalTranscript += transcript + " ";
          } else {
            interim += transcript;
          }
        }

        interimTranscript = interim.trim();
        // Atualiza o fluxo de perguntas/procedimentos (somente quando necessário)
        onTranscriptUpdateForGuidance();
      };

      recognition.onerror = (event) => {
        console.error("Erro no reconhecimento de voz:", event.error);
        if (event.error === "not-allowed" || event.error === "service-not-allowed") {
          micStatus.innerText =
            "Permita o acesso ao microfone nas configurações do navegador e tente novamente.";
        } else {
          micStatus.innerText =
            "Ocorreu um erro no reconhecimento de voz. Tente novamente.";
        }
      };

      recognition.onend = () => {
        if (isRecording && !isPaused) {
          try {
            recognition.start();
          } catch (err) {
            console.warn("Não foi possível retomar reconhecimento:", err);
          }
        }
      };
    }

    function updateTimer() {
      const now = Date.now();
      const seconds = accumulatedSeconds + Math.floor((now - startTime) / 1000);
      const m = ("0" + Math.floor(seconds / 60)).slice(-2);
      const s = ("0" + (seconds % 60)).slice(-2);
      timerEl.innerText = `${m}:${s}`;
    }

    function startTimer() {
      startTime = Date.now();
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(updateTimer, 500);
    }

    function pauseTimer() {
      if (!startTime) return;
      const now = Date.now();
      accumulatedSeconds += Math.floor((now - startTime) / 1000);
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
    }

    function resetTimer() {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
      startTime = null;
      accumulatedSeconds = 0;
      timerEl.innerText = "00:00";
    }

    function resetNewModulesUI() {
      sbarOutput.value = "";
      sbarStatus.textContent = "";
      classificationsStatus.textContent = "";
      pregnancyBox.textContent = "Nenhum conteúdo disponível.";
      lactationBox.textContent = "Nenhum conteúdo disponível.";
      if (interactionsBox) interactionsBox.textContent = "Nenhum conteúdo disponível.";
      if (interactionsStatus) interactionsStatus.textContent = "";
      if (presentationsMaxDoseBox) presentationsMaxDoseBox.textContent = "Nenhum conteúdo disponível.";
      if (presentationsMaxDoseStatus) presentationsMaxDoseStatus.textContent = "";
    }

    async function finalizarConsulta() {
      soapError.textContent = "";
      micStatus.innerText = "Gerando SOAP e prescrição com base na gravação...";
      micStatus.classList.add("loading-dot");

      if (recognition) {
        try {
          recognition.stop();
        } catch (e) {
          console.warn("Erro ao parar reconhecimento:", e);
        }
      }

      pauseTimer();

      const transcricao = finalTranscript.trim();
      if (!transcricao) {
        micStatus.classList.remove("loading-dot");
        micStatus.innerText =
          "Nenhuma fala foi capturada. Verifique o microfone e tente novamente.";
        return;
      }

      baseTranscriptRaw = transcricao;

      const transcricaoParaGeracao = buildTranscriptWithPatientContext(transcricao);
      baseTranscript = transcricaoParaGeracao;

      try {
        const resp = await fetch(BACKEND_URL + "/api/gerar-soap", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao: transcricaoParaGeracao })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend:", resp.status, txt);
          soapError.textContent =
            "Erro ao gerar evolução/plano de cuidados. Verifique o backend e tente novamente.";
          micStatus.innerText = "Falha ao gerar o resumo.";
          micStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const soap = data.soap || "";
        const prescricao = data.prescricao || "";

        updateSoapFromString(soap);

        prescriptionOutput.value = prescricao;
        printBtn.style.display = prescricao ? "inline-block" : "none";

        micStatus.innerText = "Consulta encerrada. SOAP e prescrição gerados.";
        micStatus.classList.remove("loading-dot");

        await updateClassifications();
        await updateRiskTriage();
        } catch (e) {
        console.error(e);
        soapError.textContent =
          "Erro ao gerar evolução e plano de cuidados (falha de rede ou backend).";
        micStatus.innerText = "Falha ao gerar o resumo.";
        micStatus.classList.remove("loading-dot");
      }
    }

    function splitSoap(soapText) {
      const sections = { S: "", O: "", A: "", P: "" };
      if (!soapText) return sections;

      const regex = /\b([SOAP])\s*:\s*([\s\S]*?)(?=\b[SOAP]\s*:|$)/g;
      let match;
      while ((match = regex.exec(soapText)) !== null) {
        const key = match[1].toUpperCase();
        sections[key] = match[2].trim();
      }
      return sections;
    }

    function updateSoapFromString(soapText) {
      currentSoapRaw = soapText || "";
      const parts = splitSoap(currentSoapRaw);

      soapS.value = parts.S || "";
      soapO.value = parts.O || "";
      soapA.value = parts.A || "";
      soapP.value = parts.P || "";

      resultsCard.classList.remove("hidden");
    }

    function getCombinedSoapFromFields() {
      const s = soapS.value.trim();
      const o = soapO.value.trim();
      const a = soapA.value.trim();
      const p = soapP.value.trim();

      let combined = "";
      if (s) combined += "S: " + s + "\n";
      if (o) combined += "O: " + o + "\n";
      if (a) combined += "A: " + a + "\n";
      if (p) combined += "P: " + p;
      currentSoapRaw = combined;
      return combined;
    }


    function formatInteractionsList(interacoes, observacoes) {
      const items = Array.isArray(interacoes) ? interacoes : [];
      if (!items.length) {
        const obs = (observacoes || "").trim();
        return obs
          ? ("Nenhuma interação clinicamente relevante identificada com segurança para os medicamentos prescritos.\n\nObservações:\n" + obs)
          : "Nenhuma interação clinicamente relevante identificada com segurança para os medicamentos prescritos.";
      }

      const parts = [];
      for (const it of items) {
        const meds = Array.isArray(it?.medicamentos) ? it.medicamentos : [];
        const a = meds[0] ? String(meds[0]) : "não informado";
        const b = meds[1] ? String(meds[1]) : "não informado";
        const grav = it?.gravidade ? String(it.gravidade) : "indeterminada";
        const desc = it?.descricao ? String(it.descricao) : "";
        const riscos = it?.riscos ? String(it.riscos) : "";
        const conduta = it?.conduta ? String(it.conduta) : "";

        let block = a + " + " + b + " (gravidade: " + grav + ")";
        if (desc.trim()) block += "\nInteração: " + desc.trim();
        if (riscos.trim()) block += "\nRiscos: " + riscos.trim();
        if (conduta.trim()) block += "\nConduta: " + conduta.trim();
        parts.push(block);
      }

      const obs = (observacoes || "").trim();
      if (obs) {
        parts.push("Observações:\n" + obs);
      }
      return parts.join("\n\n");
    }


    async function updateMedicationSafetyFromContext(contexto) {
      if (!interactionsBox || !interactionsStatus) return;

      interactionsStatus.textContent = "Gerando registro de administração segura...";
      interactionsStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/interacoes-medicamentosas", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ contexto })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP:", resp.status, txt);
          interactionsBox.textContent = "Falha ao gerar registro.";
          return;
        }

        const data = await resp.json().catch(() => ({}));
        interactionsBox.textContent = (data.registro || "").trim() || "Nenhum conteúdo disponível.";
      } catch (e) {
        console.error(e);
        interactionsBox.textContent = "Falha ao gerar registro (rede/backend).";
      } finally {
        interactionsStatus.classList.remove("loading-dot");
        interactionsStatus.textContent = "";
      }
    }

    function formatPresentationsMaxDoseList(itens) {
      const items = Array.isArray(itens) ? itens : [];
      if (!items.length) {
        return "Nenhuma informação disponível para os medicamentos prescritos.";
      }

      const lines = [];
      for (const it of items) {
        const med = it?.medicamento ? String(it.medicamento).trim() : "não informado";
        const a = it?.apresentacoes || {};
        const doseMax = it?.dosagem_maxima_diaria ? String(it.dosagem_maxima_diaria).trim() : "";

        lines.push("Medicamento: " + med);
        lines.push("Apresentações disponíveis:");

        const map = [
          ["Comprimido simples", a.comprimido_simples],
          ["Comprimido revestido", a.comprimido_revestido],
          ["Cápsula", a.capsula],
          ["Suspensão oral", a.suspensao_oral],
          ["Gotas", a.gotas],
          ["Solução oral", a.solucao_oral],
          ["Solução injetável", a.solucao_injetavel],
          ["Endovenosa", a.endovenosa],
          ["Intramuscular", a.intramuscular]
        ];

        for (const [label, val] of map) {
          const v = String(val || "").trim() || "não informado";
          lines.push("- " + label + ": " + v);
        }

        lines.push("Dosagem máxima diária: " + (doseMax || "não informado"));
        lines.push("");
      }

      return lines.join("\n").trim();
    }


    async function updateWoundCareFromContext(contexto) {
      if (!presentationsMaxDoseBox || !presentationsMaxDoseStatus) return;

      presentationsMaxDoseStatus.textContent = "Gerando registro de curativos e feridas...";
      presentationsMaxDoseStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/apresentacoes-dosagem-maxima", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ contexto })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP:", resp.status, txt);
          presentationsMaxDoseBox.textContent = "Falha ao gerar curativos.";
          return;
        }

        const data = await resp.json().catch(() => ({}));
        presentationsMaxDoseBox.textContent = (data.curativos || "").trim() || "Nenhum conteúdo disponível.";
      } catch (e) {
        console.error(e);
        presentationsMaxDoseBox.textContent = "Falha ao gerar curativos (rede/backend).";
      } finally {
        presentationsMaxDoseStatus.classList.remove("loading-dot");
        presentationsMaxDoseStatus.textContent = "";
      }
    }

    function updateQuestionsTimer() {
      const now = Date.now();
      const seconds = questionsAccumulatedSeconds + Math.floor((now - questionsStartTime) / 1000);
      const m = ("0" + Math.floor(seconds / 60)).slice(-2);
      const s = ("0" + (seconds % 60)).slice(-2);
      questionsTimerEl.innerText = `${m}:${s}`;
    }

    function startQuestionsTimer() {
      questionsStartTime = Date.now();
      if (questionsTimerInterval) clearInterval(questionsTimerInterval);
      questionsTimerInterval = setInterval(updateQuestionsTimer, 500);
    }

    function pauseQuestionsTimer() {
      if (!questionsStartTime) return;
      const now = Date.now();
      questionsAccumulatedSeconds += Math.floor((now - questionsStartTime) / 1000);
      if (questionsTimerInterval) clearInterval(questionsTimerInterval);
      questionsTimerInterval = null;
    }

    function resetQuestionsTimer() {
      if (questionsTimerInterval) clearInterval(questionsTimerInterval);
      questionsTimerInterval = null;
      questionsStartTime = null;
      questionsAccumulatedSeconds = 0;
      questionsTimerEl.innerText = "00:00";
    }

    function initQuestionsSpeech() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        return null;
      }

      const rec = new SR();
      rec.lang = "pt-BR";
      rec.continuous = true;
      rec.interimResults = true;

      rec.onresult = (event) => {
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            questionsFinalTranscript += transcript + " ";
          }
        }
      };

      rec.onerror = (event) => {
        console.error("Erro no reconhecimento das perguntas:", event.error);
        recommendationsStatus.textContent =
          "Ocorreu um erro no reconhecimento de voz das perguntas. Tente novamente.";
        recommendationsStatus.classList.remove("loading-dot");
      };

      rec.onend = () => {
        if (questionsIsRecording) {
          try {
            rec.start();
          } catch (err) {
            console.warn("Não foi possível retomar reconhecimento das perguntas:", err);
          }
        }
      };

      return rec;
    }

    function startQuestionsRecording() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        recommendationsStatus.textContent =
          "Seu navegador não suporta reconhecimento de voz. Use Google Chrome em um computador.";
        return;
      }

      if (!questionsRecognition) {
        questionsRecognition = initQuestionsSpeech();
        if (!questionsRecognition) return;
      }

      questionsIsRecording = true;
      questionsFinalTranscript = "";

      questionsTimerEl.classList.remove("hidden");
      resetQuestionsTimer();
      startQuestionsTimer();

      askQuestionsBtn.textContent = "Encerrar perguntas";
      closeRecommendationsBtn.disabled = true;
      closeRecommendationsBtn.style.opacity = "0.5";

      recommendationsStatus.textContent =
        "Gravando perguntas e respostas. Quando terminar, clique em \"Encerrar perguntas\".";
      recommendationsStatus.classList.remove("loading-dot");

      try {
        questionsRecognition.start();
      } catch (e) {
        console.warn("Erro ao iniciar reconhecimento das perguntas:", e);
      }
    }

    async function stopQuestionsRecordingAndUpdateSoap() {
      questionsIsRecording = false;

      if (questionsRecognition) {
        try {
          questionsRecognition.stop();
        } catch (e) {
          console.warn("Erro ao parar reconhecimento das perguntas:", e);
        }
      }

      pauseQuestionsTimer();

      const qa = (questionsFinalTranscript || "").trim();
      if (!qa) {
        recommendationsStatus.textContent = "Nenhuma fala foi capturada nesta rodada de perguntas.";
        askQuestionsBtn.textContent = "Complementar avaliação";
        closeRecommendationsBtn.disabled = false;
        closeRecommendationsBtn.style.opacity = "1";
        askQuestionsBtn.disabled = false;
        resetQuestionsTimer();
        questionsTimerEl.classList.add("hidden");
        return;
      }

      const soapAtual = getCombinedSoapFromFields();
      if (!soapAtual) {
        recommendationsStatus.textContent = "Não há SOAP disponível para atualizar.";
        askQuestionsBtn.textContent = "Complementar avaliação";
        closeRecommendationsBtn.disabled = false;
        closeRecommendationsBtn.style.opacity = "1";
        askQuestionsBtn.disabled = false;
        return;
      }

      askQuestionsBtn.disabled = true;
      recommendationsStatus.textContent = "Atualizando SOAP e módulos com as novas respostas...";
      recommendationsStatus.classList.add("loading-dot");

      const transcricaoBase = (baseTranscript || finalTranscript || "").trim();

      try {
        const resp = await fetch(BACKEND_URL + "/api/atualizar-soap-perguntas", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            soap_atual: soapAtual,
            perguntas_e_respostas: qa,
            transcricao_base: transcricaoBase
          })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (atualizar perguntas):", resp.status, txt);
          recommendationsStatus.textContent = "Não foi possível atualizar o SOAP com as novas respostas.";
          recommendationsStatus.classList.remove("loading-dot");
          askQuestionsBtn.disabled = false;
          return;
        }

        const data = await resp.json();
        const soap = data.soap || "";
        const prescricao = data.prescricao || "";

        if (soap) {
          updateSoapFromString(soap);
        }
        if (prescricao) {
          prescriptionOutput.value = prescricao;
          printBtn.style.display = "inline-block";
        }

        const appended =
          (transcricaoBase ? transcricaoBase + "\n\n" : "") +
          "RODADA ADICIONAL DE PERGUNTAS E RESPOSTAS:\n" +
          qa +
          "\n";
        baseTranscript = appended;
        finalTranscript = appended;

        recommendationsStatus.textContent = "SOAP atualizado com as novas respostas.";
        recommendationsStatus.classList.remove("loading-dot");

        await updateClassifications();
        await updateRiskTriage();
      } catch (err) {
        console.error("Erro geral ao atualizar SOAP com perguntas:", err);
        recommendationsStatus.textContent = "Erro ao atualizar o SOAP com as novas respostas.";
        recommendationsStatus.classList.remove("loading-dot");
      } finally {
        askQuestionsBtn.textContent = "Complementar avaliação";
        askQuestionsBtn.disabled = false;
        closeRecommendationsBtn.disabled = false;
        closeRecommendationsBtn.style.opacity = "1";
        resetQuestionsTimer();
        questionsTimerEl.classList.add("hidden");
        recommendationsPanel.classList.remove("visible");
      }
    }

    async function fetchRecommendations() {
      const combinedSoap = getCombinedSoapFromFields();
      if (!combinedSoap) {
        soapError.textContent =
          "Não há SOAP gerado ainda para sugerir perguntas complementares.";
        return;
      }

      // Reseta qualquer rodada anterior de perguntas
      if (questionsIsRecording && questionsRecognition) {
        try {
          questionsIsRecording = false;
          questionsRecognition.stop();
        } catch (e) {}
      }
      askQuestionsBtn.textContent = "Complementar avaliação";
      askQuestionsBtn.disabled = true;
      closeRecommendationsBtn.disabled = false;
      closeRecommendationsBtn.style.opacity = "1";
      resetQuestionsTimer();
      questionsTimerEl.classList.add("hidden");

      recommendationsPanel.classList.add("visible");
      recommendationsStatus.textContent =
        "Gerando perguntas complementares essenciais com base na queixa e no SOAP...";
      recommendationsStatus.classList.add("loading-dot");
      recommendationsList.innerHTML = "";


      try {
        const resp = await fetch(BACKEND_URL + "/api/recomendacoes-anamnese", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            soap: combinedSoap
          })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error(
            "Erro HTTP do backend (recomendações):",
            resp.status,
            txt
          );
          recommendationsStatus.textContent =
            "Não foi possível gerar as recomendações de perguntas.";
          recommendationsStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const perguntas = Array.isArray(data.perguntas) ? data.perguntas : [];

        if (!perguntas.length) {
          recommendationsStatus.textContent =
            "Nenhuma pergunta complementar foi sugerida para este caso.";
          recommendationsStatus.classList.remove("loading-dot");
          return;
        }

        recommendationsList.innerHTML = "";
        perguntas.forEach((q, index) => {
          const item = document.createElement("div");
          item.className = "recommendation-item";
          item.textContent = (index + 1) + ". " + q;
          recommendationsList.appendChild(item);
        });

        recommendationsStatus.textContent =
          "Use estas perguntas para aprofundar a anamnese com o paciente.";
        recommendationsStatus.classList.remove("loading-dot");
        askQuestionsBtn.disabled = false;
      } catch (err) {
        console.error("Erro geral ao buscar recomendações:", err);
        recommendationsStatus.textContent =
          "Erro ao gerar recomendações de perguntas.";
        recommendationsStatus.classList.remove("loading-dot");
      }
    }

    async function handleAskQuestionsFromPanel() {
      if (!questionsIsRecording) {
        startQuestionsRecording();
      } else {
        await stopQuestionsRecordingAndUpdateSoap();
      }
    }

    function startRecording() {
      if (triageIsRecording) {
        alert("Finalize a triagem hospitalar antes de iniciar a consulta.");
        return;
      }
      if (!recognition) {
        initSpeech();
        if (!recognition) {
          return;
        }
      }

      isRecording = true;
      isPaused = false;
      if (triageRecordBtn) triageRecordBtn.disabled = true;
      finalTranscript = "";
      baseTranscript = "";
      resultsCard.classList.add("hidden");
      printBtn.style.display = "none";
      prescriptionOutput.value = "";
      soapS.value = "";
      soapO.value = "";
      soapA.value = "";
      soapP.value = "";
      resetNewModulesUI();

      pauseBtn.style.display = "inline-block";
      pauseBtn.innerText = "Pausar";
      recordBtn.className = "recording";
      recordBtn.innerText = "Encerrar consulta";
      micStatus.innerText = "Gravando consulta...";
      soapError.textContent = "";
      resultsCard.classList.add("hidden");

      resetLiveGuidanceState();
      renderLiveGuidance();
      startGuidanceLoop();

      resetTimer();
      startTimer();

      try {
        recognition.start();
      } catch (e) {
        console.warn("Erro ao iniciar reconhecimento:", e);
      }
    }

    function stopRecording() {
      isRecording = false;
      isPaused = false;

      stopGuidanceLoop();
      interimTranscript = "";
      renderLiveGuidance();

      if (recognition) {
        try {
          recognition.stop();
        } catch (e) {
          console.warn("Erro ao parar reconhecimento:", e);
        }
      }
      pauseTimer();
      recordBtn.className = "start";
      recordBtn.innerText = "Iniciar atendimento";
      pauseBtn.style.display = "none";
      if (triageRecordBtn) triageRecordBtn.disabled = false;
    }

    function pauseRecording() {
      if (!isRecording || isPaused) return;
      isPaused = true;

      stopGuidanceLoop();
      if (liveGuidanceStatus) liveGuidanceStatus.textContent = "Consulta pausada. As sugestões em tempo real serão retomadas ao retomar a gravação.";

      if (recognition) {
        try {
          recognition.stop();
        } catch (e) {
          console.warn("Erro ao pausar reconhecimento:", e);
        }
      }
      pauseTimer();
      pauseBtn.innerText = "Retomar";
      micStatus.innerText = "Consulta pausada.";
    }

    function resumeRecording() {
      if (!isRecording || !isPaused) return;
      isPaused = false;

      startGuidanceLoop();

      if (recognition) {
        try {
          recognition.start();
        } catch (e) {
          console.warn("Erro ao retomar reconhecimento:", e);
        }
      }
      startTimer();
      pauseBtn.innerText = "Pausar";
      micStatus.innerText = "Gravando consulta...";
    }

    
    function copyToClipboard(text) {
      if (!text) return;
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).catch(() => {
          alert("Não foi possível copiar o texto.");
        });
      } else {
        const temp = document.createElement("textarea");
        temp.value = text;
        document.body.appendChild(temp);
        temp.select();
        try {
          document.execCommand("copy");
        } catch (e) {
          alert("Não foi possível copiar o texto.");
        }
        document.body.removeChild(temp);
      }
    }

        // =========================
    // IMAGENS - compressão + análise automática (até 4 fotos por módulo)
    // =========================
    async function fileToCompressedDataUrl(file, maxDim = 1280, quality = 0.82) {
  // Tenta converter para JPEG via canvas (reduz tamanho e evita estouro de limite).
  // Se falhar (ex.: formatos não suportados), retorna string vazia para permitir fallback.
  const f = file;
  if (!f) return "";

  const objectUrl = URL.createObjectURL(f);
  try {
    const img = await new Promise((resolve, reject) => {
      const i = new Image();
      i.onload = () => resolve(i);
      i.onerror = () => reject(new Error("Falha ao carregar a imagem."));
      i.src = objectUrl;
    });

    const w = img.naturalWidth || img.width || 0;
    const h = img.naturalHeight || img.height || 0;
    if (!w || !h) throw new Error("Dimensões inválidas.");

    const scale = Math.min(1, maxDim / Math.max(w, h));
    const outW = Math.max(1, Math.round(w * scale));
    const outH = Math.max(1, Math.round(h * scale));

    const canvas = document.createElement("canvas");
    canvas.width = outW;
    canvas.height = outH;

    const ctx = canvas.getContext("2d");
    if (!ctx) throw new Error("Falha ao preparar canvas.");
    ctx.drawImage(img, 0, 0, outW, outH);

    return canvas.toDataURL("image/jpeg", quality);
  } catch (e) {
    return "";
  } finally {
    URL.revokeObjectURL(objectUrl);
  }
}

function fileToDataUrl(file) {
  return new Promise((resolve, reject) => {
    try {
      const reader = new FileReader();
      reader.onload = () => resolve(String(reader.result || ""));
      reader.onerror = () => reject(new Error("Falha ao ler arquivo."));
      reader.readAsDataURL(file);
    } catch (e) {
      reject(e);
    }
  });
}

async function addFilesToTarget(files, targetKey, mode) {
  const list = Array.from(files || []);
  if (!list.length) return;

  const key = (targetKey === "wound" || targetKey === "med" || targetKey === "exam") ? targetKey : "med";

  const cfg = key === "wound"
    ? { arr: woundImages, statusEl: presentationsMaxDoseStatus, boxEl: presentationsMaxDoseBox, update: updateWoundActions, schedule: scheduleWoundAnalysis }
    : key === "exam"
      ? { arr: examImages, statusEl: examInterpretationStatus, boxEl: examInterpretationBox, update: updateExamActions, schedule: scheduleExamAnalysis }
      : { arr: medImages, statusEl: interactionsStatus, boxEl: interactionsBox, update: updateMedSafetyActions, schedule: scheduleMedAnalysis };

  const arr = cfg.arr;
  const statusEl = cfg.statusEl;
  const boxEl = cfg.boxEl;

  if (mode === "replace") {
    arr.length = 0;
  }

  // Feedback imediato (para não parecer que "não aconteceu nada")
  if (statusEl) statusEl.textContent = "Carregando imagem(ns).";
  if (boxEl) boxEl.textContent = "Processando.";
  if (cfg && cfg.update) cfg.update();

  const remaining = Math.max(0, 4 - arr.length);
  const slice = list.slice(0, remaining);

  let added = 0;
  let failed = 0;

  for (const file of slice) {
    try {
      // 1) tenta canvas->JPEG (melhor para upload)
      let dataUrl = await fileToCompressedDataUrl(file);
      // 2) fallback: dataURL direto (quando canvas falha)
      if (!dataUrl) dataUrl = await fileToDataUrl(file);

      if (dataUrl && dataUrl.startsWith("data:image/")) {
        arr.push(dataUrl);
        added += 1;
      } else {
        failed += 1;
      }
    } catch (e) {
      failed += 1;
    }
  }

  if (!arr.length) {
    const msg = "Não foi possível ler a imagem selecionada neste aparelho. Tente usar JPG/PNG (ou ajuste a câmera para modo mais compatível).";
    if (statusEl) statusEl.textContent = msg;
    if (boxEl) boxEl.textContent = "Nenhum conteúdo disponível.";
    if (cfg && cfg.update) cfg.update();
    return;
  }

  // Dispara análise automática
  const countMsg = arr.length + " imagem(ns) selecionada(s). Enviando para análise.";
  if (statusEl) statusEl.textContent = countMsg;

  if (cfg && cfg.schedule) cfg.schedule();
}
    async function analyzeWoundWithImages(dataUrls) {
  if (!presentationsMaxDoseStatus || !presentationsMaxDoseBox) return;

  const images = Array.isArray(dataUrls) ? dataUrls.filter(Boolean) : [];
  if (!images.length) {
    presentationsMaxDoseStatus.textContent = "Nenhuma imagem selecionada.";
    presentationsMaxDoseBox.textContent = "Nenhum conteúdo disponível.";
    updateWoundActions();
    return;
  }

  presentationsMaxDoseStatus.textContent = "Analisando imagem(ns) da lesão.";
  presentationsMaxDoseBox.textContent = "Processando.";
  updateWoundActions();

  try {
    const payload = {
      images_data_url: images,
      image_data_url: images[0] // compatibilidade
    };

    const resp = await fetch(BACKEND_URL + "/api/analisar-lesao-imagem", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const data = await resp.json().catch(() => ({}));
    if (!resp.ok) throw new Error(data?.error || "Falha ao analisar imagem.");

    const texto = (data?.texto || "").trim();
    presentationsMaxDoseBox.textContent = texto || "Nenhum conteúdo disponível.";
    presentationsMaxDoseStatus.textContent = "Análise concluída.";
    updateWoundActions();
  } catch (e) {
    presentationsMaxDoseStatus.textContent = "Falha ao analisar imagem. " + (e && e.message ? e.message : "");
    presentationsMaxDoseBox.textContent = "Nenhum conteúdo disponível.";
    updateWoundActions();
  }
}


    async function analyzePrescriptionWithImages(dataUrls) {
  if (!interactionsStatus || !interactionsBox) return;

  const images = Array.isArray(dataUrls) ? dataUrls.filter(Boolean) : [];
  if (!images.length) {
    interactionsStatus.textContent = "Nenhuma imagem selecionada.";
    interactionsBox.textContent = "Nenhum conteúdo disponível.";
    updateMedSafetyActions();
    return;
  }

  interactionsStatus.textContent = "Analisando prescrição (imagem(ns)).";
  interactionsBox.textContent = "Processando.";
  updateMedSafetyActions();

  try {
    const payload = {
      images_data_url: images,
      image_data_url: images[0] // compatibilidade
    };

    const resp = await fetch(BACKEND_URL + "/api/analisar-prescricao-imagem", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const data = await resp.json().catch(() => ({}));
    if (!resp.ok) throw new Error(data?.error || "Falha ao analisar prescrição.");

    const texto = (data?.texto || "").trim();
    interactionsBox.textContent = texto || "Nenhum conteúdo disponível.";
    interactionsStatus.textContent = "Análise concluída.";
    updateMedSafetyActions();
  } catch (e) {
    interactionsStatus.textContent = "Falha ao analisar prescrição. " + (e && e.message ? e.message : "");
    interactionsBox.textContent = "Nenhum conteúdo disponível.";
    updateMedSafetyActions();
  }
}



    async function analyzeExamWithImages(dataUrls) {
  if (!examInterpretationStatus || !examInterpretationBox) return;

  const images = Array.isArray(dataUrls) ? dataUrls.filter(Boolean) : [];
  if (!images.length) {
    examInterpretationStatus.textContent = "Nenhuma imagem selecionada.";
    examInterpretationBox.textContent = "Nenhum conteúdo disponível.";
    updateExamActions();
    return;
  }

  examInterpretationStatus.textContent = "Analisando exame (imagem(ns)).";
  examInterpretationBox.textContent = "Processando.";
  updateExamActions();

  try {
    const payload = {
      images_data_url: images,
      image_data_url: images[0] // compatibilidade
    };

    const resp = await fetch(BACKEND_URL + "/api/interpretar-exame-imagem", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const data = await resp.json().catch(() => ({}));
    if (!resp.ok) throw new Error(data?.error || "Falha ao interpretar o exame.");

    const texto = (data?.texto || "").trim();
    examInterpretationBox.textContent = texto || "Nenhum conteúdo disponível.";
    examInterpretationStatus.textContent = "Análise concluída.";
    updateExamActions();
  } catch (e) {
    examInterpretationStatus.textContent = "Falha ao interpretar o exame. " + (e && e.message ? e.message : "");
    examInterpretationBox.textContent = "Nenhum conteúdo disponível.";
    updateExamActions();
  }
}

    function getSoapSectionText(letter) {
      switch (letter) {
        case "S":
          return soapS.value.trim();
        case "O":
          return soapO.value.trim();
        case "A":
          return soapA.value.trim();
        case "P":
          return soapP.value.trim();
        default:
          return "";
      }
    }

    function openPrintWindow(title, text) {
      const content = (text || "").trim();
      if (!content) {
        alert("Não há conteúdo para imprimir.");
        return;
      }

      const w = window.open("", "_blank", "width=800,height=600");
      if (!w) {
        alert("Não foi possível abrir a janela de impressão.");
        return;
      }

      w.document.write("<html><head><title>" + escapeHtml(title) + "</title></head><body>");
      w.document.write("<pre style='font-family: Arial, sans-serif; white-space: pre-wrap;'>" +
        escapeHtml(content) +
        "</pre>");
      w.document.write("</body></html>");
      w.document.close();
      w.focus();
      w.print();
    }

    
    function extractMedicationsFromPrescriptionText(text) {
      const raw = String(text || "").replace(/\r/g, "").trim();
      if (!raw) return [];

      const lines = raw.split("\n").map(l => l.trim()).filter(Boolean);

      const meds = [];

      // Heurística principal:
      // - Prescrição ambulatorial: medicamentos aparecem em lista numerada e a seção "Orientações:" deve ser ignorada.
      // - Prescrição hospitalar: medicamentos aparecem em bullets dentro das seções
      //   "Medicamentos contínuos:" e/ou "Medicamentos se necessário:".

      const isHospital =
        lines.some(l => /^medicamentos\s+cont[ií]nuos\s*:/i.test(l)) ||
        lines.some(l => /^medicamentos\s+se\s+necess[aá]rio\s*:/i.test(l)) ||
        lines.some(l => /^medicamentos\s+se\s+necessario\s*:/i.test(l));

      if (!isHospital) {
        for (const line of lines) {
          const low = line.toLowerCase();

          // Para de coletar ao entrar em orientações/assinatura
          if (low.startsWith("orientações:") || low.startsWith("orientacoes:")) break;
          if (low.startsWith("assinatura:")) break;
          if (low.startsWith("médico") || low.startsWith("medico")) break;

          const m = line.match(/^\s*\d+\s*[\.\)]\s*([^—–-]+?)\s*(?:[—–-].*)?$/);
          if (m && m[1]) {
            const name = m[1].trim();
            if (name && name.length >= 2) meds.push(name);
          }
        }
      } else {
        let section = null; // "cont", "prn", "other"

        for (const line of lines) {
          const low = line.toLowerCase();

          if (/^medicamentos\s+cont[ií]nuos\s*:/i.test(line) || /^medicamentos\s+continuos\s*:/i.test(line)) {
            section = "cont";
            continue;
          }
          if (/^medicamentos\s+se\s+necess[aá]rio\s*:/i.test(line) || /^medicamentos\s+se\s+necessario\s*:/i.test(line)) {
            section = "prn";
            continue;
          }

          // Qualquer outro cabeçalho em formato "X:" encerra a seção de medicamentos
          if (/^[a-zA-ZÀ-ÿ].*:\s*$/.test(line) && !/^medicamentos\s+/i.test(line)) {
            section = "other";
            continue;
          }

          // Captura bullets apenas nas seções corretas
          const isBullet = /^\s*[-•]\s+/.test(line);
          if (!isBullet) continue;
          if (section !== "cont" && section !== "prn") continue;

          const m = line.match(/^\s*[-•]\s*([^—–-]+?)\s*(?:[—–-].*)?$/);
          if (!m || !m[1]) continue;

          const name = m[1].trim();
          if (!name || name.length < 2) continue;
          if (/^(n[aã]o informado)$/i.test(name)) continue;

          meds.push(name);
        }
      }

      // Deduplicação preservando ordem
      const seen = new Set();
      const unique = [];
      for (const x of meds) {
        const key = x.toLowerCase();
        if (seen.has(key)) continue;
        seen.add(key);
        unique.push(x);
      }

      return unique.slice(0, 60);
    }

    function getAllPrescribedMedications() {
      const amb = prescriptionOutput.value || "";
      const hosp = sbarOutput.value || "";
      const meds = [
        ...extractMedicationsFromPrescriptionText(amb),
        ...extractMedicationsFromPrescriptionText(hosp)
      ];

      const seen = new Set();
      const unique = [];
      for (const x of meds) {
        const key = x.toLowerCase();
        if (seen.has(key)) continue;
        seen.add(key);
        unique.push(x);
      }
      return unique.slice(0, 60);
    }

                let sbarTimerInterval = null;
        let sbarStartTs = 0;

        let sbarRecognition = null;
        let sbarIsRecording = false;
        

          stopSbarTimer();
let sbarFinalTranscript = "";
        let sbarInterimTranscript = "";
        let sbarHasStarted = false;
        let sbarHasAnyResult = false;
        let sbarStartAttemptId = 0;


        function startSbarTimer() {
          if (!sbarTimer) return;
          sbarStartTs = Date.now();
          sbarTimer.textContent = "00:00";
          sbarTimer.classList.remove("hidden");
          if (sbarTimerInterval) clearInterval(sbarTimerInterval);
          sbarTimerInterval = setInterval(() => {
            const elapsed = Math.max(0, Date.now() - sbarStartTs);
            const totalSec = Math.floor(elapsed / 1000);
            const mm = String(Math.floor(totalSec / 60)).padStart(2, "0");
            const ss = String(totalSec % 60).padStart(2, "0");
            sbarTimer.textContent = `${mm}:${ss}`;
            if (sbarIsRecording && sbarStatus) {
              sbarStatus.textContent = `Gravando passagem de plantão (SBAR)... ${mm}:${ss} (clique novamente em "Encerrar e gerar SBAR" quando terminar)`;
            }
          }, 500);
        }

        function stopSbarTimer() {
          if (sbarTimerInterval) clearInterval(sbarTimerInterval);
          sbarTimerInterval = null;
          if (!sbarTimer) return;
          sbarTimer.classList.add("hidden");
        }

        function initSbarSpeech() {
          const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
          if (!SR) {
            if (sbarStatus) {
              sbarStatus.textContent = "Seu navegador não suporta reconhecimento de voz. Use Google Chrome.";
            }
            return;
          }

          sbarRecognition = new SR();
          sbarRecognition.lang = "pt-BR";
          sbarRecognition.continuous = true;
          sbarRecognition.interimResults = true;

          
          sbarRecognition.onstart = () => {
            sbarHasStarted = true;
            if (sbarStatus) {
              sbarStatus.textContent = "Gravando passagem de plantão (SBAR)... Quando terminar, clique em \"Encerrar e gerar SBAR\".";
              sbarStatus.classList.remove("loading-dot");
            }
          };
sbarRecognition.onresult = (event) => {
            
            sbarHasAnyResult = true;
let interim = "";
            for (let i = event.resultIndex; i < event.results.length; i++) {
              const transcript = event.results[i][0].transcript;
              if (event.results[i].isFinal) {
                sbarFinalTranscript += transcript + " ";
              } else {
                interim += transcript;
              }
            }
            sbarInterimTranscript = interim.trim();
          };

          sbarRecognition.onerror = (event) => {
            console.error("Erro no reconhecimento de voz (SBAR):", event.error);
            if (sbarStatus) {
              if (event.error === "not-allowed" || event.error === "service-not-allowed") {
                sbarStatus.textContent = "Permita o acesso ao microfone nas configurações do navegador e tente novamente.";
              } else {
                sbarStatus.textContent = "Ocorreu um erro no reconhecimento de voz. Tente novamente.";
              }
            }
          };

          sbarRecognition.onend = () => {
            if (sbarIsRecording) {
              try {
                sbarRecognition.start();
              } catch (err) {
                console.warn("Não foi possível retomar reconhecimento (SBAR):", err);
              }
            }
          };
        }

        function hasAnyOtherRecordingActive() {
          // isRecording: consulta SOAP
          // triageIsRecording: triagem
          // reportIsRecording: relatórios
          // questionsIsRecording: perguntas adicionais
          return !!(isRecording || triageIsRecording || reportIsRecording || questionsIsRecording);
        }

        // Guia do SBAR (inline, dentro do próprio módulo)
        if (openSbarGuideBtn && sbarGuidePanel) {
          openSbarGuideBtn.addEventListener("click", () => {
            const willOpen = sbarGuidePanel.classList.contains("hidden");
            sbarGuidePanel.classList.toggle("hidden");
            if (willOpen) {
              // Mantém o usuário no módulo SBAR (sem rolar para o topo)
              sbarGuidePanel.scrollIntoView({ behavior: "smooth", block: "nearest" });
            }
          });
        }


        async function startSbarRecording() {
          if (hasAnyOtherRecordingActive()) {
            alert("Finalize a gravação atual (consulta/triagem/relatórios) antes de iniciar o SBAR.");
            return;
          }

          if (!sbarRecognition) {
            initSbarSpeech();
            if (!sbarRecognition) return;
          }

          // Reset de estado
          sbarIsRecording = true;
          sbarFinalTranscript = "";
          sbarInterimTranscript = "";
          
          sbarHasStarted = false;
          sbarHasAnyResult = false;
          const myAttempt = ++sbarStartAttemptId;
          // Se o reconhecimento não iniciar em ~2.5s, aborta e orienta o usuário.
          setTimeout(() => {
            if (sbarIsRecording && !sbarHasStarted && myAttempt === sbarStartAttemptId) {
              try { if (sbarRecognition) sbarRecognition.stop(); } catch (e) {}
              sbarIsRecording = false;
              stopSbarTimer();
              if (sbarStatus) {
                sbarStatus.textContent = "Não foi possível iniciar o microfone. Verifique permissão, selecione o microfone correto e tente novamente."; 
                sbarStatus.classList.remove("loading-dot");
              }
              if (sbarRecordBtn) {
                sbarRecordBtn.classList.remove("recording");
                sbarRecordBtn.classList.add("start");
                sbarRecordBtn.textContent = "Iniciar passagem de plantão (SBAR)";
                sbarRecordBtn.disabled = false;
              }
            }
          }, 2500);
if (sbarOutput) sbarOutput.value = "";
          if (sbarStatus) {
            sbarStatus.textContent = "Gravando SBAR. Fale em voz alta, de preferência próximo ao microfone. Clique novamente em \"Encerrar e gerar SBAR\" quando terminar.";
            sbarStatus.classList.remove("loading-dot");
          }

          if (sbarRecordBtn) {
            sbarRecordBtn.classList.remove("start");
            sbarRecordBtn.classList.add("recording");
            sbarRecordBtn.textContent = "Encerrar e gerar SBAR";
            sbarRecordBtn.disabled = false;
          }

          startSbarTimer();

          // Garante permissão do microfone (reduz falhas silenciosas em alguns navegadores)
          try {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
              const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
              // libera imediatamente (SpeechRecognition usa o próprio pipeline)
              stream.getTracks().forEach(t => t.stop());
            }
          } catch (e) {
            if (sbarStatus) {
              sbarStatus.textContent = "Permissão de microfone negada ou indisponível.";
              sbarStatus.classList.remove("loading-dot");
            }
          }

          try {
            // Evita erro 'recognition has already started'
            try { sbarRecognition.abort(); } catch (e) {}
            sbarRecognition.start();
          } catch (err) {
            console.error("Falha ao iniciar reconhecimento (SBAR):", err);
            if (sbarStatus) sbarStatus.textContent = "Não foi possível iniciar a gravação do SBAR.";
            sbarIsRecording = false;
            if (sbarRecordBtn) {
              sbarRecordBtn.classList.remove("recording");
              sbarRecordBtn.classList.add("start");
              sbarRecordBtn.textContent = "Iniciar passagem de plantão (SBAR)";
            }
            stopSbarTimer();
          }
        }

        async function stopSbarRecordingAndGenerate() {
          if (!sbarIsRecording) return;

          sbarIsRecording = false;

          if (sbarRecordBtn) {
            sbarRecordBtn.disabled = true;
          }

          try {
            if (sbarRecognition) sbarRecognition.stop();
          } catch (e) {
            console.warn("Erro ao parar reconhecimento (SBAR):", e);
          }

          // pequena espera para capturar os últimos resultados finais
          await new Promise(r => setTimeout(r, 900));

          const transcricao = String(((sbarFinalTranscript || "") + " " + (sbarInterimTranscript || ""))).trim();

          if (!transcricao) {
            if (sbarStatus) {
              sbarStatus.textContent = (!sbarHasStarted ? "A gravação não iniciou. Verifique permissão do microfone e tente novamente." : "Nenhuma fala foi capturada. Tente novamente, falando mais próximo ao microfone (ou aguarde 1 a 2 segundos antes de começar a falar).");
              sbarStatus.classList.remove("loading-dot");
            }
            if (sbarRecordBtn) {
              sbarRecordBtn.disabled = false;
              sbarRecordBtn.classList.remove("recording");
              sbarRecordBtn.classList.add("start");
              sbarRecordBtn.textContent = "Iniciar passagem de plantão (SBAR)";
            }
            stopSbarTimer();
            return;
          }

          await generateHospitalPrescriptionFromTranscript(transcricao);
        }

        async function generateHospitalPrescriptionFromTranscript(transcricao) {
          if (!sbarRecordBtn) return;

          sbarRecordBtn.classList.add("generating");
          sbarRecordBtn.disabled = true;

          if (sbarStatus) {
            sbarStatus.textContent = "Gerando SBAR...";
            sbarStatus.classList.add("loading-dot");
          }

          try {
            const resp = await fetch(BACKEND_URL + "/api/gerar-sbar", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ transcricao })
            });

            if (!resp.ok) {
              const txt = await resp.text().catch(() => "");
              console.error("Erro HTTP do backend (SBAR):", resp.status, txt);
              if (sbarStatus) {
                sbarStatus.textContent = "Não foi possível gerar o SBAR.";
                sbarStatus.classList.remove("loading-dot");
              }
              return;
            }

            const data = await resp.json().catch(() => null);
            const texto = (data && (data.sbar || data.passagem_plantao || data.passagem_plantao_sbar || data.prescricao_hospitalar || data.texto)) ? String(data.sbar || data.passagem_plantao || data.passagem_plantao_sbar || data.prescricao_hospitalar || data.texto).trim() : "";
            if (!texto) {
              console.error("Resposta inválida do backend (SBAR):", data);
              if (sbarStatus) {
                sbarStatus.textContent = "Resposta inválida ao gerar o SBAR.";
                sbarStatus.classList.remove("loading-dot");
              }
              return;
            }

            if (sbarOutput) sbarOutput.value = texto;
            if (sbarStatus) {
              sbarStatus.textContent = "SBAR gerado.";
              sbarStatus.classList.remove("loading-dot");
            }
          } catch (err) {
            console.error("Erro ao gerar SBAR:", err);
            if (sbarStatus) {
              sbarStatus.textContent = "Erro ao gerar SBAR.";
              sbarStatus.classList.remove("loading-dot");
            }
          } finally {
            stopSbarTimer();
            if (sbarRecordBtn) {
              sbarRecordBtn.classList.remove("generating");
              sbarRecordBtn.classList.remove("recording");
              sbarRecordBtn.classList.add("start");
              sbarRecordBtn.textContent = "Iniciar passagem de plantão (SBAR)";
              sbarRecordBtn.disabled = false;
            }
          }
        }

    function formatClassificationList(items) {
      if (!Array.isArray(items) || !items.length) {
        return "Nenhum conteúdo disponível.";
      }
      const lines = [];
      for (const it of items) {
        const med = (it && it.medicamento) ? String(it.medicamento) : "não informado";
        const cat = (it && it.categoria) ? String(it.categoria) : "NA";
        const desc = (it && it.descricao) ? String(it.descricao) : "categoria não informada (dados insuficientes)";
        if (cat === "NA") {
          lines.push(med + ": categoria não informada (dados insuficientes)");
        } else {
          lines.push(med + ": " + cat + " (" + desc + ")");
        }
      }
      return lines.join("\n");
    }

    async function updateClassifications() {
      classificationsStatus.textContent = "";

      const contexto = getNursingContext();
      if (!contexto) {
        pregnancyBox.textContent = "Nenhum conteúdo disponível.";
        lactationBox.textContent = "Nenhum conteúdo disponível.";
        return;
      }

      classificationsStatus.textContent = "Gerando SAE e orientações...";
      classificationsStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/classificar-gestacao-lactacao", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ contexto })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP:", resp.status, txt);
          pregnancyBox.textContent = "Falha ao gerar SAE.";
          lactationBox.textContent = "Falha ao gerar orientações.";
          return;
        }

        const data = await resp.json().catch(() => ({}));
        pregnancyBox.textContent = (data.sae || "").trim() || "Nenhum conteúdo disponível.";
        lactationBox.textContent = (data.orientacoes || "").trim() || "Nenhum conteúdo disponível.";
      } catch (e) {
        console.error(e);
        pregnancyBox.textContent = "Falha ao gerar SAE (rede/backend).";
        lactationBox.textContent = "Falha ao gerar orientações (rede/backend).";
      } finally {
        classificationsStatus.classList.remove("loading-dot");
        classificationsStatus.textContent = "";
      }
    }

    let reportTimerInterval = null;
    let reportTimerSeconds = 0;

    function formatSecondsMMSS(totalSeconds) {
      const secs = Math.max(0, Number(totalSeconds) || 0);
      const m = ("0" + Math.floor(secs / 60)).slice(-2);
      const s = ("0" + (secs % 60)).slice(-2);
      return `${m}:${s}`;
    }

    function updateReportStatusTimer() {
      if (!reportIsRecording) return;
      const mmss = formatSecondsMMSS(reportTimerSeconds);
      reportStatus.textContent = `Gravando relatório... ${mmss}`;
    }

    function startReportStatusTimer() {
      reportTimerSeconds = 0;
      if (reportTimerInterval) clearInterval(reportTimerInterval);
      updateReportStatusTimer();
      reportTimerInterval = setInterval(() => {
        reportTimerSeconds += 1;
        updateReportStatusTimer();
      }, 1000);
    }

    function stopReportStatusTimer() {
      if (reportTimerInterval) clearInterval(reportTimerInterval);
      reportTimerInterval = null;
    }


    function initReportSpeech() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        reportStatus.textContent =
          "Seu navegador não suporta reconhecimento de voz. Use Google Chrome em um computador.";
        return null;
      }

      const rec = new SR();
      rec.lang = "pt-BR";
      rec.continuous = true;
      rec.interimResults = true;

      rec.onresult = (event) => {
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            reportFinalTranscript += transcript + " ";
          }
        }
      };

      rec.onerror = (event) => {
        console.error("Erro no reconhecimento do relatório:", event.error);
        reportStatus.textContent =
          "Ocorreu um erro no reconhecimento de voz do relatório. Tente novamente.";
      };

      rec.onend = () => {
        if (reportIsRecording && !reportIsPaused) {
          try {
            rec.start();
          } catch (err) {
            console.warn("Não foi possível retomar reconhecimento do relatório:", err);
          }
        }
      };

      return rec;
    }

    async function startReportRecording() {
      reportStatus.textContent = "";
      reportOutput.value = "";
      reportFinalTranscript = "";
      updateReportActions();
      if (reportDocTypeDetected) reportDocTypeDetected.textContent = "";
      if (reportMissingFields) reportMissingFields.textContent = "";

      if (!reportRecognition) {
        reportRecognition = initReportSpeech();
        if (!reportRecognition) return;
      }

      reportIsRecording = true;
      reportIsPaused = false;

      reportRecordBtn.className = "small-record-btn recording";
      reportRecordBtn.innerText = "Encerrar gravação";
      reportStatus.textContent = "Gravando documento...";
      reportStatus.classList.remove("loading-dot");
      reportStatus.classList.add("loading-dot");

      startReportStatusTimer();

      try {
        reportRecognition.start();
      } catch (e) {
        console.warn("Erro ao iniciar reconhecimento do relatório:", e);
      }
    }

    async function stopReportRecordingAndGenerate() {
      reportIsRecording = false;
      reportIsPaused = false;

      if (reportRecognition) {
        try {
          reportRecognition.stop();
        } catch (e) {
          console.warn("Erro ao parar reconhecimento do relatório:", e);
        }
      }

      stopReportStatusTimer();

      reportRecordBtn.className = "small-record-btn start";
      reportRecordBtn.innerText = "Gravar documento";

      const transcricao = reportFinalTranscript.trim();
      if (!transcricao) {
        reportStatus.classList.remove("loading-dot");
        reportStatus.textContent = "Nenhuma fala foi capturada no relatório.";
        return;
      }

      reportStatus.textContent = "Gerando documento...";
      reportStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/gerar-relatorio", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (relatório):", resp.status, txt);
          reportStatus.textContent = "Não foi possível gerar o relatório.";
          reportStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const documento = (data && (data.documento || data.relatorio)) ? String(data.documento || data.relatorio) : "";
        const tipoIdentificado = (data && data.tipo_documento) ? String(data.tipo_documento) : "";
        const pendentes = Array.isArray(data?.campos_pendentes) ? data.campos_pendentes : (Array.isArray(data?.campos_faltantes) ? data.campos_faltantes : []);

        if (reportDocTypeDetected) reportDocTypeDetected.textContent = tipoIdentificado ? tipoIdentificado : "não informado";
        if (reportMissingFields) reportMissingFields.textContent = pendentes.length ? pendentes.join("\n") : "Nenhum";

        reportOutput.value = normalizeNumberedParagraphs(documento);
        updateReportActions();

        reportStatus.textContent = documento ? "Documento gerado." : "Não foi possível gerar o documento.";
        reportStatus.classList.remove("loading-dot");
      } catch (err) {
        console.error("Erro ao gerar relatório:", err);
        reportStatus.textContent = "Erro ao gerar relatório.";
        reportStatus.classList.remove("loading-dot");
        updateReportActions();
      }
    }

    async function submitMedicalDoubt() {
      const q = (medicalDoubtInput.value || "").trim();
      if (!q) return;

      medicalDoubtStatus.textContent = "Respondendo dúvida...";
      medicalDoubtStatus.classList.add("loading-dot");
      medicalDoubtAnswer.textContent = "";

      try {
        const resp = await fetch(BACKEND_URL + "/api/duvidas-medicas", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ duvida: q })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (dúvidas):", resp.status, txt);
          medicalDoubtStatus.textContent = "Não foi possível responder a dúvida.";
          medicalDoubtStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const resposta = data.resposta || "";
        medicalDoubtAnswer.textContent = resposta || "Sem resposta disponível.";
        medicalDoubtStatus.textContent = "Resposta gerada.";
        medicalDoubtStatus.classList.remove("loading-dot");
      } catch (err) {
        console.error("Erro ao responder dúvida:", err);
        medicalDoubtStatus.textContent = "Erro ao responder a dúvida.";
        medicalDoubtStatus.classList.remove("loading-dot");
      }
    }

    // Dúvidas em Saúde: Enter e botão Enviar
if (medicalDoubtInput) {
  medicalDoubtInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      submitMedicalDoubt();
    }
  });
}

if (medicalDoubtSendBtn) {
  medicalDoubtSendBtn.addEventListener("click", () => {
    submitMedicalDoubt();
  });
}


if (triageRecordBtn) {
  triageRecordBtn.onclick = () => {
    if (!triageIsRecording) {
      startTriageRecording();
    } else {
      stopTriageRecording();
      finalizarTriagemHospitalar();
    }
  };
}

if (triagePauseBtn) {
  triagePauseBtn.onclick = () => {
    if (!triageIsRecording) return;
    if (!triageIsPaused) pauseTriageRecording();
    else resumeTriageRecording();
  };
}

if (triageCopyFullBtn) {
  triageCopyFullBtn.addEventListener("click", () => {
    const text = (triageFullReport && triageFullReport.value) ? triageFullReport.value.trim() : "";
    if (!text) {
      alert("Não há relatório de triagem para copiar.");
      return;
    }
    copyToClipboard(text);
  });
}

if (triagePrintFullBtn) {
  triagePrintFullBtn.addEventListener("click", () => {
    const text = (triageFullReport && triageFullReport.value) ? triageFullReport.value : "";
    openPrintWindow("Relatório de triagem hospitalar", text);
  });
}

if (triageCopyProntuarioBtn) {
  triageCopyProntuarioBtn.addEventListener("click", () => {
    const text = (triageProntuario && triageProntuario.value) ? triageProntuario.value.trim() : "";
    if (!text) {
      alert("Não há texto de prontuário para copiar.");
      return;
    }
    copyToClipboard(text);
  });
}

if (triagePrintProntuarioBtn) {
  triagePrintProntuarioBtn.addEventListener("click", () => {
    const text = (triageProntuario && triageProntuario.value) ? triageProntuario.value : "";
    openPrintWindow("Texto para prontuário - Triagem", text);
  });
}

if (triageCopyPassagemBtn) {
  triageCopyPassagemBtn.addEventListener("click", () => {
    const text = (triagePassagemMedico && triagePassagemMedico.value) ? triagePassagemMedico.value.trim() : "";
    if (!text) {
      alert("Não há passagem ao médico para copiar.");
      return;
    }
    copyToClipboard(text);
  });
}

if (triagePrintPassagemBtn) {
  triagePrintPassagemBtn.addEventListener("click", () => {
    const text = (triagePassagemMedico && triagePassagemMedico.value) ? triagePassagemMedico.value : "";
    openPrintWindow("Passagem rápida ao médico - Triagem", text);
  });
}

recordBtn.onclick = () => {
      if (!isRecording) {
        startRecording();
      } else {
        stopRecording();
        finalizarConsulta();
      }
    };

    pauseBtn.onclick = () => {
      if (!isRecording) return;
      if (!isPaused) {
        pauseRecording();
      } else {
        resumeRecording();
      }
    };

    printBtn.onclick = () => {
      openPrintWindow("Plano de Cuidados (Prescrição de Enfermagem)", prescriptionOutput.value);
    };

    recommendationsBtn.addEventListener("click", () => {
      fetchRecommendations();
    });

    closeRecommendationsBtn.addEventListener("click", () => {
      if (questionsIsRecording) {
        recommendationsStatus.textContent =
          "Finalize a gravação das perguntas clicando em \"Encerrar perguntas\" antes de fechar.";
        return;
      }
      recommendationsPanel.classList.remove("visible");
    });

    askQuestionsBtn.addEventListener("click", () => {
      handleAskQuestionsFromPanel();
    });

    soapCopyButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const part = btn.getAttribute("data-part");
        const sectionText = getSoapSectionText(part);
        if (!sectionText) {
          alert("Seção " + part + " está vazia.");
          return;
        }
        copyToClipboard(part + ": " + sectionText);
      });

    if (copyFullSoapBtn) {
      copyFullSoapBtn.addEventListener("click", () => {
        const full = getCombinedSoapFromFields();
        if (!full.trim()) {
          alert("Não há SOAP disponível para copiar.");
          return;
        }
        copyToClipboard(full);
      });
    }

    if (printSoapBtn) {
      printSoapBtn.addEventListener("click", () => {
        const full = getCombinedSoapFromFields();
        openPrintWindow("SOAP", full);
      });
    }

    copyPrescriptionBtn.addEventListener("click", () => {
      const text = prescriptionOutput.value.trim();
      if (!text) {
        alert("Não há prescrição para copiar.");
        return;
      }
      copyToClipboard(text);
    });
    if (sbarRecordBtn) {
      sbarRecordBtn.addEventListener("click", async (e) => {
        e.preventDefault();
        if (!sbarIsRecording) {
          await startSbarRecording();
        } else {
          await stopSbarRecordingAndGenerate();
        }
      });
    }

    // Relatórios de Enfermagem / Encaminhamentos etc.
    if (reportRecordBtn) {
      reportRecordBtn.addEventListener("click", async (e) => {
        e.preventDefault();
        if (!reportIsRecording) {
          startReportRecording();
        } else {
          await stopReportRecordingAndGenerate();
        }
      });
    }

    if (copyReportBtn) {
      copyReportBtn.addEventListener("click", (e) => {
        e.preventDefault();
        const t = reportOutput && reportOutput.value ? reportOutput.value.trim() : "";
        if (!t) {
          alert("Não há documento para copiar.");
          return;
        }
        copyToClipboard(t);
      });
    }

    if (printReportBtn) {
      printReportBtn.addEventListener("click", (e) => {
        e.preventDefault();
        const t = reportOutput && reportOutput.value ? reportOutput.value.trim() : "";
        if (!t) {
          alert("Não há documento para imprimir.");
          return;
        }
        openPrintWindow("Documento", t);
      });
    }
    copySbarBtn.addEventListener("click", () => {
      const text = sbarOutput.value.trim();
      if (!text) {
        alert("Não há SBAR para copiar.");
        return;
      }
      copyToClipboard(text);
    });

    printSbarBtn.addEventListener("click", () => {
      openPrintWindow("Passagem de Plantão (SBAR)", sbarOutput.value);
    });

    if (printRiskTriageBtn) {
      printRiskTriageBtn.addEventListener("click", () => {
        const text = (riskTriageMeaning && riskTriageMeaning.dataset && riskTriageMeaning.dataset.printText) ? riskTriageMeaning.dataset.printText : "";
        openPrintWindow("Classificação de risco por cores", text);
      });
    }

    
    if (copySaeBtn) {
      copySaeBtn.addEventListener("click", () => {
        const text = (pregnancyBox && pregnancyBox.textContent) ? pregnancyBox.textContent.trim() : "";
        if (!text) {
          alert("Não há SAE para copiar.");
          return;
        }
        copyToClipboard(text);
      });
    }

    if (copyOrientationsBtn) {
      copyOrientationsBtn.addEventListener("click", () => {
        const text = (lactationBox && lactationBox.textContent) ? lactationBox.textContent.trim() : "";
        if (!text) {
          alert("Não há orientações para copiar.");
          return;
        }
        copyToClipboard(text);
      });
    }

    if (copyRiskTriageBtn) {
      copyRiskTriageBtn.addEventListener("click", () => {
        const text = (riskTriageMeaning && riskTriageMeaning.dataset && riskTriageMeaning.dataset.printText) ? riskTriageMeaning.dataset.printText : "";
        if (!text.trim()) {
          alert("Não há classificação de risco para copiar.");
          return;
        }
        copyToClipboard(text);
      });
    }
    });

    printPregnancyBtn.addEventListener("click", () => {
      openPrintWindow("SAE (Processo de Enfermagem)", pregnancyBox.textContent);
    });

    printLactationBtn.addEventListener("click", () => {
      openPrintWindow("Orientações ao paciente", lactationBox.textContent);
    });


    if (chooseCameraBtn) {
  chooseCameraBtn.addEventListener("click", () => {
    const input = pendingCameraInput;
    if (input) input.click();
  });
}

    if (chooseFileBtn) {
  chooseFileBtn.addEventListener("click", () => {
    const input = pendingFileInput;
    if (input) input.click();
  });
}

if (clearChosenImagesBtn) {
  clearChosenImagesBtn.addEventListener("click", () => {
    clearPendingImages();
  });
}

if (runImageAnalysisBtn) {
  runImageAnalysisBtn.addEventListener("click", async () => {
    const fn = pendingAnalysisFn;
    const imgs = Array.isArray(pendingImages) ? pendingImages.slice() : [];
    hideImageChoice();
    if (fn && imgs.length) {
      await fn(imgs);
    }
  });
}

    // Estado inicial: botões de copiar/imprimir ficam ocultos até gerar conteúdo
    updateMedSafetyActions();
    updateWoundActions();
    updateReportActions();

    if (cancelImageChoiceBtn) {
      cancelImageChoiceBtn.addEventListener("click", () => {
        hideImageChoice();
      });
    }

    if (imageChoiceOverlay) {
      imageChoiceOverlay.addEventListener("click", (e) => {
        if (e.target === imageChoiceOverlay) hideImageChoice();
      });
    }

    if (woundPhotoBtn) {
      woundPhotoBtn.addEventListener("click", () => {
        if (woundCameraInput) woundCameraInput.click();
      });
    }

    if (woundFileBtn) {
      woundFileBtn.addEventListener("click", () => {
        if (woundFileInput) woundFileInput.click();
      });
    }
if (medPhotoBtn) {
      medPhotoBtn.addEventListener("click", () => {
        if (medCameraInput) medCameraInput.click();
      });
    }

    if (medFileBtn) {
      medFileBtn.addEventListener("click", () => {
        if (medFileInput) medFileInput.click();
      });
    }
function getImageUiByKey(key) {
      const k = String(key || "").toLowerCase();
      if (k === "wound") return { statusEl: presentationsMaxDoseStatus, boxEl: presentationsMaxDoseBox };
      if (k === "exam") return { statusEl: examInterpretationStatus, boxEl: examInterpretationBox };
      return { statusEl: interactionsStatus, boxEl: interactionsBox };
    }

    function bindImageInput(inputEl, key, mode) {
      if (!inputEl) return;

      const handler = async (e) => {
        const input = e && e.currentTarget ? e.currentTarget : inputEl;
        const files = (input && input.files) ? Array.from(input.files) : [];
        if (!files.length) return;

        const ui = getImageUiByKey(key);
        const firstName = (files[0] && files[0].name) ? files[0].name : "arquivo";
        const msg0 = `Arquivo recebido: ${firstName}. Preparando imagem.`;
        if (ui && ui.statusEl) ui.statusEl.textContent = msg0;

        // Evita que alguns navegadores invalidem o FileList ao limpar cedo demais.
        inputEl.disabled = true;
        try {
          await addFilesToTarget(files, key, mode);
        } catch (err) {
          const msg = "Erro ao processar a imagem selecionada. Tente JPG/PNG (ou refaça a foto) e confirme a conexão.";
          if (ui && ui.statusEl) ui.statusEl.textContent = msg;
          if (ui && ui.boxEl) ui.boxEl.textContent = "Nenhum conteúdo disponível.";
        } finally {
          try { input.value = ""; } catch {}
          inputEl.disabled = false;
        }
      };

      // Alguns navegadores disparam 'input' em vez de 'change' em certos fluxos.
      inputEl.addEventListener("change", handler);
      inputEl.addEventListener("input", handler);
    }

if (woundCameraInput) bindImageInput(woundCameraInput, "wound", "append");
    if (woundFileInput) bindImageInput(woundFileInput, "wound", "replace");
    if (medCameraInput) bindImageInput(medCameraInput, "med", "append");
    if (medFileInput) bindImageInput(medFileInput, "med", "replace");
    if (examCameraInput) bindImageInput(examCameraInput, "exam", "append");
    if (examFileInput) bindImageInput(examFileInput, "exam", "replace");

    // =========================
    // ADMIN (cadastro, mensalidade, histórico e auditoria)
    // =========================

    function fmtDt(iso) {
      if (!iso) return "-";
      try { return new Date(iso).toLocaleString("pt-BR"); } catch { return String(iso); }
    }

    function fmtMoney(v) {
      try {
        const n = Number(v);
        if (!Number.isFinite(n)) return String(v ?? "");
        return n.toLocaleString("pt-BR", { style: "currency", currency: "BRL" });
      } catch {
        return String(v ?? "");
      }
    }

    function currentYYYYMM() {
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      return `${y}-${m}`;
    }

    async function adminFetchJson(path, options) {
      const resp = await fetch(BACKEND_URL + path, Object.assign({ method: "GET" }, options || {}));
      const data = await resp.json().catch(() => ({}));
      if (!resp.ok) throw new Error(data.error || ("Falha: " + resp.status));
      return data;
    }

    async function autoRecoverIfEmpty() {
      try {
        if (RECOVERY_RUNNING) return;
        if (RECOVERY_TRIED) return;
        const payload = getLocalBackupPayload();
        const hasUsers = payload && Array.isArray(payload.users) && payload.users.length > 0;
        if (!hasUsers) return;
        if (!Array.isArray(ADMIN_CACHE_USERS) || ADMIN_CACHE_USERS.length !== 0) return;

        RECOVERY_RUNNING = true;
        RECOVERY_TRIED = true;

        const st = document.getElementById("adminStatus");
        if (st) st.textContent = "Recuperando usuários a partir do backup local...";

        // Cria backup manual no servidor (se houver)
        try { await adminFetchJson("/api/admin/backup/create", { method: "POST" }); } catch {}

        await adminFetchJson("/api/admin/backup/import", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        await adminLoadAll();
        if (st) st.textContent = "Recuperação concluída a partir do backup local.";
      } catch (e) {
        const st = document.getElementById("adminStatus");
        if (st) st.textContent = "Falha ao recuperar do backup local: " + String(e?.message || e || "");
      } finally {
        RECOVERY_RUNNING = false;
        updateAdminLocalBackupBadge();
      }
    }

    async function adminLoadAll() {
      try {
        const [users, audit] = await Promise.all([
          adminFetchJson("/api/admin/users"),
          adminFetchJson("/api/admin/audit")
        ]);
        ADMIN_CACHE_USERS = Array.isArray(users.users) ? users.users : [];
        ADMIN_CACHE_AUDIT = Array.isArray(audit.audit) ? audit.audit : [];
        renderAdminUsers();
        renderAdminAudit();
        const sub = document.getElementById("adminSubtitle");
        if (sub) sub.textContent = `Usuários cadastrados: ${ADMIN_CACHE_USERS.length}`;
        const st = document.getElementById("adminStatus");
        if (st) st.textContent = "";
        updateAdminLocalBackupBadge();
        // Atualiza backup local com a versão do servidor (quando houver dados)
        if (ADMIN_CACHE_USERS.length > 0) { await refreshLocalBackupFromServer(); }
        // Se o servidor vier vazio (ex.: redeploy), tenta restaurar automaticamente do backup local
        await autoRecoverIfEmpty();
      } catch (e) {
        const st = document.getElementById("adminStatus");
        if (st) st.textContent = String(e.message || e);
      }
    }

    function renderAdminAudit() {
      const tbody = document.getElementById("auditTbody");
      if (!tbody) return;
      tbody.innerHTML = "";

      for (const a of ADMIN_CACHE_AUDIT.slice().reverse().slice(0, 200)) {
        const tr = document.createElement("tr");
        const tdReg = document.createElement("td");
        const tdAdm = document.createElement("td");

        const dt = fmtDt(a.at || a.paidAt);
        const user = [a.userName, a.userLogin].filter(Boolean).join(" - ");
        const parts = [];
        if (dt && dt !== "-") parts.push(dt);
        if (user) parts.push(user);
        if (a.month) parts.push("Mês: " + a.month);
        if (a.amount !== undefined && a.amount !== null && String(a.amount) !== "") parts.push("Valor: " + fmtMoney(a.amount));
        if (a.method) parts.push("Método: " + a.method);
        if (a.notes) parts.push("Obs: " + a.notes);

        tdReg.textContent = parts.join(" / ");
        tdAdm.textContent = a.receivedBy || a.admin || a.actor || "-";
        tr.appendChild(tdReg);
        tr.appendChild(tdAdm);
        tbody.appendChild(tr);
      }
    }

    function isOnline(lastSeenAt) {
      if (!lastSeenAt) return false;
      try {
        const t = new Date(lastSeenAt).getTime();
        return (Date.now() - t) <= (2 * 60 * 1000);
      } catch {
        return false;
      }
    }

    function renderAdminUsers() {
      const tbody = document.getElementById("usersTbody");
      if (!tbody) return;
      tbody.innerHTML = "";

      const q = (document.getElementById("adminSearch")?.value || "").trim().toLowerCase();
      const rows = ADMIN_CACHE_USERS.filter(u => {
        if (!q) return true;
        const s = `${u.fullName||""} ${u.login||""} ${u.phone||""}`.toLowerCase();
        return s.includes(q);
      });

      for (const u of rows) {
        const tr = document.createElement("tr");
        const active = (u && (u.isActive !== undefined ? !!u.isActive : !!u.active));

        const tdName = document.createElement("td");
        tdName.textContent = u.fullName || "-";

        const tdLogin = document.createElement("td");
        tdLogin.textContent = u.login || "-";

        const tdPhone = document.createElement("td");
        tdPhone.textContent = u.phone || "-";

        const tdOnline = document.createElement("td");
        const on = isOnline(u.lastSeenAt);
        const pillOn = document.createElement("span");
        pillOn.className = "pill " + (on ? "green" : "gray");
        pillOn.textContent = on ? "Online" : "Offline";
        tdOnline.appendChild(pillOn);

        const tdPay = document.createElement("td");
        const paid = (u && (u.isPaidThisMonth !== undefined ? !!u.isPaidThisMonth : !!u.paidCurrentMonth));
        const pillPay = document.createElement("button");
        pillPay.type = "button";
        pillPay.className = "pill " + (paid ? "green" : "red");
        pillPay.textContent = paid ? "Em dia" : "Em atraso";
        pillPay.title = "Clique para marcar pagamento do mês";
        pillPay.addEventListener("click", async () => {
          const month = prompt("Mês no formato AAAA-MM", currentYYYYMM());
          if (!month) return;
          const amount = prompt("Valor (opcional)", "");
          const method = prompt("Método (opcional)", "PIX");
          const notes = prompt("Observações (opcional)", "");
          try {
            await adminFetchJson(`/api/admin/users/${encodeURIComponent(u.id)}/pay`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ month, amount, method, notes })
            });
            await adminLoadAll();
            await refreshLocalBackupFromServer();
          } catch (e) {
            const st = document.getElementById("adminStatus");
            if (st) st.textContent = String(e.message || e);
          }
        });
        tdPay.appendChild(pillPay);

        const tdLast = document.createElement("td");
        tdLast.textContent = u.lastLoginAt ? fmtDt(u.lastLoginAt) : "-";

        const tdActions = document.createElement("td");
        const actions = document.createElement("div");
        actions.className = "admin-actions";

        const btnEdit = document.createElement("button");
        btnEdit.className = "admin-btn secondary";
        btnEdit.type = "button";
        btnEdit.textContent = "Editar";
        btnEdit.addEventListener("click", () => {
          openEditUserModal(u);
        });

        const btnHist = document.createElement("button");
        btnHist.className = "admin-btn secondary";
        btnHist.type = "button";
        btnHist.textContent = "Histórico";
        btnHist.addEventListener("click", async () => {
          try {
            const data = await adminFetchJson(`/api/admin/users/${encodeURIComponent(u.id)}/payments`);
            openPaymentsModal(u, data.payments || []);
          } catch (e) {
            const st = document.getElementById("adminStatus");
            if (st) st.textContent = String(e.message || e);
          }
        });

        const btnActive = document.createElement("button");
        btnActive.type = "button";
        btnActive.className = "pill " + (active ? "green" : "red");
        btnActive.textContent = active ? "Ativado" : "Desativado";
        btnActive.title = "Clique para ativar/desativar. Se desativado ou em débito, o acesso do usuário será bloqueado.";
        btnActive.addEventListener("click", async () => {
          try {
            await adminFetchJson(`/api/admin/users/${encodeURIComponent(u.id)}/active`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ active: !active })
            });
            await adminLoadAll();
            await refreshLocalBackupFromServer();
          } catch (e) {
            const st = document.getElementById("adminStatus");
            if (st) st.textContent = String(e.message || e);
          }
        });

        const btnReset = document.createElement("button");
        btnReset.className = "admin-btn secondary";
        btnReset.type = "button";
        btnReset.textContent = "Reset senha";
        btnReset.addEventListener("click", async () => {
          const newPass = prompt("Nova senha (será salva)", "");
          if (!newPass) return;
          try {
            await adminFetchJson(`/api/admin/users/${encodeURIComponent(u.id)}/reset-password`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ password: newPass })
            });
            await adminLoadAll();
            await refreshLocalBackupFromServer();
          } catch (e) {
            const st = document.getElementById("adminStatus");
            if (st) st.textContent = String(e.message || e);
          }
        });

        const btnDelete = document.createElement("button");
        btnDelete.className = "admin-btn danger";
        btnDelete.type = "button";
        btnDelete.textContent = "Excluir";
        btnDelete.addEventListener("click", async () => {
          if (!confirm("Excluir este usuário? O histórico de pagamentos será preservado.")) return;
          try {
            await adminFetchJson(`/api/admin/users/${encodeURIComponent(u.id)}`, { method: "DELETE" });
            await adminLoadAll();
            await refreshLocalBackupFromServer();
          } catch (e) {
            const st = document.getElementById("adminStatus");
            if (st) st.textContent = String(e.message || e);
          }
        });

        actions.appendChild(btnEdit);
        actions.appendChild(btnHist);
        actions.appendChild(btnActive);
        actions.appendChild(btnReset);
        actions.appendChild(btnDelete);
        tdActions.appendChild(actions);

        tr.appendChild(tdName);
        tr.appendChild(tdLogin);
        tr.appendChild(tdPhone);
        tr.appendChild(tdOnline);
        tr.appendChild(tdPay);
        tr.appendChild(tdLast);
        tr.appendChild(tdActions);

        tbody.appendChild(tr);
      }
    }

    function openPaymentsModal(user, payments) {
      const modal = document.getElementById("paymentsModal");
      const subtitle = document.getElementById("paymentsModalSubtitle");
      const tbody = document.getElementById("paymentsTbody");
      if (!modal || !tbody) return;
      if (subtitle) subtitle.textContent = `${user.fullName || "-"} • ${user.login || "-"}`;

      tbody.innerHTML = "";
      const list = Array.isArray(payments) ? payments.slice().reverse() : [];
      for (const p of list) {
        const tr = document.createElement("tr");
        const tdM = document.createElement("td");
        const tdAt = document.createElement("td");
        const tdAm = document.createElement("td");
        const tdMe = document.createElement("td");
        const tdNo = document.createElement("td");
        tdM.textContent = p.month || "-";
        tdAt.textContent = fmtDt(p.paidAt);
        tdAm.textContent = (p.amount !== undefined && p.amount !== null && String(p.amount).trim() !== "") ? String(p.amount) : "-";
        tdMe.textContent = p.method || "-";
        tdNo.textContent = p.notes || "-";
        tr.appendChild(tdM); tr.appendChild(tdAt); tr.appendChild(tdAm); tr.appendChild(tdMe); tr.appendChild(tdNo);
        tbody.appendChild(tr);
      }

      modal.classList.remove("hidden");
    }

        // =========================
    // EDITAR USUÁRIO (ADMIN)
    // =========================
    let EDIT_USER_ID = null;

    function openEditUserModal(user) {
      EDIT_USER_ID = user?.id || null;
      document.getElementById("editUserSubtitle").textContent = `${user.fullName || "-"} • ${user.login || "-"}`;

      document.getElementById("editFullName").value = user.fullName || "";
      document.getElementById("editDob").value = user.dob || "";
      document.getElementById("editPhone").value = user.phone || "";
      document.getElementById("editLogin").value = user.login || "";
      document.getElementById("editPassword").value = "";

      document.getElementById("editUserModal").classList.remove("hidden");
    }

    function closeEditUserModal() {
      EDIT_USER_ID = null;
      document.getElementById("editUserModal")?.classList.add("hidden");
    }

    document.getElementById("cancelEditUserBtn")?.addEventListener("click", closeEditUserModal);

    document.getElementById("saveEditUserBtn")?.addEventListener("click", async () => {
      try {
        if (!EDIT_USER_ID) throw new Error("Usuário inválido.");
        const fullName = (document.getElementById("editFullName")?.value || "").trim();
        const dob = (document.getElementById("editDob")?.value || "").trim();
        const phone = (document.getElementById("editPhone")?.value || "").trim();
        const login = (document.getElementById("editLogin")?.value || "").trim();
        const password = (document.getElementById("editPassword")?.value || "").trim();

        if (!fullName || !dob || !phone || !login) {
          alert("Preencha: nome completo, data de nascimento, telefone e login.");
          return;
        }

        await adminFetchJson(`/api/admin/users/${encodeURIComponent(EDIT_USER_ID)}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ fullName, dob, phone, login, password })
        });

        closeEditUserModal();
        await adminLoadAll();
            await refreshLocalBackupFromServer();
      } catch (e) {
        alert(String(e?.message || e || "Falha ao editar usuário."));
      }
    });

document.getElementById("closePaymentsBtn")?.addEventListener("click", () => {
      document.getElementById("paymentsModal")?.classList.add("hidden");
    });

    document.getElementById("adminSearch")?.addEventListener("input", renderAdminUsers);

    document.getElementById("adminRefreshBtn")?.addEventListener("click", adminLoadAll);

    document.getElementById("adminBackupBtn")?.addEventListener("click", async () => {
      try {
        // Usa o token salvo em sessão (localStorage) e o wrapper de fetch já injeta Authorization
        const t = getToken();
        if (!t) throw new Error("Sessão inválida. Faça login novamente.");

        const resp = await fetch(BACKEND_URL + "/api/admin/backup/export", { method: "GET" });
        const ct = resp.headers.get("content-type") || "";

        if (!resp.ok) {
          let msg = "Falha ao exportar.";
          try {
            if (ct.includes("application/json")) {
              const j = await resp.json();
              msg = j?.error || msg;
            } else {
              msg = (await resp.text()) || msg;
            }
          } catch {}
          throw new Error(msg);
        }

        const blob = await resp.blob();
        const a = document.createElement("a");
        const url = URL.createObjectURL(blob);
        a.href = url;
        a.download = `backup-enfermagem-${new Date().toISOString().slice(0,10)}.json`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 1500);

        // Atualiza o cache local do backup para contingência
        try {
          const txt = await (await fetch(BACKEND_URL + "/api/admin/backup/export", { method: "GET" })).text();
          if (txt && txt.trim().startsWith("{")) {
            setLocalBackupText(txt);
            updateAdminLocalBackupBadge();
          }
        } catch {}
      } catch (e) {
        alert(e?.message || "Erro ao baixar backup.");
      }
    });

    document.getElementById("adminRestoreBtn")?.addEventListener("click", async () => {
      const input = document.getElementById("adminRestoreFile");
      if (input) input.click();
    });

    document.getElementById("adminRestoreFile")?.addEventListener("change", async (ev) => {
      try {
        const file = ev.target?.files?.[0];
        if (!file) return;
        if (!confirm("Restaurar/mesclar este backup? Isso não apaga histórico; apenas recupera/mescla dados.")) {
          ev.target.value = "";
          return;
        }

        // cria um backup manual antes de restaurar
        try { await adminFetchJson("/api/admin/backup/create", { method: "POST" }); } catch {}

        const txt = await file.text();
        const payload = JSON.parse(txt);

        await adminFetchJson("/api/admin/backup/import", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        ev.target.value = "";
        await adminLoadAll();
        await refreshLocalBackupFromServer();
        alert("Backup importado/mesclado com sucesso.");
      } catch (e) {
        alert(String(e?.message || e || "Falha ao restaurar backup."));
      }
    });


    document.getElementById("createUserBtn")?.addEventListener("click", async () => {
      const fullName = (document.getElementById("newFullName")?.value || "").trim();
      const dob = (document.getElementById("newDob")?.value || "").trim();
      const phone = (document.getElementById("newPhone")?.value || "").trim();
      const login = (document.getElementById("newLogin")?.value || "").trim();
      const password = (document.getElementById("newPassword")?.value || "").trim();
      const st = document.getElementById("createUserStatus");
      if (!fullName || !dob || !phone || !login || !password) {
        if (st) st.textContent = "Preencha nome completo, data de nascimento, telefone, login e senha.";
        return;
      }
      if (st) st.textContent = "Cadastrando...";
      try {
        await adminFetchJson("/api/admin/users", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ fullName, dob, phone, login, password })
        });
        if (st) st.textContent = "Usuário cadastrado.";
        // Limpa campos
        ["newFullName","newDob","newPhone","newLogin","newPassword"].forEach(id => {
          const el = document.getElementById(id);
          if (el) el.value = "";
        });
        await adminLoadAll();
            await refreshLocalBackupFromServer();
      } catch (e) {
        if (st) st.textContent = String(e.message || e);
      }
    });

    // Inicializa a sessão ao carregar
    restoreSession();

    // Failsafe: se nenhuma view estiver visível após 1s, mostra login
    setTimeout(() => {
      const lv = document.getElementById("loginView");
      const av = document.getElementById("adminView");
      const nv = document.getElementById("nurseView");
      const anyVisible = (lv && !lv.classList.contains("hidden")) || (av && !av.classList.contains("hidden")) || (nv && !nv.classList.contains("hidden"));
      if (!anyVisible) showLogin();
    }, 1000);



    

    // ============================
    // MÓDULO: Guias de consulta (nurseView)
    // ============================
    (function initConsultGuides() {
      const consultButtons = Array.from(document.querySelectorAll(".consult-type-btn"));
      const drawer = document.getElementById("consultGuideDrawer");
      const titleEl = document.getElementById("consultGuideTitle");
      const subtitleEl = document.getElementById("consultGuideSubtitle");
      const contentEl = document.getElementById("consultGuideContent");
      const closeBtn = document.getElementById("closeConsultGuideBtn");
      const prenatalTriRow = document.getElementById("prenatalTrimesterRow");
      const triBtns = Array.from(document.querySelectorAll(".trimester-btn"));

      if (!consultButtons.length || !drawer || !titleEl || !subtitleEl || !contentEl || !closeBtn || !prenatalTriRow) return;

      function esc(s) {
        return String(s ?? "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      const GUIDE = {
        prenatal: {
          title: "Consulta pré-natal por trimestre",
          subtitle: "Roteiro prático com linguagem direta e detalhada, baseado nas recomendações do Ministério da Saúde. Ajuste conforme risco gestacional e protocolos locais.",
          trimester: {
            1: {
              subtitle: "1º trimestre (até 13 semanas + 6 dias)",
              html: `
                <h4>Objetivos</h4>
                <ul>
                  <li>Confirmar gestação, estimar idade gestacional, identificar riscos e organizar o plano de pré-natal.</li>
                  <li>Garantir que a gestante entenda como será o acompanhamento, quais exames serão feitos e quando retornar.</li>
                </ul>

                <h4>Perguntas essenciais (anamnese)</h4>
                <ul>
                  <li>Data da última menstruação (DUM) e regularidade do ciclo; dúvidas sobre a data.</li>
                  <li>Gestas/partos/abortos anteriores, cesáreas, complicações (preeclâmpsia, hemorragia, prematuridade, DMG, infecções).</li>
                  <li>Doenças prévias: hipertensão, diabetes, tireoide, epilepsia, cardiopatias, trombose, asma, doenças renais.</li>
                  <li>Uso de medicamentos, álcool, tabaco, outras drogas; alergias.</li>
                  <li>Sintomas atuais: náuseas/vômitos intensos, dor abdominal, febre, sangramento, corrimento, disúria.</li>
                  <li>Condições sociais e de segurança: suporte familiar, trabalho, violência, acesso ao serviço.</li>
                </ul>

                <h4>Exame físico e obstétrico (passo a passo)</h4>
                <ul>
                  <li>Pressão arterial, peso, altura, IMC e ganho de peso esperado.</li>
                  <li>Avaliar edema, sinais de anemia, tireoide, mamas e cavidade oral conforme necessidade.</li>
                  <li>Exame obstétrico conforme idade gestacional: altura uterina (quando aplicável) e ausculta de BCF (quando possível).</li>
                </ul>

                <h4>Exames recomendados (rotina mínima do MS)</h4>
                <ul>
                  <li>ABO-Rh e hemoglobina/hematócrito na primeira consulta.</li>
                  <li>Glicemia de jejum na primeira consulta.</li>
                  <li>VDRL (sífilis) na primeira consulta.</li>
                  <li>Urina tipo 1 na primeira consulta.</li>
                  <li>Teste anti-HIV na primeira consulta.</li>
                  <li>Sorologia para toxoplasmose na primeira consulta (se disponível).</li>
                </ul>

                <h4>O que explicar para quem não entende nada</h4>
                <ul>
                  <li><b>Por que tantos exames?</b> Eles servem para descobrir cedo problemas que podem não dar sintoma (anemia, diabetes, sífilis, HIV, infecção urinária).</li>
                  <li><b>O que acontece se der alterado?</b> A equipe orienta o tratamento e faz acompanhamento mais de perto para proteger mãe e bebê.</li>
                </ul>
              `
            },
            2: {
              subtitle: "2º trimestre (14 a 27 semanas + 6 dias)",
              html: `
                <h4>Objetivos</h4>
                <ul>
                  <li>Acompanhar crescimento do bebê e saúde da gestante.</li>
                  <li>Rastrear diabetes gestacional no período recomendado.</li>
                </ul>

                <h4>O que perguntar e registrar</h4>
                <ul>
                  <li>Sintomas de alarme: sangramento, perda de líquido, febre, dor forte, redução de movimentos fetais (quando já perceptíveis).</li>
                  <li>Sintomas urinários (ardor ao urinar, urgência, dor lombar), cefaleia importante, alteração visual, dor no “boca do estômago”.</li>
                  <li>Adesão a ferro/ácido fólico (se prescritos), alimentação e atividade física.</li>
                </ul>

                <h4>Exame físico e obstétrico (rotina)</h4>
                <ul>
                  <li>Pressão arterial e peso em toda consulta.</li>
                  <li>Altura uterina, ausculta de BCF e avaliação de edema conforme evolução.</li>
                </ul>

                <h4>Exames recomendados</h4>
                <ul>
                  <li>Se a glicemia de jejum do início estiver normal, realizar entre 24 e 28 semanas o Teste Oral de Tolerância à Glicose (TOTG) para investigar diabetes gestacional.</li>
                  <li>Manter atenção para sinais e sintomas que indiquem necessidade de repetir urina e investigar infecção urinária.</li>
                </ul>

                <h4>Como explicar o TOTG (bem simples)</h4>
                <ul>
                  <li>É um exame para ver como o corpo “lida com açúcar”. A gestante fica em jejum, colhe sangue, toma uma solução doce e faz novas coletas.</li>
                  <li>Ele é feito nesse período porque é quando a gravidez pode “desencadear” diabetes gestacional, mesmo em quem nunca teve.</li>
                </ul>
              `
            },
            3: {
              subtitle: "3º trimestre (28 semanas até o parto)",
              html: `
                <h4>Objetivos</h4>
                <ul>
                  <li>Reforçar segurança materno-fetal, planejar parto e identificar precocemente complicações.</li>
                  <li>Repetir exames de rastreio no momento recomendado pelo MS.</li>
                </ul>

                <h4>Exames recomendados (rotina mínima do MS)</h4>
                <ul>
                  <li>Glicemia de jejum próxima à 30ª semana.</li>
                  <li>VDRL (sífilis) próximo à 30ª semana.</li>
                  <li>Urina tipo 1 próxima à 30ª semana.</li>
                  <li>Teste anti-HIV próximo à 30ª semana (sempre que possível).</li>
                  <li>HBsAg (hepatite B) de preferência próximo à 30ª semana (se disponível).</li>
                </ul>

                <h4>O que perguntar e orientar</h4>
                <ul>
                  <li>Movimentos fetais, contrações, sangramento, perda de líquido, febre.</li>
                  <li>Sinais de gravidade: dor de cabeça forte, visão embaçada, falta de ar, dor intensa no abdome superior, inchaço importante.</li>
                  <li>Plano de parto: local de referência, documentos, sinais para ir à maternidade, transporte.</li>
                </ul>

                <h4>Explicação simples para a paciente</h4>
                <ul>
                  <li>“Vamos repetir alguns exames porque, mesmo que antes estivesse tudo normal, algumas infecções e alterações podem aparecer mais tarde e precisam ser tratadas a tempo.”</li>
                </ul>
              `
            }
          }
        },

        puericultura: {
          title: "Consulta puericultura",
          subtitle: "Roteiro prático com o que observar, perguntar e quais testes/triagens devem estar em dia.",
          html: `
            <h4>Quando acompanhar (consultas de rotina)</h4>
            <ul>
              <li>Consulta na primeira semana de vida (muito importante para avaliar mãe e bebê).</li>
              <li>Consultas de rotina: 1, 2, 4, 6, 9, 12, 18 e 24 meses; após 2 anos, pelo menos 1 vez ao ano (ou mais, se necessário).</li>
            </ul>

            <h4>Triagens (testes) que devem estar registrados</h4>
            <ul>
              <li>Teste do pezinho: idealmente entre o 3º e 5º dia de vida.</li>
              <li>Teste da orelhinha: entre 24 e 48 horas após o nascimento e, no máximo, durante o 1º mês.</li>
              <li>Teste do coraçãozinho: oximetria de pulso após 24 horas de vida (geralmente na maternidade).</li>
              <li>Teste do olhinho: triagem ocular no recém-nascido (registrar resultado e encaminhar se alterado).</li>
            </ul>

            <h4>O que fazer na consulta (bem detalhado)</h4>
            <ul>
              <li>Medir peso, comprimento/estatura e perímetro cefálico (quando aplicável), e comparar com as curvas.</li>
              <li>Perguntar sobre alimentação: aleitamento materno (exclusivo ou não), dificuldades para mamar, vômitos, diarreia, constipação.</li>
              <li>Checar vacinação: comparar com o Calendário Nacional e orientar próximas doses.</li>
              <li>Avaliar desenvolvimento: olhar, sorriso, controle de cabeça, sentar, engatinhar, andar, fala e interação, conforme a idade.</li>
              <li>Exame físico: pele, respiração, coração, abdome, quadril (quando indicado), olhos, ouvidos, boca, genitália, coluna, tônus.</li>
              <li>Orientar sinais de alarme: febre em recém-nascido, dificuldade para respirar, recusa alimentar persistente, sonolência excessiva, vômitos em jato, sangue nas fezes, icterícia intensa.</li>
            </ul>
          `
        },

        planejamento: {
          title: "Consulta planejamento familiar",
          subtitle: "Roteiro para orientar escolha do método contraceptivo com segurança e linguagem simples.",
          html: `
            <h4>Passo 1: entender o objetivo da pessoa</h4>
            <ul>
              <li>Quer evitar gravidez agora? Por quanto tempo? Quer engravidar em breve?</li>
              <li>Tem parceiro(a)? Usa preservativo? Há risco de IST?</li>
              <li>Já usou algum método? Teve efeitos colaterais? Está satisfeita?</li>
            </ul>

            <h4>Passo 2: checagem de segurança (antes de indicar um método)</h4>
            <ul>
              <li>Medir pressão arterial e peso/IMC.</li>
              <li>Perguntar sobre enxaqueca com aura, trombose, câncer de mama, hepatopatias, sangramento uterino inexplicado, tabagismo (principalmente &gt; 35 anos).</li>
              <li>Se houver chance de gravidez, orientar teste de gravidez e/ou critérios clínicos para excluir gestação.</li>
            </ul>

            <h4>Exames: o que é rotina e o que é por indicação</h4>
            <ul>
              <li>Em geral, a consulta se baseia em história e exame físico (especialmente pressão). Exames laboratoriais não são exigência “para todo mundo” e devem ser solicitados quando houver indicação clínica.</li>
              <li>Para DIU, deve haver avaliação clínica e ginecológica conforme protocolos do serviço; se houver risco de IST, orientar investigação e manejo.</li>
              <li>Citopatológico (preventivo) deve seguir o protocolo do rastreamento do colo do útero; não é “obrigatório” para iniciar todos os métodos, mas deve estar em dia conforme idade/intervalo.</li>
            </ul>

            <h4>Explicação simples dos métodos (para leigos)</h4>
            <ul>
              <li><b>Preservativo:</b> protege contra gravidez e IST. Precisa usar em todas as relações.</li>
              <li><b>Pílula/adesivo/anel (com hormônio):</b> muito eficaz se usado certo; pode ter restrições em quem tem risco de trombose ou pressão alta descontrolada.</li>
              <li><b>Injetável:</b> aplicação mensal ou trimestral; pode alterar o sangramento.</li>
              <li><b>DIU:</b> longa duração; a pessoa não precisa lembrar todo dia. Pode ser de cobre ou hormonal (quando disponível).</li>
              <li><b>Laqueadura/vasectomia:</b> métodos definitivos; exige decisão muito segura.</li>
            </ul>

            <h4>Fechamento</h4>
            <ul>
              <li>Confirmar que a pessoa entendeu como usar o método e o que fazer se esquecer.</li>
              <li>Orientar retorno (efeitos colaterais, adaptação, revisão) e sinais de alerta (dor forte, sangramento intenso, falta de ar, dor na perna, desmaio).</li>
            </ul>
          `
        },

        hiperdia: {
          title: "Consulta hiperdia",
          subtitle: "Checklist de consulta para hipertensão e diabetes, com monitoramento e exames recomendados pelo Ministério da Saúde (PCDT).",
          html: `
            <h4>1) Perguntas essenciais (o que não pode faltar)</h4>
            <ul>
              <li>Quais remédios está usando (nome, dose, horário)? Está tomando todos os dias?</li>
              <li>Teve efeitos colaterais? Teve hipoglicemia (tremor, suor frio, confusão, desmaio)?</li>
              <li>Teve dor no peito, falta de ar, inchaço, fraqueza em um lado do corpo, alteração de visão?</li>
              <li>Como está a alimentação, atividade física, sono, tabagismo e álcool?</li>
            </ul>

            <h4>2) Exame físico (rotina em toda consulta)</h4>
            <ul>
              <li>Pressão arterial, peso/IMC e circunferência abdominal.</li>
              <li>Avaliar edema, ausculta cardíaca, pulsos periféricos e sinais de insuficiência cardíaca.</li>
              <li>Para diabetes: examinar os pés (pele, unhas, feridas, sensibilidade e pulsos) e orientar cuidados diários.</li>
            </ul>

            <h4>3) Monitoramento e periodicidade (HAS)</h4>
            <ul>
              <li><b>Reavaliação inicial:</b> mensal até alcançar a meta de pressão; depois, a cada 3–6 meses no primeiro ano e, após controle, pode ser semestral.</li>
              <li><b>Exames laboratoriais:</b> perfil lipídico, glicemia de jejum ou HbA1c, creatinina, potássio (e sódio se em diurético tiazídico), urinálise; solicitar anualmente ou pelo menos a cada 2 anos, conforme o caso.</li>
              <li><b>Eletrocardiograma:</b> solicitar para avaliação e acompanhamento conforme necessidade clínica.</li>
            </ul>

            <h4>4) Monitoramento e periodicidade (DM2)</h4>
            <ul>
              <li><b>Consultas:</b> reavaliar no máximo a cada 3 a 6 meses, ajustando o tratamento conforme metas e risco.</li>
              <li><b>Em cada consulta:</b> peso, pressão arterial e estratificação de risco cardiovascular.</li>
              <li><b>Ao diagnóstico e anualmente:</b> perfil lipídico, creatinina/albuminúria (nefropatia), fundoscopia (retinopatia), avaliação do pé diabético (monofilamento e pulsos podais).</li>
              <li><b>Ao diagnóstico e a cada 6 meses:</b> glicemia de jejum e hemoglobina glicada (HbA1c).</li>
            </ul>

            <h4>5) Orientações em linguagem simples (para o paciente entender)</h4>
            <ul>
              <li><b>Pressão alta</b> costuma não dar sintoma. Mesmo “se sentindo bem”, precisa tratar para evitar AVC, infarto e problemas no rim.</li>
              <li><b>Diabetes</b> pode machucar olhos, rins e pés “por dentro”. Os exames e o exame do pé servem para detectar cedo.</li>
              <li><b>Procure urgência se</b>: dor no peito, falta de ar forte, desmaio, confusão, fraqueza em um lado do corpo, glicemia muito baixa com rebaixamento.</li>
            </ul>
          `
        },puerperio: {
          title: "Consulta de puerpério",
          subtitle: "Roteiro para a consulta pós-parto com foco em segurança, amamentação, saúde mental e planejamento reprodutivo.",
          html: `
            <h4>Quando fazer</h4>
            <ul>
              <li>Atenção à mulher e ao recém-nascido na primeira semana após o parto.</li>
              <li>Consulta puerperal até o 42º dia pós-parto (6 semanas).</li>
            </ul>

            <h4>O que perguntar (bem detalhado)</h4>
            <ul>
              <li>Sangramento: quantidade, odor, coágulos; febre; dor pélvica; secreção na ferida (cesárea/episiotomia).</li>
              <li>Sintomas urinários e intestinais; dor intensa; tontura; falta de ar.</li>
              <li>Amamentação: pega, dor, fissuras, ingurgitamento, mastite; ganho de peso do bebê.</li>
              <li>Humor: tristeza persistente, ansiedade intensa, insônia grave, pensamentos de autoagressão (avaliar risco).</li>
              <li>Contracepção e retorno da atividade sexual.</li>
            </ul>

            <h4>Exame físico</h4>
            <ul>
              <li>Pressão arterial, estado geral e sinais de anemia/desidratação.</li>
              <li>Mamas (se dor, febre, fissuras), abdome e avaliação uterina conforme queixa e período.</li>
              <li>Ferida operatória/episiotomia: sinais de infecção.</li>
            </ul>

            <h4>Exames e condutas lembradas pelo MS</h4>
            <ul>
              <li>Se não foi feito durante o pré-natal, ofertar teste anti-HIV e VDRL no puerpério, considerando o risco e a disponibilidade.</li>
              <li>Reposição de ferro se anemia/situações de risco e orientação alimentar para recuperação.</li>
              <li>Planejamento reprodutivo: orientar método seguro no puerpério conforme condição clínica e amamentação.</li>
            </ul>

            <h4>Explicação simples para a paciente</h4>
            <ul>
              <li>“Essa consulta serve para garantir que você está se recuperando bem do parto, que o bebê está bem, e para evitar problemas que podem aparecer depois que você já foi para casa.”</li>
            </ul>
          `
        },

        sbar: {
          title: "Perguntas para Passagem de Plantão (SBAR)",
          subtitle: "Use este roteiro para coletar rapidamente informações e montar um SBAR claro para o próximo profissional.",
          html: `
            <h4>S (Situação) – o que está acontecendo agora</h4>
            <ul>
              <li>Quem é o paciente (nome, idade, identificação) e onde está (sala/leito/consultório)?</li>
              <li>Qual é o problema principal neste momento?</li>
              <li>Há instabilidade? (queda de pressão, falta de ar, rebaixamento de consciência, dor intensa, sangramento)</li>
              <li>Sinais vitais atuais e tendência (melhorou/piorou)?</li>
            </ul>

            <h4>B (Background) – contexto e histórico relevante</h4>
            <ul>
              <li>Diagnósticos principais e comorbidades importantes.</li>
              <li>Motivo de internação/atendimento e evolução até aqui (em 2–3 frases).</li>
              <li>Alergias, medicamentos em uso e intervenções recentes (antibiótico, soro, oxigênio, procedimentos).</li>
              <li>Resultados relevantes já disponíveis (exames, imagem) e pendências (o que ainda falta sair).</li>
            </ul>

            <h4>A (Avaliação) – interpretação e o que você acha que é</h4>
            <ul>
              <li>Como você interpreta o quadro agora? (ex.: “piora respiratória com provável pneumonia”, “hipotensão possivelmente por desidratação”)</li>
              <li>Principais riscos nas próximas horas (choque, rebaixamento, sangramento, hipoglicemia, crise hipertensiva).</li>
              <li>Resposta ao que foi feito até agora (melhorou com medicação? persistiu?).</li>
            </ul>

            <h4>R (Recomendação) – o que precisa ser feito a seguir</h4>
            <ul>
              <li>O que você precisa que o próximo profissional faça (objetivo e claro).</li>
              <li>Monitorização: frequência de sinais vitais, controle de glicemia, diurese, dor, saturação.</li>
              <li>Condutas pendentes: exames a coletar, medicações a administrar, reavaliação em X minutos/horas.</li>
              <li>Quando chamar médico imediatamente (critérios objetivos).</li>
            </ul>
          `
        }
      };

      let currentConsultKey = null;
      let currentTri = 1;

      function setActive(btn) {
        consultButtons.forEach(b => b.classList.remove("active"));
        if (btn) btn.classList.add("active");
      }

      function renderGuide(key) {
        const g = GUIDE[key];
        if (!g) return;

        titleEl.textContent = g.title || "";
        subtitleEl.textContent = g.subtitle || "";
        drawer.classList.remove("hidden");

        if (key === "prenatal") {
          prenatalTriRow.classList.remove("hidden");
          // Seleciona trimestre atual
          triBtns.forEach(b => {
            const tri = Number(b.getAttribute("data-tri"));
            if (tri === currentTri) b.classList.add("active");
            else b.classList.remove("active");
          });
          const triData = g.trimester?.[currentTri] || g.trimester?.[1];
          if (triData) {
            subtitleEl.textContent = triData.subtitle || g.subtitle || "";
            contentEl.innerHTML = triData.html || "";
          } else {
            contentEl.textContent = "Conteúdo indisponível.";
          }
        } else {
          prenatalTriRow.classList.add("hidden");
          contentEl.innerHTML = g.html || "";
        }
      }

      function openGuide(key, btn) {
        currentConsultKey = key;
        currentTri = 1;
        setActive(btn);
        renderGuide(key);
        try {
          drawer.scrollIntoView({ behavior: "smooth", block: "start" });
        } catch (e) {}
      }

      function closeGuide() {
        drawer.classList.add("hidden");
        prenatalTriRow.classList.add("hidden");
        contentEl.innerHTML = "";
        currentConsultKey = null;
        consultButtons.forEach(b => b.classList.remove("active"));
      }

      consultButtons.forEach(btn => {
        btn.addEventListener("click", () => {
          const key = btn.getAttribute("data-consult");
          if (!key) return;
          openGuide(key, btn);
        });
      });

      triBtns.forEach(btn => {
        btn.addEventListener("click", () => {
          const tri = Number(btn.getAttribute("data-tri"));
          if (!Number.isFinite(tri) || tri < 1 || tri > 3) return;
          currentTri = tri;
          if (currentConsultKey === "prenatal") renderGuide("prenatal");
        });
      });

      closeBtn.addEventListener("click", closeGuide);

      // Fecha com ESC quando o drawer estiver aberto
      document.addEventListener("keydown", (ev) => {
        if (ev.key === "Escape" && drawer && !drawer.classList.contains("hidden")) closeGuide();
      });
    })();

// ============================
    // MÓDULO: Calculadoras Clínicas
    // ============================
    const calculatorsCard = document.getElementById("calculatorsCard");
    const calcSelect = document.getElementById("calcSelect");

    const calcPanels = {
      imc: document.getElementById("calcPanel_imc"),
      cv_risk: document.getElementById("calcPanel_cv_risk"),
      bsa: document.getElementById("calcPanel_bsa"),
      gest_age: document.getElementById("calcPanel_gest_age"),
      drip_pump: document.getElementById("calcPanel_drip_pump"),
      fluid_balance: document.getElementById("calcPanel_fluid_balance"),
      weight_dose: document.getElementById("calcPanel_weight_dose"),
      glasgow: document.getElementById("calcPanel_glasgow"),
      sedation: document.getElementById("calcPanel_sedation"),
      pain: document.getElementById("calcPanel_pain"),
      morse: document.getElementById("calcPanel_morse"),
      braden: document.getElementById("calcPanel_braden"),
      pews: document.getElementById("calcPanel_pews"),
    };

    function safeNumber(v) {
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    }

    function formatPtNumber(n, decimals = 2) {
      if (!Number.isFinite(n)) return "-";
      return n.toLocaleString("pt-BR", { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
    }

    function parseDateYYYYMMDD(value) {
      if (!value) return null;
      const parts = String(value).split("-");
      if (parts.length !== 3) return null;
      const y = Number(parts[0]);
      const m = Number(parts[1]);
      const d = Number(parts[2]);
      if (!Number.isFinite(y) || !Number.isFinite(m) || !Number.isFinite(d)) return null;
      // horário do meio-dia para reduzir risco de variações por fuso/DST
      return new Date(y, m - 1, d, 12, 0, 0, 0);
    }

    function formatDatePt(dateObj) {
      try {
        return dateObj.toLocaleDateString("pt-BR");
      } catch (e) {
        return "-";
      }
    }

    function showCalcPanel(key) {
      Object.keys(calcPanels).forEach(k => {
        const el = calcPanels[k];
        if (!el) return;
        if (k === key) el.classList.remove("hidden");
        else el.classList.add("hidden");
      });
    }

    if (calcSelect) {
      calcSelect.addEventListener("change", () => {
        showCalcPanel(calcSelect.value);
      });
      showCalcPanel(calcSelect.value || "imc");
    }

    // IMC
    const imcWeightKg = document.getElementById("imcWeightKg");
    const imcHeightCm = document.getElementById("imcHeightCm");
    const imcResult = document.getElementById("imcResult");

    function calcIMC() {
      if (!imcResult) return;
      const w = safeNumber(imcWeightKg?.value);
      const hcm = safeNumber(imcHeightCm?.value);
      if (!w || !hcm || w <= 0 || hcm <= 0) {
        imcResult.textContent = "Preencha peso e altura.";
        return;
      }
      const hm = hcm / 100;
      const bmi = w / (hm * hm);
      let cat = "";
      if (bmi < 18.5) cat = "Baixo peso";
      else if (bmi < 25) cat = "Eutrofia";
      else if (bmi < 30) cat = "Sobrepeso";
      else if (bmi < 35) cat = "Obesidade grau I";
      else if (bmi < 40) cat = "Obesidade grau II";
      else cat = "Obesidade grau III";
      imcResult.textContent = `IMC: ${formatPtNumber(bmi, 1)}\nClassificação: ${cat}`;
    }
    [imcWeightKg, imcHeightCm].forEach(el => el && el.addEventListener("input", calcIMC));
    calcIMC();

    // Risco cardiovascular (PREVENT - SBC/TribeMD)
    const cvAge = document.getElementById("cvAge");
    const cvSex = document.getElementById("cvSex");
    const cvWeightKg = document.getElementById("cvWeightKg");
    const cvHeightCm = document.getElementById("cvHeightCm");
    const cvSbp = document.getElementById("cvSbp");
    const cvCreatinine = document.getElementById("cvCreatinine");
    const cvTotalChol = document.getElementById("cvTotalChol");
    const cvHdl = document.getElementById("cvHdl");
    const cvSmoker = document.getElementById("cvSmoker");
    const cvDiabetes = document.getElementById("cvDiabetes");
    const cvOnHtnMeds = document.getElementById("cvOnHtnMeds");
    const cvOnStatin = document.getElementById("cvOnStatin");
    const cvRiskResult = document.getElementById("cvRiskResult");

    // Coeficientes: PREVENT (AHA) - Base model (sem fatores "novos"): 10 anos e 30 anos.
    // Referência técnica dos coeficientes: tabela do PREVENT (AHA) conforme EBMcalc.
    const PREVENT_BASE_10 = {
      C0: [0.7939329, 0.7688528, 0.719883, 0.7099847, 0.8998235, 0.8972642],
      C1: [0, 0, 0, 0, 0, 0],
      C2: [0.0305239, 0.0736174, 0.1176967, 0.1658663, 0, 0],
      C3: [-0.1606857, -0.0954431, -0.151185, -0.1144285, 0, 0],
      C4: [-0.2394003, -0.4347345, -0.0835358, -0.2837212, -0.4559771, -0.6811466],
      C5: [0.3600781, 0.3362658, 0.3592852, 0.3239977, 0.3576505, 0.3634461],
      C6: [0.8667604, 0.7692857, 0.8348585, 0.7189597, 1.038346, 0.923776],
      C7: [0.5360739, 0.4386871, 0.4831078, 0.3956973, 0.583916, 0.5023736],
      C8: [0, 0, 0, 0, -0.0072294, -0.0485841],
      C9: [0, 0, 0, 0, 0.2997706, 0.3726929],
      C10: [0.6045917, 0.5378979, 0.4864619, 0.3690075, 0.7451638, 0.6926917],
      C11: [0.0433769, 0.0164827, 0.0397779, 0.0203619, 0.0557087, 0.0251827],
      C12: [0.3151672, 0.288879, 0.2265309, 0.2036522, 0.3534442, 0.2980922],
      C13: [-0.1477655, -0.1337349, -0.0592374, -0.0865581, 0, 0],
      C14: [-0.0663612, -0.0475924, -0.0395762, -0.0322916, -0.0981511, -0.0497731],
      C15: [0.1197879, 0.150273, 0.0844423, 0.114563, 0, 0],
      C16: [-0.0819715, -0.0517874, -0.0567839, -0.0300005, 0, 0],
      C17: [0.0306769, 0.0191169, 0.0325692, 0.0232747, 0, 0],
      C18: [-0.0946348, -0.1049477, -0.1035985, -0.0927024, -0.0946663, -0.1289201],
      C19: [-0.27057, -0.2251948, -0.2417542, -0.2018525, -0.3581041, -0.3040924],
      C20: [-0.078715, -0.0895067, -0.0791142, -0.0970527, -0.1159453, -0.1401688],
      C21: [0, 0, 0, 0, -0.003878, 0.0068126],
      C22: [-0.1637806, -0.1543702, -0.1671492, -0.1217081, -0.1884289, -0.1797778],
      C23: [0, 0, 0, 0, 0, 0],
      C24: [0, 0, 0, 0, 0, 0],
      C25: [0, 0, 0, 0, 0, 0],
      C26: [0, 0, 0, 0, 0, 0],
      C27: [0, 0, 0, 0, 0, 0],
      C28: [0, 0, 0, 0, 0, 0],
      C29: [0, 0, 0, 0, 0, 0],
      C30: [0, 0, 0, 0, 0, 0],
      C31: [-3.307728, -3.031168, -3.819975, -3.500655, -4.310409, -3.946391],
    };

    const PREVENT_BASE_30 = {
      C0: [0.5503079, 0.4627309, 0.4669202, 0.3994099, 0.6254374, 0.5681541],
      C1: [-0.0928369, -0.0984281, -0.0893118, -0.0937484, -0.0983038, -0.1048388],
      C2: [0.0409794, 0.0836088, 0.1256901, 0.1744643, 0, 0],
      C3: [-0.1663306, -0.1029824, -0.1542255, -0.120203, 0, 0],
      C4: [-0.1628654, -0.2140352, -0.0018093, -0.0665117, -0.3919241, -0.4761564],
      C5: [0.3299505, 0.2904325, 0.322949, 0.2753037, 0.3142295, 0.30324],
      C6: [0.6793894, 0.5331276, 0.6296707, 0.4790257, 0.8330787, 0.6840338],
      C7: [0.3196112, 0.2141914, 0.268292, 0.1782635, 0.3438651, 0.2656273],
      C8: [0, 0, 0, 0, 0.0594874, 0.0833107],
      C9: [0, 0, 0, 0, 0.2525536, 0.26999],
      C10: [0.1857101, 0.1155556, 0.100106, -0.0218789, 0.2981642, 0.2541805],
      C11: [0.0553528, 0.0603775, 0.0499663, 0.0602553, 0.0667159, 0.0638923],
      C12: [0.2894, 0.232714, 0.1875292, 0.1421182, 0.333921, 0.2583631],
      C13: [-0.075688, -0.0272112, 0.0152476, 0.0135996, 0, 0],
      C14: [-0.056367, -0.0384488, -0.0276123, -0.0218265, -0.0893177, -0.0391938],
      C15: [0.1071019, 0.134192, 0.0736147, 0.1013148, 0, 0],
      C16: [-0.0751438, -0.0511759, -0.0521962, -0.0312619, 0, 0],
      C17: [0.0301786, 0.0165865, 0.0316918, 0.020673, 0, 0],
      C18: [-0.0998776, -0.1101437, -0.1046101, -0.0920935, -0.0974299, -0.1269124],
      C19: [-0.3206166, -0.2585943, -0.2727793, -0.2159947, -0.404855, -0.3273572],
      C20: [-0.1607862, -0.1566406, -0.1530907, -0.1548811, -0.1982991, -0.2043019],
      C21: [0, 0, 0, 0, -0.0035619, -0.0182831],
      C22: [-0.1450788, -0.1166776, -0.1299149, -0.0712547, -0.1564215, -0.1342618],
      C23: [0, 0, 0, 0, 0, 0],
      C24: [0, 0, 0, 0, 0, 0],
      C25: [0, 0, 0, 0, 0, 0],
      C26: [0, 0, 0, 0, 0, 0],
      C27: [0, 0, 0, 0, 0, 0],
      C28: [0, 0, 0, 0, 0, 0],
      C29: [0, 0, 0, 0, 0, 0],
      C30: [0, 0, 0, 0, 0, 0],
      C31: [-1.318827, -1.148204, -1.974074, -1.736444, -2.205379, -1.95751],
    };

    function preventIndex(endpoint, sex) {
      const sx = (sex === "male") ? "m" : "f";
      if (endpoint === "total") return sx === "f" ? 0 : 1;
      if (endpoint === "ascvd") return sx === "f" ? 2 : 3;
      return sx === "f" ? 4 : 5; // hf
    }

    function preventEgfrCkdEpi2021(creatinineMgDl, ageYears, sex) {
      // CKD-EPI 2021 (sem raça): https://www.kidney.org/professionals/kdoqi/gfr_calculator (equação 2021)
      const scr = creatinineMgDl;
      const age = ageYears;
      const female = (sex !== "male");

      const kappa = female ? 0.7 : 0.9;
      const alpha = female ? -0.241 : -0.302;
      const sexFactor = female ? 1.012 : 1.0;

      const minPart = Math.min(scr / kappa, 1);
      const maxPart = Math.max(scr / kappa, 1);

      const egfr = 142 * Math.pow(minPart, alpha) * Math.pow(maxPart, -1.2) * Math.pow(0.9938, age) * sexFactor;
      return egfr;
    }

    function preventRiskPct(logit) {
      // 100 * exp(x) / (1 + exp(x))
      const ex = Math.exp(logit);
      const p = ex / (1 + ex);
      return p * 100;
    }

    function preventComputeLogit(model, endpoint, sex, v) {
      const idx = preventIndex(endpoint, sex);
      const C = (name) => (model[name] ? model[name][idx] : 0);

      // Variáveis conforme especificação do PREVENT:
      const ageTerm = (v.age - 55) / 10;
      const nonHdlTerm = (((v.totalChol - v.hdl) * 0.02586) - 3.5); // mmol/L
      const hdlTerm = ((v.hdl * 0.02586) - 1.3) / 0.3; // mmol/L

      const sbpLow = (Math.min(v.sbp, 110) - 110) / 20;
      const sbpHigh = (Math.max(v.sbp, 110) - 130) / 20;

      const bmiLow = (Math.min(v.bmi, 30) - 25) / 5;
      const bmiHigh = (Math.max(v.bmi, 30) - 30) / 5;

      const egfrLow = (Math.min(v.egfr, 60) - 60) / -15;
      const egfrHigh = (Math.max(v.egfr, 60) - 90) / -15;

      const diabetes = v.diabetes ? 1 : 0;
      const smoker = v.smoker ? 1 : 0;
      const onHtnMeds = v.onHtnMeds ? 1 : 0;
      const onStatin = v.onStatin ? 1 : 0;

      const logit =
        (C("C0") * ageTerm) +
        (C("C1") * (ageTerm * ageTerm)) +
        (C("C2") * nonHdlTerm) +
        (C("C3") * hdlTerm) +
        (C("C4") * sbpLow) +
        (C("C5") * sbpHigh) +
        (C("C6") * diabetes) +
        (C("C7") * smoker) +
        (C("C8") * bmiLow) +
        (C("C9") * bmiHigh) +
        (C("C10") * egfrLow) +
        (C("C11") * egfrHigh) +
        (C("C12") * onHtnMeds) +
        (C("C13") * onStatin) +
        (C("C14") * onHtnMeds * sbpHigh) +
        (C("C15") * onStatin * nonHdlTerm) +
        (C("C16") * ageTerm * nonHdlTerm) +
        (C("C17") * ageTerm * hdlTerm) +
        (C("C18") * ageTerm * sbpHigh) +
        (C("C19") * ageTerm * diabetes) +
        (C("C20") * ageTerm * smoker) +
        (C("C21") * bmiHigh) +
        (C("C22") * ageTerm * egfrLow) +
        (C("C31"));

      return logit;
    }

    function cvRiskBandAscvd10y(pct) {
      if (!Number.isFinite(pct)) return "-";
      if (pct < 5) return "Baixo (<5%)";
      if (pct < 7.5) return "Limítrofe (5% a <7,5%)";
      if (pct < 20) return "Intermediário (7,5% a <20%)";
      return "Alto (≥20%)";
    }

    function calcCvRiskPrevent() {
      if (!cvRiskResult) return;

      const age = safeNumber(cvAge?.value);
      const sex = cvSex?.value || "female";
      const w = safeNumber(cvWeightKg?.value);
      const hcm = safeNumber(cvHeightCm?.value);
      const sbp = safeNumber(cvSbp?.value);
      const scr = safeNumber(cvCreatinine?.value);
      const tc = safeNumber(cvTotalChol?.value);
      const hdl = safeNumber(cvHdl?.value);
      const smoker = Number(cvSmoker?.value || "0") === 1;
      const diabetes = Number(cvDiabetes?.value || "0") === 1;
      const onHtnMeds = Number(cvOnHtnMeds?.value || "0") === 1;
      const onStatin = Number(cvOnStatin?.value || "0") === 1;

      const missing = [];
      if (!age || age <= 0) missing.push("idade");
      if (!w || w <= 0) missing.push("peso");
      if (!hcm || hcm <= 0) missing.push("altura");
      if (!sbp || sbp <= 0) missing.push("PAS");
      if (!scr || scr <= 0) missing.push("creatinina");
      if (!tc || tc <= 0) missing.push("colesterol total");
      if (!hdl || hdl <= 0) missing.push("HDL");

      if (missing.length) {
        cvRiskResult.textContent = "Preencha: " + missing.join(", ") + ".";
        return;
      }

      const hm = hcm / 100;
      const bmi = w / (hm * hm);
      const egfr = preventEgfrCkdEpi2021(scr, age, sex);

      const v = {
        age,
        sbp,
        totalChol: tc,
        hdl,
        bmi,
        egfr,
        smoker,
        diabetes,
        onHtnMeds,
        onStatin
      };

      const total10 = preventRiskPct(preventComputeLogit(PREVENT_BASE_10, "total", sex, v));
      const ascvd10 = preventRiskPct(preventComputeLogit(PREVENT_BASE_10, "ascvd", sex, v));
      const hf10 = preventRiskPct(preventComputeLogit(PREVENT_BASE_10, "hf", sex, v));

      let text = "";
      const warnings = [];
      if (age < 30 || age > 79) warnings.push("Faixa etária fora do intervalo típico (30 a 79 anos) do PREVENT; interpretar com cautela.");
      if (egfr <= 0 || !Number.isFinite(egfr)) warnings.push("Não foi possível estimar eTFG com segurança; verifique creatinina/idade/sexo.");
      if (warnings.length) text += warnings.map(w => "Atenção: " + w).join("\n") + "\n\n";

      text += `IMC: ${formatPtNumber(bmi, 1)} kg/m²\n`;
      text += `eTFG (CKD-EPI 2021): ${formatPtNumber(egfr, 0)} mL/min/1,73m²\n\n`;

      text += `Risco em 10 anos (PREVENT)\n`;
      text += `CVD total: ${formatPtNumber(total10, 1)}%\n`;
      text += `ASCVD: ${formatPtNumber(ascvd10, 1)}% (${cvRiskBandAscvd10y(ascvd10)})\n`;
      text += `Insuficiência cardíaca: ${formatPtNumber(hf10, 1)}%\n`;

      // 30-year: aplicável principalmente para 30-59 anos
      if (age >= 30 && age <= 59) {
        const total30 = preventRiskPct(preventComputeLogit(PREVENT_BASE_30, "total", sex, v));
        const ascvd30 = preventRiskPct(preventComputeLogit(PREVENT_BASE_30, "ascvd", sex, v));
        const hf30 = preventRiskPct(preventComputeLogit(PREVENT_BASE_30, "hf", sex, v));
        text += `\nRisco em 30 anos (PREVENT)\n`;
        text += `CVD total: ${formatPtNumber(total30, 1)}%\n`;
        text += `ASCVD: ${formatPtNumber(ascvd30, 1)}%\n`;
        text += `Insuficiência cardíaca: ${formatPtNumber(hf30, 1)}%\n`;
      } else {
        text += `\nRisco em 30 anos: aplicável principalmente para 30 a 59 anos.\n`;
      }

      text += `\nObservação: ferramenta de apoio. A interpretação e conduta dependem do contexto clínico e diretriz adotada.`;

      cvRiskResult.textContent = text;
    }

    [
      cvAge, cvSex, cvWeightKg, cvHeightCm, cvSbp, cvCreatinine,
      cvTotalChol, cvHdl, cvSmoker, cvDiabetes, cvOnHtnMeds, cvOnStatin
    ].forEach(el => el && el.addEventListener("input", calcCvRiskPrevent));
    [cvSex, cvSmoker, cvDiabetes, cvOnHtnMeds, cvOnStatin].forEach(el => el && el.addEventListener("change", calcCvRiskPrevent));
    calcCvRiskPrevent();


    // BSA (Mosteller)
    const bsaWeightKg = document.getElementById("bsaWeightKg");
    const bsaHeightCm = document.getElementById("bsaHeightCm");
    const bsaResult = document.getElementById("bsaResult");

    function calcBSA() {
      if (!bsaResult) return;
      const w = safeNumber(bsaWeightKg?.value);
      const hcm = safeNumber(bsaHeightCm?.value);
      if (!w || !hcm || w <= 0 || hcm <= 0) {
        bsaResult.textContent = "Preencha peso e altura.";
        return;
      }
      const bsa = Math.sqrt((hcm * w) / 3600);
      bsaResult.textContent = `SC (Mosteller): ${formatPtNumber(bsa, 2)} m²`;
    }
    [bsaWeightKg, bsaHeightCm].forEach(el => el && el.addEventListener("input", calcBSA));
    calcBSA();

    // Idade gestacional (por DUM)
    const gestDum = document.getElementById("gestDum");
    const gestResult = document.getElementById("gestResult");

    function calcGestAge() {
      if (!gestResult) return;
      const dum = parseDateYYYYMMDD(gestDum?.value);
      if (!dum) {
        gestResult.textContent = "Informe a DUM.";
        return;
      }
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 12, 0, 0, 0);
      const diffMs = today.getTime() - dum.getTime();
      const diffDays = Math.floor(diffMs / (24 * 60 * 60 * 1000));
      if (diffDays < 0) {
        gestResult.textContent = "A DUM está no futuro. Verifique a data.";
        return;
      }
      const weeks = Math.floor(diffDays / 7);
      const days = diffDays % 7;

      const dpp = new Date(dum.getTime() + 280 * 24 * 60 * 60 * 1000);
      gestResult.textContent = `Idade gestacional hoje: ${weeks} semanas e ${days} dias\nDPP (DUM + 280 dias): ${formatDatePt(dpp)}\nDUM: ${formatDatePt(dum)}`;
    }
    gestDum && gestDum.addEventListener("change", calcGestAge);
    calcGestAge();

    // Gotejamento e bomba
    const dripVolumeMl = document.getElementById("dripVolumeMl");
    const dripTimeH = document.getElementById("dripTimeH");
    const dripTimeMin = document.getElementById("dripTimeMin");
    const dripFactor = document.getElementById("dripFactor");
    const dripResult = document.getElementById("dripResult");

    function calcDrip() {
      if (!dripResult) return;
      const vol = safeNumber(dripVolumeMl?.value);
      const h = safeNumber(dripTimeH?.value) ?? 0;
      const m = safeNumber(dripTimeMin?.value) ?? 0;
      const factor = safeNumber(dripFactor?.value);
      const totalMin = (h * 60) + m;

      if (!vol || vol <= 0 || !factor || factor <= 0 || !totalMin || totalMin <= 0) {
        dripResult.textContent = "Preencha volume, tempo e fator de gotejamento.";
        return;
      }

      const mlPerH = vol / (totalMin / 60);
      const gttPerMin = (vol * factor) / totalMin;

      dripResult.textContent =
        `Bomba de infusão: ${formatPtNumber(mlPerH, 1)} mL/h\nGotejamento: ${formatPtNumber(gttPerMin, 0)} gotas/min\n(Volume: ${formatPtNumber(vol, 1)} mL, Tempo: ${formatPtNumber(totalMin, 0)} min, Fator: ${formatPtNumber(factor, 0)} gotas/mL)`;
    }
    [dripVolumeMl, dripTimeH, dripTimeMin, dripFactor].forEach(el => el && el.addEventListener("input", calcDrip));
    dripFactor && dripFactor.addEventListener("change", calcDrip);
    calcDrip();

    // Balanço hídrico
    const fbInputMl = document.getElementById("fbInputMl");
    const fbOutputMl = document.getElementById("fbOutputMl");
    const fbWeightKg = document.getElementById("fbWeightKg");
    const fbHours = document.getElementById("fbHours");
    const fbResult = document.getElementById("fbResult");

    function calcFluidBalance() {
      if (!fbResult) return;
      const input = safeNumber(fbInputMl?.value) ?? 0;
      const output = safeNumber(fbOutputMl?.value) ?? 0;
      const bal = input - output;

      let msg = `Entradas: ${formatPtNumber(input, 0)} mL\nSaídas: ${formatPtNumber(output, 0)} mL\nBalanço: ${formatPtNumber(bal, 0)} mL`;

      const w = safeNumber(fbWeightKg?.value);
      const hours = safeNumber(fbHours?.value);
      if (w && w > 0 && hours && hours > 0) {
        const diuresis = output / (w * hours);
        msg += `\nDiurese estimada: ${formatPtNumber(diuresis, 2)} mL/kg/h`;
      }
      fbResult.textContent = msg;
    }
    [fbInputMl, fbOutputMl, fbWeightKg, fbHours].forEach(el => el && el.addEventListener("input", calcFluidBalance));
    calcFluidBalance();

    // Dose por peso
    const wdWeightKg = document.getElementById("wdWeightKg");
    const wdDoseMgKg = document.getElementById("wdDoseMgKg");
    const wdMaxDoseMg = document.getElementById("wdMaxDoseMg");
    const wdConcMgMl = document.getElementById("wdConcMgMl");
    const wdResult = document.getElementById("wdResult");

    function calcWeightDose() {
      if (!wdResult) return;
      const w = safeNumber(wdWeightKg?.value);
      const d = safeNumber(wdDoseMgKg?.value);
      if (!w || !d || w <= 0 || d <= 0) {
        wdResult.textContent = "Preencha peso e dose (mg/kg).";
        return;
      }
      let mg = w * d;
      const maxMg = safeNumber(wdMaxDoseMg?.value);
      let capped = false;
      if (maxMg && maxMg > 0 && mg > maxMg) {
        mg = maxMg;
        capped = true;
      }

      let msg = `Dose por tomada: ${formatPtNumber(mg, 2)} mg`;
      if (capped) msg += `\n(Aplicado limite de dose máxima: ${formatPtNumber(maxMg, 2)} mg)`;

      const conc = safeNumber(wdConcMgMl?.value);
      if (conc && conc > 0) {
        const ml = mg / conc;
        msg += `\nVolume por tomada: ${formatPtNumber(ml, 2)} mL (concentração: ${formatPtNumber(conc, 2)} mg/mL)`;
      }
      wdResult.textContent = msg;
    }
    [wdWeightKg, wdDoseMgKg, wdMaxDoseMg, wdConcMgMl].forEach(el => el && el.addEventListener("input", calcWeightDose));
    calcWeightDose();

    // Glasgow
    const gcsEye = document.getElementById("gcsEye");
    const gcsVerbal = document.getElementById("gcsVerbal");
    const gcsMotor = document.getElementById("gcsMotor");
    const gcsResult = document.getElementById("gcsResult");

    function calcGCS() {
      if (!gcsResult) return;
      const e = safeNumber(gcsEye?.value) ?? 0;
      const v = safeNumber(gcsVerbal?.value) ?? 0;
      const m = safeNumber(gcsMotor?.value) ?? 0;
      const total = e + v + m;
      let grav = "";
      if (total >= 13) grav = "Leve (13 a 15)";
      else if (total >= 9) grav = "Moderado (9 a 12)";
      else grav = "Grave (3 a 8)";
      gcsResult.textContent = `ECG total: ${total} (E${e} V${v} M${m})\nGravidade (interpretação usual): ${grav}`;
    }
    [gcsEye, gcsVerbal, gcsMotor].forEach(el => el && el.addEventListener("change", calcGCS));
    calcGCS();

    // Ramsay / RASS
    const ramsay = document.getElementById("ramsay");
    const rass = document.getElementById("rass");
    const sedationResult = document.getElementById("sedationResult");

    function ramsayText(score) {
      const map = {
        1: "Ansioso/agitado.",
        2: "Cooperativo/orientado/tranquilo.",
        3: "Responde apenas a comandos.",
        4: "Resposta rápida a estímulo (tátil/sonoro).",
        5: "Resposta lenta a estímulo.",
        6: "Sem resposta."
      };
      return map[score] || "-";
    }

    function rassText(score) {
      const map = {
        4: "Combativo.",
        3: "Muito agitado.",
        2: "Agitado.",
        1: "Inquieto.",
        0: "Alerta e calmo.",
        "-1": "Sonolento (desperta ao chamado).",
        "-2": "Sedação leve (breve despertar ao chamado).",
        "-3": "Sedação moderada (movimenta ou abre olhos à voz, sem contato visual).",
        "-4": "Sedação profunda (responde a estímulo físico).",
        "-5": "Não desperta."
      };
      return map[String(score)] || "-";
    }

    function calcSedation() {
      if (!sedationResult) return;
      const rs = safeNumber(ramsay?.value);
      const ra = safeNumber(rass?.value);
      const ram = rs ? `Ramsay: ${rs} - ${ramsayText(rs)}` : "Ramsay: -";
      const raa = (ra !== null) ? `RASS: ${ra} - ${rassText(ra)}` : "RASS: -";
      sedationResult.textContent = `${ram}\n${raa}`;
    }
    [ramsay, rass].forEach(el => el && el.addEventListener("change", calcSedation));
    calcSedation();

    // Dor
    const painScore = document.getElementById("painScore");
    const painResult = document.getElementById("painResult");

    function calcPain() {
      if (!painResult) return;
      const p = safeNumber(painScore?.value);
      if (p === null || p < 0 || p > 10) {
        painResult.textContent = "Informe um valor de 0 a 10.";
        return;
      }
      let cat = "";
      if (p === 0) cat = "Sem dor";
      else if (p <= 3) cat = "Dor leve";
      else if (p <= 6) cat = "Dor moderada";
      else cat = "Dor intensa";
      painResult.textContent = `Pontuação: ${p}\nClassificação: ${cat}`;
    }
    painScore && painScore.addEventListener("input", calcPain);
    calcPain();

    // Morse
    const morseFallHx = document.getElementById("morseFallHx");
    const morseSecondaryDx = document.getElementById("morseSecondaryDx");
    const morseAid = document.getElementById("morseAid");
    const morseIv = document.getElementById("morseIv");
    const morseGait = document.getElementById("morseGait");
    const morseMental = document.getElementById("morseMental");
    const morseResult = document.getElementById("morseResult");

    function calcMorse() {
      if (!morseResult) return;
      const items = [morseFallHx, morseSecondaryDx, morseAid, morseIv, morseGait, morseMental]
        .map(el => safeNumber(el?.value) ?? 0);
      const total = items.reduce((a,b) => a + b, 0);
      let risk = "";
      if (total <= 24) risk = "Baixo (0 a 24)";
      else if (total <= 44) risk = "Moderado (25 a 44)";
      else risk = "Alto (≥ 45)";
      morseResult.textContent = `Morse total: ${total}\nClassificação (interpretação usual): ${risk}`;
    }
    [morseFallHx, morseSecondaryDx, morseAid, morseIv, morseGait, morseMental].forEach(el => el && el.addEventListener("change", calcMorse));
    calcMorse();

    // Braden
    const brSensory = document.getElementById("brSensory");
    const brMoisture = document.getElementById("brMoisture");
    const brActivity = document.getElementById("brActivity");
    const brMobility = document.getElementById("brMobility");
    const brNutrition = document.getElementById("brNutrition");
    const brFriction = document.getElementById("brFriction");
    const bradenResult = document.getElementById("bradenResult");

    function calcBraden() {
      if (!bradenResult) return;
      const vals = [brSensory, brMoisture, brActivity, brMobility, brNutrition, brFriction]
        .map(el => safeNumber(el?.value) ?? 0);
      const total = vals.reduce((a,b) => a + b, 0);

      let cat = "";
      if (total <= 9) cat = "Risco muito alto (≤ 9)";
      else if (total <= 12) cat = "Risco alto (10 a 12)";
      else if (total <= 14) cat = "Risco moderado (13 a 14)";
      else if (total <= 18) cat = "Risco leve (15 a 18)";
      else cat = "Sem risco ou risco mínimo (19 a 23)";

      bradenResult.textContent = `Braden total: ${total}\nClassificação (interpretação usual): ${cat}`;
    }
    [brSensory, brMoisture, brActivity, brMobility, brNutrition, brFriction].forEach(el => el && el.addEventListener("change", calcBraden));
    calcBraden();

    // PEWS (Brighton)
    const pewsBehavior = document.getElementById("pewsBehavior");
    const pewsCardio = document.getElementById("pewsCardio");
    const pewsResp = document.getElementById("pewsResp");
    const pewsResult = document.getElementById("pewsResult");

    function calcPEWS() {
      if (!pewsResult) return;
      const b = safeNumber(pewsBehavior?.value) ?? 0;
      const c = safeNumber(pewsCardio?.value) ?? 0;
      const r = safeNumber(pewsResp?.value) ?? 0;
      const total = b + c + r;

      let cat = "";
      if (total <= 2) cat = "Baixo (0 a 2)";
      else if (total <= 4) cat = "Intermediário (3 a 4)";
      else cat = "Elevado (≥ 5)";

      pewsResult.textContent = `PEWS total: ${total} (Comportamento ${b}, Cardiovascular ${c}, Respiratório ${r})\nClassificação (orientação geral): ${cat}\nObservação: em muitas instituições, pontuação ≥ 3 exige reavaliação e possível escalonamento conforme protocolo local.`;
    }
    [pewsBehavior, pewsCardio, pewsResp].forEach(el => el && el.addEventListener("change", calcPEWS));
    calcPEWS();


</script>

  <div class="whatsapp-fab-label"><div class="wa-label-title">WhatsApp</div><div class="wa-label-sub">Dúvidas, reportar erros, sugestões, melhorias</div></div>
  <a
    class="whatsapp-fab"
    href="https://wa.me/5575981457012?text=Ol%C3%A1%21%20Gostaria%20de%20reportar%20um%20erro%2C%20tirar%20uma%20d%C3%BAvida%20ou%20enviar%20uma%20sugest%C3%A3o."
    target="_blank"
    rel="noopener"
    aria-label="Entrar em contato pelo WhatsApp"
    title="Dúvidas, reportar erros, sugestões, melhorias"
  >
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M19.5 14.5c-.7 0-1.4-.1-2.1-.3a1 1 0 0 0-1 .2l-1.3 1.3a13.1 13.1 0 0 1-5.8-5.8l1.3-1.3a1 1 0 0 0 .2-1c-.2-.7-.3-1.4-.3-2.1a1 1 0 0 0-1-1H6.5a1 1 0 0 0-1 1c0 6.1 4.9 11 11 11a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1z"></path>
    </svg>
  </a>

</body>
</html>

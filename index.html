<!-- index.html -->
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Atendimento de Enfermagem</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: Arial, Helvetica, sans-serif;
      margin: 0;
      padding: 0;
      background: #f5f5f5;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    .page {
      width: 100%;
      max-width: 800px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin: 20px 0 10px 0;
      text-align: center;
    }
    .center-card {
      background: #ffffff;
      border-radius: 16px;
      padding: 30px 20px 25px 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 420px;
      margin-top: 10px;
    }

    .live-guidance {
      width: 100%;
      background: #f9fbff;
      border: 1px solid #d7e6ff;
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 14px;
    }
    .live-guidance-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }
    .live-guidance-title {
      font-weight: bold;
      font-size: 13px;
      color: #0c5460;
      margin: 0;
    }
    .live-guidance-context {
      font-size: 12px;
      color: #555;
      text-align: right;
      margin: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 55%;
    }
    .live-guidance-status {
      font-size: 12px;
      color: #555;
      margin: 0 0 8px 0;
      min-height: 16px;
    }
    .live-guidance-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .live-guidance-item {
      background: #ffffff;
      border-radius: 10px;
      border: 1px solid #e4eefc;
      padding: 8px;
      font-size: 13px;
      line-height: 1.35;
      color: #1f2937;
    }

    .live-guidance-section-title {
      margin-top: 6px;
      font-size: 12px;
      font-weight: 700;
      color: #0f172a;
    }
    .live-guidance-proc {
      background: #ffffff;
      border-radius: 10px;
      border: 1px solid #e9e9e9;
      padding: 8px;
      font-size: 13px;
      line-height: 1.35;
      color: #111827;
    }
    .live-guidance-empty-item {
      font-size: 12px;
      color: #666;
      background: #ffffff;
      border-radius: 10px;
      border: 1px dashed #cbd5e1;
      padding: 10px;
    }
    .live-guidance-empty {
      font-size: 12px;
      color: #666;
      background: #ffffff;
      border-radius: 10px;
      border: 1px dashed #c8d8f5;
      padding: 8px;
    }
    .live-guidance-item-text {
      margin-bottom: 6px;
    }
    .live-guidance-item-actions {
      display: flex;
      justify-content: flex-end;
    }
    .mini-red-btn {
      border: none;
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 12px;
      color: #fff;
      cursor: pointer;
    }
    .mini-red-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    #recordBtn {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      font-size: 20px;
      font-weight: bold;
      color: #fff;
      margin-bottom: 10px;
      transition: background 0.2s, transform 0.1s;
    }
    #recordBtn.start {
      background: #28a745;
    }
    #recordBtn.recording {
      background: #dc3545;
    }
    #recordBtn:active {
      transform: scale(0.97);
    }
    #startNotice {
      font-size: 13px;
      color: #555;
      text-align: center;
      margin-top: 8px;
      margin-bottom: 8px;
    }
    #timer {
      font-size: 26px;
      margin-top: 16px;
      font-family: "Courier New", monospace;
    }
    #micStatus {
      margin-top: 8px;
      font-size: 14px;
      text-align: center;
      color: #333;
      min-height: 20px;
    }
    .controls-row {
      margin-top: 12px;
      display: flex;
      gap: 8px;
      align-items: center;
    }
    #pauseBtn {
      padding: 6px 14px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: #6c757d;
      color: #fff;
      font-size: 13px;
      display: none;
    }
    #pauseLabel {
      font-size: 12px;
      color: #555;
      margin-top: 6px;
      text-align: center;
    }
    #finishHint {
      font-size: 12px;
      color: #555;
      margin-top: 10px;
      text-align: center;
    }
    .results-card {
      background: #ffffff;
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      width: 100%;
      max-width: 800px;
      margin-top: 20px;
    }
    .results-card h2 {
      margin-top: 0;
    }
    .error {
      color: #b00020;
      margin-top: 8px;
      font-size: 13px;
      text-align: center;
    }
    .loading-dot::after {
      content: "...";
      animation: dots 1s steps(3, end) infinite;
    }
    @keyframes dots {
      0% { content: ""; }
      33% { content: "."; }
      66% { content: ".."; }
      100% { content: "..."; }
    }

    .soap-block {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 10px;
      background: #fafafa;
    }
    .soap-block-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }
    .soap-label {
      font-weight: bold;
      font-size: 14px;
    }
    .soap-textarea {
      width: 100%;
      min-height: 60px;
      resize: vertical;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #ddd;
      font-size: 14px;
      font-family: inherit;
      background: #ffffff;
    }
    .copy-soap-btn {
      padding: 4px 8px;
      border-radius: 12px;
      border: 1px solid #0c5460;
      background: #ffffff;
      color: #0c5460;
      font-size: 12px;
      cursor: pointer;
    }
    .copy-soap-btn:hover {
      background: #e6f2f5;
    }

    .prescription-textarea {
      width: 100%;
      min-height: 140px;
      resize: vertical;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #ddd;
      font-size: 14px;
      font-family: inherit;
      background: #fafafa;
      white-space: pre-wrap;
    }

    .prescription-actions {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    #copyPrescriptionBtn,
    #copyHospitalPrescriptionBtn,
    #printHospitalPrescriptionBtn,
    #generateHospitalPrescriptionBtn,
    #copySaeBtn,
    #printPregnancyBtn,
    #printLactationBtn,
        #copyFullSoapBtn,
    #printSoapBtn,
    #updateInteractionsBtn,
    #printInteractionsBtn
{
      padding: 8px 18px;
      border-radius: 20px;
      border: 1px solid #0c5460;
      background: #ffffff;
      color: #0c5460;
      font-size: 14px;
      cursor: pointer;
    }
    #copyPrescriptionBtn:hover,
    #copyHospitalPrescriptionBtn:hover,
    #printHospitalPrescriptionBtn:hover,
    #generateHospitalPrescriptionBtn:hover,
    #copySaeBtn:hover,
    #printPregnancyBtn:hover,
    #printLactationBtn:hover,
        #copyFullSoapBtn:hover,
    #printSoapBtn:hover,
    #updateInteractionsBtn:hover,
    #printInteractionsBtn:hover
{
      background: #e6f2f5;
    }

    #printBtn {
      margin-top: 0;
      padding: 8px 18px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: #0c5460;
      color: #fff;
      font-size: 14px;
      display: none;
    }

    #recommendationsBtn {
      margin-left: 0;
      padding: 8px 18px;
      border-radius: 20px;
      border: 1px solid #dc3545;
      background: #dc3545;
      color: #fff;
      cursor: pointer;
      font-size: 14px;
    }
    #recommendationsBtn:hover {
      background: #c82333;
      border-color: #c82333;
    }

    
    #generateHospitalPrescriptionBtn {
      border: 1px solid #dc3545;
      background: #dc3545;
      color: #fff;
    }
    #generateHospitalPrescriptionBtn:hover {
      background: #c82333;
      border-color: #c82333;
    }
.soap-title-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .recommendations-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 360px;
      max-width: 100%;
      height: 100vh;
      background: #ffffff;
      box-shadow: -2px 0 8px rgba(0,0,0,0.15);
      display: none;
      flex-direction: column;
      padding: 16px;
      z-index: 1000;
    }
    .recommendations-panel.visible {
      display: flex;
    }
    .recommendations-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .recommendations-header h3 {
      margin: 0;
      font-size: 16px;
    }
    .close-panel-btn {
      border: none;
      background: transparent;
      font-size: 18px;
      cursor: pointer;
      padding: 4px 8px;
    }
    .recommendations-status {
      font-size: 13px;
      color: #555;
      margin-bottom: 8px;
    }
    .recommendations-list {
      flex: 1;
      overflow-y: auto;
      margin-bottom: 12px;
      font-size: 14px;
    }
    .recommendation-item {
      background: #f5f5f5;
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 6px;
    }
    .ask-questions-btn {
      padding: 8px 16px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: #007bff;
      color: #fff;
      font-size: 14px;
    }
    .ask-questions-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .recommendations-footer {
      font-size: 11px;
      color: #666;
      margin-top: 8px;
    }

    .questions-timer {
      font-size: 18px;
      margin-top: 10px;
      font-family: "Courier New", monospace;
      text-align: center;
      color: #333;
    }

    .mini-status {
      margin-top: 6px;
      font-size: 12px;
      color: #555;
      min-height: 16px;
    }

    .classification-box {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 10px;
      background: #fafafa;
      white-space: pre-wrap;
      font-size: 14px;
      line-height: 1.35;
      min-height: 48px;
    }

    .risk-triage-box {
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 12px;
      background: #fafafa;
    }
    .risk-triage-current {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    .risk-badge {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      color: #fff;
      font-weight: bold;
      font-size: 13px;
      min-width: 120px;
      text-align: center;
    }
    .risk-none { background: #6c757d; }
    .risk-vermelho { background: #dc3545; }
    .risk-laranja { background: #fd7e14; }
    .risk-amarelo { background: #ffc107; color: #1f2937; }
    .risk-verde { background: #28a745; }
    .risk-azul { background: #0d6efd; }

    .risk-meaning {
      font-size: 14px;
      line-height: 1.35;
      color: #1f2937;
      white-space: pre-wrap;
      flex: 1;
      min-width: 180px;
    }

    .risk-legend {
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 13px;
      color: #1f2937;
    }
    .risk-legend-row {
      display: flex;
      align-items: flex-start;
      gap: 10px;
    }
    .risk-legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 4px;
      margin-top: 2px;
      flex: 0 0 14px;
    }
    .swatch-vermelho { background: #dc3545; }
    .swatch-laranja { background: #fd7e14; }
    .swatch-amarelo { background: #ffc107; }
    .swatch-verde { background: #28a745; }
    .swatch-azul { background: #0d6efd; }


    .section-header-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .section-header-row h2 {
      margin: 0;
    }

    .module-card {
      background: #ffffff;
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      width: 100%;
      max-width: 800px;
      margin-top: 20px;
    }
    .module-card h2 {
      margin-top: 0;
    }
    .inline-input-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 10px;
    }
    .text-input {
      flex: 1;
      min-width: 220px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #ddd;
      font-size: 14px;
      font-family: inherit;
      background: #ffffff;
    }
    .answer-box {
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 12px;
      background: #fafafa;
      white-space: pre-wrap;
      font-size: 14px;
      line-height: 1.4;
      min-height: 70px;
      margin-top: 12px;
    }
    .small-record-btn {
      padding: 10px 16px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      color: #fff;
      transition: background 0.2s, transform 0.1s;
    }
    .small-record-btn.start {
      background: #28a745;
    }
    .small-record-btn.recording {
      background: #dc3545;
    }
    .small-record-btn:active {
      transform: scale(0.98);
    }
    .report-actions {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    @media (max-width: 480px) {
      #recordBtn {
        width: 150px;
        height: 150px;
        font-size: 18px;
      }
      .prescription-actions {
        flex-direction: column;
        align-items: flex-start;
      }
    }

    .hidden {
      display: none !important;
    }
  

    .patientinfo-panel {
      border: 1px solid #e6e6e6;
      border-radius: 10px;
      padding: 12px;
      margin-bottom: 12px;
      background: #fafafa;
    }
    .patientinfo-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .mini-timer {
      font-size: 16px;
      font-weight: bold;
      min-width: 64px;
    }
    .patient-summary {
      margin-top: 8px;
      font-size: 14px;
      color: #333;
      white-space: pre-wrap;
    }


  
    #patientInfoBtn {
      background: #b00020;
      border-color: #b00020;
    }
    #patientInfoBtn:hover {
      filter: brightness(0.95);
    }

  
    .photo-btn {
      background: #dc3545;
      border: none;
      color: #fff;
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
    }
    .photo-btn:hover {
      filter: brightness(0.95);
    }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.45);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      padding: 16px;
    }
    .modal {
      background: #fff;
      border-radius: 14px;
      width: 100%;
      max-width: 420px;
      padding: 16px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.25);
    }
    .modal h3 {
      margin: 0 0 8px 0;
      font-size: 16px;
    }
    .modal p {
      margin: 0 0 12px 0;
      font-size: 13px;
      color: #555;
    }
    .modal-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .modal-actions button {
      flex: 1 1 140px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #d1d5db;
      background: #f9fafb;
      cursor: pointer;
      font-weight: 600;
    }
    .modal-actions button.primary {
      background: #2563eb;
      color: #fff;
      border-color: #2563eb;
    }
    .modal-actions button.danger {
      background: #dc3545;
      color: #fff;
      border-color: #dc3545;
    }
    .hidden-input {
      display: none !important;
    }

    .consult-type-panel {
      width: 100%;
      background: #ffffff;
      border-radius: 12px;
      border: 1px solid #e5e7eb;
      padding: 12px;
      margin-bottom: 12px;
    }
    .consult-type-title {
      margin: 0 0 10px 0;
      font-weight: bold;
      font-size: 13px;
      color: #111827;
    }
    .consult-type-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 10px;
    }
    .consult-type-btn {
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid #0c5460;
      background: #ffffff;
      color: #0c5460;
      font-size: 13px;
      cursor: pointer;
      flex: 1 1 160px;
      text-align: center;
      font-weight: 600;
    }
    .consult-type-btn:hover {
      background: #e6f2f5;
    }
    .consult-type-btn.active {
      background: #0c5460;
      color: #ffffff;
    }
    .consult-guide-drawer {
      width: 100%;
      background: #f9fbff;
      border: 1px solid #d7e6ff;
      border-radius: 12px;
      padding: 12px;
    }
    .consult-guide-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 10px;
      margin-bottom: 10px;
    }
    .consult-guide-title {
      font-weight: bold;
      font-size: 14px;
      color: #0c5460;
      margin: 0 0 4px 0;
    }
    .consult-guide-subtitle {
      font-size: 12px;
      color: #555;
      margin: 0;
    }
    .consult-guide-close {
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid #d1d5db;
      background: #ffffff;
      cursor: pointer;
      font-weight: 600;
      font-size: 12px;
    }
    .trimester-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin: 8px 0 10px 0;
    }
    .trimester-btn {
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid #0c5460;
      background: #ffffff;
      color: #0c5460;
      font-size: 12px;
      cursor: pointer;
      font-weight: 600;
    }
    .trimester-btn.active {
      background: #0c5460;
      color: #ffffff;
    }
    .consult-guide-content {
      font-size: 13px;
      color: #111827;
      line-height: 1.4;
    }
    .guide-section-title {
      font-weight: bold;
      margin: 10px 0 6px 0;
      color: #111827;
    }
    .consult-guide-content ol {
      margin: 0 0 6px 18px;
      padding: 0;
    }
    .consult-guide-content li {
      margin: 0 0 6px 0;
    }


  
    /* Padronização de botões de copiar e imprimir */
    .btn-copy {
      padding: 8px 18px;
      border-radius: 20px;
      border: 1px solid #fd7e14 !important;
      background: #fd7e14 !important;
      color: #ffffff !important;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.05s, opacity 0.15s;
    }
    .btn-copy:hover { opacity: 0.92; }
    .btn-copy:active { transform: scale(0.98); }

    .btn-print {
      padding: 8px 18px;
      border-radius: 20px;
      border: 1px solid #0d6efd !important;
      background: #0d6efd !important;
      color: #ffffff !important;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.05s, opacity 0.15s;
    }
    .btn-print:hover { opacity: 0.92; }
    .btn-print:active { transform: scale(0.98); }

    /* Botões "Copiar" por seção do SOAP (mesma identidade visual, tamanho menor) */
    .copy-soap-btn {
      border: 1px solid #fd7e14 !important;
      background: #fd7e14 !important;
      color: #ffffff !important;
      border-radius: 20px;
      padding: 4px 10px;
      font-size: 12px;
      cursor: pointer;
    }
    .copy-soap-btn:hover { opacity: 0.92; }

    /* Botão flutuante de contato via WhatsApp */
    .whatsapp-fab {
      position: fixed;
      right: 18px;
      bottom: 18px;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: none;
      background: #25D366;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 8px 18px rgba(0,0,0,0.20);
      cursor: pointer;
      text-decoration: none;
      z-index: 2000;
    }
    .whatsapp-fab:active { transform: scale(0.98); }
    .whatsapp-fab svg { width: 28px; height: 28px; fill: #ffffff; }
    .whatsapp-fab-label {
      position: fixed;
      right: 84px;
      bottom: 28px;
      background: #ffffff;
      border: 1px solid #e5e7eb;
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 12px;
      color: #111827;
      box-shadow: 0 6px 16px rgba(0,0,0,0.12);
      z-index: 2000;
      user-select: none;
    }
    @media (max-width: 520px) {
      .whatsapp-fab-label { display: none; }
    }

  </style>
</head>
<body>
  <div class="page">
    <h1>Atendimento de Enfermagem</h1>

    <div class="center-card">

      <div id="consultTypePanel" class="consult-type-panel">
        <p class="consult-type-title">Guias de consulta</p>
        <div class="consult-type-buttons">
          <button class="consult-type-btn" type="button" data-consult="prenatal">Consulta pré-natal por trimestre</button>
          <button class="consult-type-btn" type="button" data-consult="puericultura">Consulta puericultura</button>
          <button class="consult-type-btn" type="button" data-consult="planejamento">Consulta planejamento familiar</button>
          <button class="consult-type-btn" type="button" data-consult="hiperdia">Consulta hiperdia</button>
        </div>

        <div id="consultGuideDrawer" class="consult-guide-drawer hidden">
          <div class="consult-guide-header">
            <div>
              <p id="consultGuideTitle" class="consult-guide-title"></p>
              <p id="consultGuideSubtitle" class="consult-guide-subtitle"></p>
            </div>
            <button id="closeConsultGuideBtn" class="consult-guide-close" type="button">Fechar</button>
          </div>

          <div id="prenatalTrimesterRow" class="trimester-row hidden">
            <button class="trimester-btn" type="button" data-tri="1">1º trimestre</button>
            <button class="trimester-btn" type="button" data-tri="2">2º trimestre</button>
            <button class="trimester-btn" type="button" data-tri="3">3º trimestre</button>
          </div>

          <div id="consultGuideContent" class="consult-guide-content"></div>
        </div>
      </div>

      <div id="liveGuidance" class="live-guidance">
        <div class="live-guidance-header">
          <p class="live-guidance-title">Perguntas e procedimentos essenciais</p>
          <p id="liveGuidanceContext" class="live-guidance-context"></p>
        </div>
        <p id="liveGuidanceStatus" class="live-guidance-status">Inicie o atendimento para receber perguntas e procedimentos necessários em tempo real.</p>
        <div id="liveGuidanceList" class="live-guidance-list">
          <div class="live-guidance-empty">Nenhuma sugestão por enquanto.</div>
        </div>
      </div>

      <button id="recordBtn" class="start">Iniciar atendimento</button>

      <p id="startNotice">
        Assim que iniciar a gravação, informe sempre o nome completo do paciente, idade, peso e sinais vitais (PA, FC, FR, SpO2 e temperatura) para que o SOAP e a prescrição sejam gerados corretamente.
      </p>

      <div id="timer">00:00</div>
      <div id="micStatus">Clique em "Iniciar atendimento" para começar.</div>

      <div class="controls-row">
        <button id="pauseBtn">Pausar</button>
      </div>
      <div id="pauseLabel">Use o botão pequeno para pausar e retomar a consulta.</div>

      <div id="finishHint">
        Para encerrar a consulta e gerar o SOAP, clique novamente no botão grande vermelho.
      </div>

      <div id="soapError" class="error"></div>
    </div>

    <div id="resultsCard" class="results-card hidden">

      <div id="patientInfoPanel" class="patientinfo-panel">
        <div class="patientinfo-row">
          <button id="patientInfoBtn" class="small-record-btn">Coletar dados essenciais</button>
          <div id="patientInfoTimer" class="mini-timer">00:00</div>
          <div id="patientInfoStatus" class="mini-status"></div>
        </div>
        <div id="patientInfoSummary" class="patient-summary"></div>
      </div>


      <div class="section-header-row">
        <div class="soap-title-actions">
          <h2>SOAP</h2>
          <button id="copyFullSoapBtn" class="btn-copy">Copiar SOAP</button>
          <button id="printSoapBtn" class="btn-print">Imprimir SOAP</button>
        </div>
        <button id="recommendationsBtn">Perguntas essenciais</button>
      </div>

      <div class="soap-block">
        <div class="soap-block-header">
          <span class="soap-label">S</span>
          <button class="copy-soap-btn" data-part="S">Copiar</button>
        </div>
        <textarea id="soapS" class="soap-textarea"></textarea>
      </div>

      <div class="soap-block">
        <div class="soap-block-header">
          <span class="soap-label">O</span>
          <button class="copy-soap-btn" data-part="O">Copiar</button>
        </div>
        <textarea id="soapO" class="soap-textarea"></textarea>
      </div>

      <div class="soap-block">
        <div class="soap-block-header">
          <span class="soap-label">A</span>
          <button class="copy-soap-btn" data-part="A">Copiar</button>
        </div>
        <textarea id="soapA" class="soap-textarea"></textarea>
      </div>

      <div class="soap-block">
        <div class="soap-block-header">
          <span class="soap-label">P</span>
          <button class="copy-soap-btn" data-part="P">Copiar</button>
        </div>
        <textarea id="soapP" class="soap-textarea"></textarea>
      </div>

      <h2>Plano de Cuidados (Prescrição de Enfermagem)</h2>
      <textarea id="prescriptionOutput" class="prescription-textarea"></textarea>

      <div class="prescription-actions">
        <button id="copyPrescriptionBtn" class="btn-copy">Copiar plano de cuidados</button>
        <button id="printBtn" class="btn-print">Imprimir plano de cuidados</button>
      </div>

      <h2>Passagem de Plantão (SBAR)</h2>
      <textarea id="hospitalPrescriptionOutput" class="prescription-textarea"></textarea>

      <div class="prescription-actions">
        <button id="generateHospitalPrescriptionBtn">Gerar SBAR</button>
        <button id="copyHospitalPrescriptionBtn" class="btn-copy">Copiar plano de cuidados hospitalar</button>
        <button id="printHospitalPrescriptionBtn" class="btn-print">Imprimir plano de cuidados hospitalar</button>
      </div>
      <div id="hospitalPrescriptionStatus" class="mini-status"></div>


      <h2>Classificação de risco por cores</h2>
      <div class="risk-triage-box">
        <div class="risk-triage-current">
          <span id="riskTriageBadge" class="risk-badge risk-none">Não informado</span>
          <div id="riskTriageMeaning" class="risk-meaning">Nenhum conteúdo disponível.</div>
        </div>
        <div id="riskTriageLegend" class="risk-legend"></div>
      </div>
      <div class="prescription-actions">
        <button id="copyRiskTriageBtn" class="btn-copy">Copiar classificação de risco</button>
        <button id="printRiskTriageBtn" class="btn-print">Imprimir classificação de risco</button>
      </div>
      <div id="riskTriageStatus" class="mini-status"></div>

      <h2>SAE (Processo de Enfermagem)</h2>
      <div id="pregnancyBox" class="classification-box">Nenhum conteúdo disponível.</div>
      <div class="prescription-actions">
        <button id="copySaeBtn" class="btn-copy">Copiar SAE</button>
        <button id="printPregnancyBtn" class="btn-print">Imprimir SAE</button>
      </div>

      <h2>Orientações ao paciente</h2>
      <div id="lactationBox" class="classification-box">Nenhum conteúdo disponível.</div>
      <div class="prescription-actions">
        <button id="copyOrientationsBtn" class="btn-copy">Copiar orientações</button>
        <button id="printLactationBtn" class="btn-print">Imprimir orientações</button>
      </div>
<div id="classificationsStatus" class="mini-status"></div>
    </div>

    
    <div id="medSafetyCard" class="module-card">
      <h2>Administração segura de medicamentos (registro de enfermagem)</h2>
                  <p class="mini-status" style="margin-top: 0;">
        Use o botão para fotografar a prescrição médica. O sistema irá transcrever o que estiver legível, organizar os medicamentos, apontar riscos e inconsistências relevantes para a enfermagem e sinalizar interações importantes quando for possível confirmar com segurança.
      </p>
<div class="prescription-actions">
        <button id="medPhotoBtn" class="photo-btn">Tirar foto</button>
        <button id="copyMedSafetyBtn" class="btn-copy">Copiar segurança dos medicamentos</button>
        <button id="printMedSafetyBtn" class="btn-print">Imprimir segurança dos medicamentos</button>
      </div>

      <div id="interactionsStatus" class="mini-status"></div>
      <div id="interactionsBox" class="classification-box">Nenhum conteúdo disponível.</div>

      <input id="medCameraInput" class="hidden-input" type="file" accept="image/*" capture="environment" />
      <input id="medFileInput" class="hidden-input" type="file" accept="image/*" />
    </div>

    <div id="woundCard" class="module-card">
      <h2>Curativos e feridas</h2>
      <p class="mini-status" style="margin-top: 0;">
        Use o botão para fotografar a lesão. O sistema irá descrever apenas o que for visível na imagem e sugerir cuidados de enfermagem e prescrição de curativo de forma segura, sem inventar dados.
      </p>

      <div class="prescription-actions">
        <button id="woundPhotoBtn" class="photo-btn">Tirar foto</button>
        <button id="copyWoundBtn" class="btn-copy">Copiar prescrição e cuidados</button>
        <button id="printWoundBtn" class="btn-print">Imprimir prescrição e cuidados</button>
      </div>

      <div id="presentationsMaxDoseStatus" class="mini-status"></div>
      <div id="presentationsMaxDoseBox" class="classification-box">Nenhum conteúdo disponível.</div>

      <input id="woundCameraInput" class="hidden-input" type="file" accept="image/*" capture="environment" />
      <input id="woundFileInput" class="hidden-input" type="file" accept="image/*" />
    </div>

<div id="medicalDoubtsCard" class="module-card">
      <h2>Dúvidas de Enfermagem</h2>
      <p class="mini-status" style="margin-top: 0;">Digite sua dúvida e pressione Enter para obter uma resposta.</p>
      <input id="medicalDoubtInput" class="text-input" type="text" placeholder="Digite aqui sua dúvida médica e pressione Enter" autocomplete="off" />
      <div id="medicalDoubtStatus" class="mini-status"></div>
      <div id="medicalDoubtAnswer" class="answer-box"></div>
    </div>

        <div id="patientReportCard" class="module-card">
      <h2>Relatórios de Enfermagem</h2>
      <p class="mini-status" style="margin-top: 0;">Grave o conteúdo do relatório em voz alta. Pergunte ao paciente qual a finalidade do relatório e peça que ele diga claramente durante a gravação (por exemplo: INSS, CAPS/saúde mental, escola, trabalho, advogado, assistência social, aquisição de insumos). Ao encerrar, a própria gravação será usada para identificar a finalidade e gerar automaticamente o relatório de enfermagem adequado.</p>

      <div class="inline-input-row">
        <button id="reportRecordBtn" class="small-record-btn start">Gravar relatório</button>
      </div>

      <div id="reportStatus" class="mini-status"></div>

      <textarea id="reportOutput" class="prescription-textarea" placeholder="O relatório gerado aparecerá aqui." style="margin-top: 12px;"></textarea>
    </div>

  </div>

  <div id="recommendationsPanel" class="recommendations-panel">
    <div class="recommendations-header">
      <h3>Perguntas essenciais para anamnese</h3>
      <button id="closeRecommendationsBtn" class="close-panel-btn" aria-label="Fechar painel de recomendações">X</button>
    </div>
    <div id="recommendationsStatus" class="recommendations-status">
      Clique em "Perguntas essenciais" para gerar perguntas complementares essenciais.
    </div>
    <div id="recommendationsList" class="recommendations-list"></div>
    <button id="askQuestionsBtn" class="ask-questions-btn" disabled>Complementar avaliação</button>
    <div id="questionsTimer" class="questions-timer hidden">00:00</div>
    <p class="recommendations-footer">
      Ao clicar em "Complementar avaliação", uma nova gravação será iniciada para você aplicar essas perguntas diretamente ao paciente.
      As respostas serão usadas para atualizar automaticamente o SOAP e a conduta.
    </p>
  </div>


  <div id="imageChoiceOverlay" class="modal-overlay hidden">
    <div class="modal">
      <h3>Selecionar imagem</h3>
      <p>Escolha uma opção.</p>
      <div class="modal-actions">
        <button id="chooseCameraBtn" class="danger">Tirar foto agora</button>
        <button id="chooseFileBtn" class="primary">Escolher arquivo</button>
        <button id="cancelImageChoiceBtn">Cancelar</button>
      </div>
    </div>
  </div>


  <script>
    const BACKEND_URL = "https://consulta-enfermagem-1.onrender.com"; // usa /api (Netlify redirect) ou mesma origem no Render

    let recognition;
    let isRecording = false;
    let isPaused = false;
    let finalTranscript = "";
    let baseTranscript = "";
    let baseTranscriptRaw = "";
    let timerInterval = null;
    let startTime = null;
    let accumulatedSeconds = 0;
    let currentSoapRaw = "";

    // ============================
    // ============================
    // MÓDULO: Perguntas e procedimentos essenciais em tempo real (FLUXO CONTROLADO)
    // ============================
    let interimTranscript = "";

    // Fluxo: aguarda motivo -> gera até 3 perguntas -> enfermeiro marca pergunta feita -> aguarda resposta -> atualiza
    let guidanceEnabled = false;
    let guidanceStage = "aguardando_motivo"; // "aguardando_motivo" | "perguntas"
    let guidancePending = []; // array de strings
    let guidanceConsultType = ""; // string
    let guidanceProceduresBase = []; // array de strings (fixo por tipo de consulta)
    let guidanceProceduresExtra = []; // array de strings (pode variar conforme queixa)

    let guidanceContextLabel = "";
    let guidanceHypothesis = "";
    let guidanceConfidence = 0; // 0..95

    let guidanceInFlight = false;
    let guidanceAskedQuestion = "";
    let guidanceAskedAtLen = 0;
    let guidanceAskedAtTs = 0;
    let guidanceAnswerDebounce = null;
    let guidanceLastPayloadHash = "";
    let guidanceTurnState = "aguardando_pergunta"; // "aguardando_pergunta" | "aguardando_resposta"
    let guidanceChunkStartLen = 0;
    let guidanceSilenceTimer = null;
    let guidanceLastChunkTs = 0;
const recordBtn = document.getElementById("recordBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const timerEl = document.getElementById("timer");
    const micStatus = document.getElementById("micStatus");
    const resultsCard = document.getElementById("resultsCard");
    const soapError = document.getElementById("soapError");
    const printBtn = document.getElementById("printBtn");

    const liveGuidance = document.getElementById("liveGuidance");
    const liveGuidanceContext = document.getElementById("liveGuidanceContext");
    const liveGuidanceStatus = document.getElementById("liveGuidanceStatus");
    const liveGuidanceList = document.getElementById("liveGuidanceList");

    const soapS = document.getElementById("soapS");
    const soapO = document.getElementById("soapO");
    const soapA = document.getElementById("soapA");
    const soapP = document.getElementById("soapP");

    const prescriptionOutput = document.getElementById("prescriptionOutput");

    const hospitalPrescriptionOutput = document.getElementById("hospitalPrescriptionOutput");
    const generateHospitalPrescriptionBtn = document.getElementById("generateHospitalPrescriptionBtn");
    const copyHospitalPrescriptionBtn = document.getElementById("copyHospitalPrescriptionBtn");
    const printHospitalPrescriptionBtn = document.getElementById("printHospitalPrescriptionBtn");
    const hospitalPrescriptionStatus = document.getElementById("hospitalPrescriptionStatus");

    const pregnancyBox = document.getElementById("pregnancyBox");
    const lactationBox = document.getElementById("lactationBox");

    const riskTriageBadge = document.getElementById("riskTriageBadge");
    const riskTriageMeaning = document.getElementById("riskTriageMeaning");
    const riskTriageLegend = document.getElementById("riskTriageLegend");
    const copyRiskTriageBtn = document.getElementById("copyRiskTriageBtn");
    const printRiskTriageBtn = document.getElementById("printRiskTriageBtn");
    const riskTriageStatus = document.getElementById("riskTriageStatus");

    const copySaeBtn = document.getElementById("copySaeBtn");
    const classificationsStatus = document.getElementById("classificationsStatus");
    const printPregnancyBtn = document.getElementById("printPregnancyBtn");
    const printLactationBtn = document.getElementById("printLactationBtn");

    const recommendationsBtn = document.getElementById("recommendationsBtn");
    const recommendationsPanel = document.getElementById("recommendationsPanel");
    const closeRecommendationsBtn = document.getElementById("closeRecommendationsBtn");
    const recommendationsStatus = document.getElementById("recommendationsStatus");
    const recommendationsList = document.getElementById("recommendationsList");
    const askQuestionsBtn = document.getElementById("askQuestionsBtn");
    const questionsTimerEl = document.getElementById("questionsTimer");

    const soapCopyButtons = document.querySelectorAll(".copy-soap-btn");
    const copyPrescriptionBtn = document.getElementById("copyPrescriptionBtn");

    const copyFullSoapBtn = document.getElementById("copyFullSoapBtn");
    const printSoapBtn = document.getElementById("printSoapBtn");

    const medicalDoubtInput = document.getElementById("medicalDoubtInput");
    const medicalDoubtStatus = document.getElementById("medicalDoubtStatus");
    const medicalDoubtAnswer = document.getElementById("medicalDoubtAnswer");


    const medPhotoBtn = document.getElementById("medPhotoBtn");
    const interactionsBox = document.getElementById("interactionsBox");
    const interactionsStatus = document.getElementById("interactionsStatus");
    const copyMedSafetyBtn = document.getElementById("copyMedSafetyBtn");
    const printMedSafetyBtn = document.getElementById("printMedSafetyBtn");
    const medCameraInput = document.getElementById("medCameraInput");
    const medFileInput = document.getElementById("medFileInput");

    const woundPhotoBtn = document.getElementById("woundPhotoBtn");
    const presentationsMaxDoseBox = document.getElementById("presentationsMaxDoseBox");
    const presentationsMaxDoseStatus = document.getElementById("presentationsMaxDoseStatus");
    const copyWoundBtn = document.getElementById("copyWoundBtn");
    const printWoundBtn = document.getElementById("printWoundBtn");
    const woundCameraInput = document.getElementById("woundCameraInput");
    const woundFileInput = document.getElementById("woundFileInput");

    const imageChoiceOverlay = document.getElementById("imageChoiceOverlay");
    const chooseCameraBtn = document.getElementById("chooseCameraBtn");
    const chooseFileBtn = document.getElementById("chooseFileBtn");
    const cancelImageChoiceBtn = document.getElementById("cancelImageChoiceBtn");

    let pendingCameraInput = null;
    let pendingFileInput = null;



    // ============================
    // MÓDULO: Coletar dados essenciais (NOVO)
    // ============================
    const patientInfoBtn = document.getElementById("patientInfoBtn");
    const patientInfoTimerEl = document.getElementById("patientInfoTimer");
    const patientInfoStatus = document.getElementById("patientInfoStatus");
    const patientInfoSummary = document.getElementById("patientInfoSummary");

    let patientContext = { nome: null, idade: null, peso_kg: null };

    let patientInfoRecognition = null;
    let patientInfoIsRecording = false;
    let patientInfoFinalTranscript = "";
    let patientInfoTimerInterval = null;
    let patientInfoStartTime = null;
    let patientInfoAccumulatedSeconds = 0;

    function resetPatientInfoTimer() {
      patientInfoAccumulatedSeconds = 0;
      patientInfoStartTime = null;
      if (patientInfoTimerInterval) clearInterval(patientInfoTimerInterval);
      patientInfoTimerInterval = null;
      if (patientInfoTimerEl) patientInfoTimerEl.textContent = "00:00";
    }

    function updatePatientInfoTimer() {
      const now = Date.now();
      const seconds = patientInfoAccumulatedSeconds + Math.floor((now - patientInfoStartTime) / 1000);
      const m = ("0" + Math.floor(seconds / 60)).slice(-2);
      const s = ("0" + (seconds % 60)).slice(-2);
      if (patientInfoTimerEl) patientInfoTimerEl.textContent = `${m}:${s}`;
    }

    function startPatientInfoTimer() {
      patientInfoStartTime = Date.now();
      if (patientInfoTimerInterval) clearInterval(patientInfoTimerInterval);
      patientInfoTimerInterval = setInterval(updatePatientInfoTimer, 200);
    }

    function stopPatientInfoTimer() {
      if (!patientInfoStartTime) return;
      const now = Date.now();
      patientInfoAccumulatedSeconds += Math.floor((now - patientInfoStartTime) / 1000);
      patientInfoStartTime = null;
      if (patientInfoTimerInterval) clearInterval(patientInfoTimerInterval);
      patientInfoTimerInterval = null;
    }

    function formatPatientSummary(ctx) {
      const parts = [];
      if (ctx?.nome) parts.push(`Nome: ${ctx.nome}`);
      if (ctx?.idade) parts.push(`Idade: ${ctx.idade}`);
      if (ctx?.peso_kg !== null && ctx?.peso_kg !== undefined) parts.push(`Peso: ${ctx.peso_kg} kg`);
      return parts.length ? parts.join(" | ") : "";
    }

    function buildTranscriptWithPatientContext(rawTranscript) {
      let t = String(rawTranscript || "").trim();
      if (!t) return "";

      t = t.replace(/^Dados do paciente:[\s\S]*?\n{2,}/i, "").trim();

      const hasAny = !!(patientContext?.nome || patientContext?.idade || (patientContext?.peso_kg !== null && patientContext?.peso_kg !== undefined));
      if (!hasAny) return t;

      const headerParts = [];
      if (patientContext.nome) headerParts.push(`Nome completo: ${patientContext.nome}.`);
      if (patientContext.idade) headerParts.push(`Idade: ${patientContext.idade}.`);
      if (patientContext.peso_kg !== null && patientContext.peso_kg !== undefined) headerParts.push(`Peso: ${patientContext.peso_kg} kg.`);

      const header = `Dados do paciente: ${headerParts.join(" ")}\n\n`;
      return header + t;
    }

    function initPatientInfoSpeech() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) return false;

      patientInfoRecognition = new SR();
      patientInfoRecognition.lang = "pt-BR";
      patientInfoRecognition.continuous = true;
      patientInfoRecognition.interimResults = true;

      patientInfoRecognition.onresult = (event) => {
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const txt = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            patientInfoFinalTranscript += txt + " ";
          }
        }
      };

      patientInfoRecognition.onerror = (e) => {
        console.warn("Erro no reconhecimento (dados do paciente):", e);
      };

      return true;
    }

    
    function getNursingContext() {
      const t = (baseTranscriptRaw || baseTranscript || finalTranscript || "").trim();
      const s = (soapS?.value || "").trim();
      const o = (soapO?.value || "").trim();
      const a = (soapA?.value || "").trim();
      const p = (soapP?.value || "").trim();
      const plano = (prescriptionOutput?.value || "").trim();
      const sbar = (hospitalPrescriptionOutput?.value || "").trim();
      const parts = [];
      if (t) parts.push("TRANSCRIÇÃO:\n" + t);
      if (s || o || a || p) parts.push("EVOLUÇÃO (SOAP):\nS: " + s + "\nO: " + o + "\nA: " + a + "\nP: " + p);
      if (plano) parts.push("PLANO DE CUIDADOS:\n" + plano);
      if (sbar) parts.push("SBAR:\n" + sbar);
      return parts.join("\n\n").trim();
    }

    // ============================
    // MÓDULO: Classificação de risco por cores (NOVO)
    // ============================
    const RISK_LEGEND_DEFAULT = [
      { cor: "Vermelho", significado: "Emergência. Atendimento imediato." },
      { cor: "Laranja", significado: "Muito urgente. Prioridade alta de atendimento." },
      { cor: "Amarelo", significado: "Urgente. Necessita avaliação em curto prazo." },
      { cor: "Verde", significado: "Pouco urgente. Pode aguardar com segurança, mantendo reavaliação se piora." },
      { cor: "Azul", significado: "Não urgente. Caso de baixa gravidade, orientar e agendar conforme necessidade." }
    ];

    function normalizeRiskColorLabel(label) {
      const t = String(label || "").trim().toLowerCase();
      if (!t) return "Não informado";
      if (t.includes("vermelh")) return "Vermelho";
      if (t.includes("laranj")) return "Laranja";
      if (t.includes("amarel")) return "Amarelo";
      if (t.includes("verd")) return "Verde";
      if (t.includes("azul")) return "Azul";
      if (t.includes("nao informado") || t.includes("não informado") || t.includes("indefin")) return "Não informado";
      return label.trim();
    }

    function applyRiskBadgeColor(cor) {
      if (!riskTriageBadge) return;
      riskTriageBadge.classList.remove("risk-none", "risk-vermelho", "risk-laranja", "risk-amarelo", "risk-verde", "risk-azul");
      const c = normalizeRiskColorLabel(cor);
      if (c === "Vermelho") riskTriageBadge.classList.add("risk-vermelho");
      else if (c === "Laranja") riskTriageBadge.classList.add("risk-laranja");
      else if (c === "Amarelo") riskTriageBadge.classList.add("risk-amarelo");
      else if (c === "Verde") riskTriageBadge.classList.add("risk-verde");
      else if (c === "Azul") riskTriageBadge.classList.add("risk-azul");
      else riskTriageBadge.classList.add("risk-none");
    }

    function renderRiskLegend(legendArr) {
      if (!riskTriageLegend) return;
      const legend = Array.isArray(legendArr) && legendArr.length ? legendArr : RISK_LEGEND_DEFAULT;

      riskTriageLegend.innerHTML = "";
      legend.forEach((item) => {
        const cor = normalizeRiskColorLabel(item?.cor || "");
        const significado = String(item?.significado || "").trim();

        const row = document.createElement("div");
        row.className = "risk-legend-row";

        const swatch = document.createElement("div");
        swatch.className = "risk-legend-swatch " + (
          cor === "Vermelho" ? "swatch-vermelho" :
          cor === "Laranja" ? "swatch-laranja" :
          cor === "Amarelo" ? "swatch-amarelo" :
          cor === "Verde" ? "swatch-verde" :
          cor === "Azul" ? "swatch-azul" : ""
        );

        const txt = document.createElement("div");
        txt.style.flex = "1";
        txt.textContent = cor + (significado ? (": " + significado) : "");

        row.appendChild(swatch);
        row.appendChild(txt);
        riskTriageLegend.appendChild(row);
      });
    }

    function buildRiskPrintText(cor, significado, legendArr) {
      const c = normalizeRiskColorLabel(cor);
      const s = String(significado || "").trim();
      const legend = Array.isArray(legendArr) && legendArr.length ? legendArr : RISK_LEGEND_DEFAULT;

      const lines = [];
      lines.push("Classificação de risco: " + c);
      if (s) lines.push("Significado: " + s);
      lines.push("");
      lines.push("Legenda:");
      legend.forEach((it) => {
        const lc = normalizeRiskColorLabel(it?.cor || "");
        const ls = String(it?.significado || "").trim();
        lines.push(lc + ": " + ls);
      });
      return lines.join("\n");
    }

    async function updateRiskTriage() {
      if (!riskTriageStatus) return;

      const contexto = getNursingContext();
      if (!contexto) {
        if (riskTriageBadge) {
          riskTriageBadge.textContent = "Não informado";
          applyRiskBadgeColor("Não informado");
        }
        if (riskTriageMeaning) riskTriageMeaning.textContent = "Nenhum conteúdo disponível.";
        renderRiskLegend(RISK_LEGEND_DEFAULT);
        riskTriageStatus.textContent = "Sem conteúdo suficiente para classificar.";
        return;
      }

      riskTriageStatus.textContent = "Gerando classificação de risco...";
      riskTriageStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/classificacao-risco", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ contexto })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (classificação de risco):", resp.status, txt);
          riskTriageStatus.classList.remove("loading-dot");
          riskTriageStatus.textContent = "Não foi possível gerar a classificação de risco.";
          return;
        }

        const data = await resp.json();

        const cor = normalizeRiskColorLabel(data?.cor || "Não informado");
        const significado = String(data?.significado || "").trim();
        const legenda = Array.isArray(data?.legenda) ? data.legenda : RISK_LEGEND_DEFAULT;

        if (riskTriageBadge) {
          riskTriageBadge.textContent = cor;
          applyRiskBadgeColor(cor);
        }
        if (riskTriageMeaning) {
          riskTriageMeaning.textContent = significado ? significado : "Sem significado disponível.";
        }
        renderRiskLegend(legenda);

        // Guarda texto para impressão
        riskTriageMeaning.dataset.printText = buildRiskPrintText(cor, significado, legenda);

        riskTriageStatus.classList.remove("loading-dot");
        riskTriageStatus.textContent = "Classificação atualizada.";
      } catch (e) {
        console.error(e);
        riskTriageStatus.classList.remove("loading-dot");
        riskTriageStatus.textContent = "Falha de rede ou backend ao gerar a classificação de risco.";
      }
    }


async function generateSoapAndPrescriptionFromTranscript(transcricao, statusText) {
      const t = String(transcricao || "").trim();
      if (!t) return;

      soapError.textContent = "";
      micStatus.innerText = statusText || "Atualizando SOAP e prescrição...";
      micStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/gerar-soap", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao: t })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend:", resp.status, txt);
          soapError.textContent = "Erro ao gerar evolução/plano de cuidados. Verifique o backend e tente novamente.";
          micStatus.innerText = "Falha ao gerar o resumo.";
          micStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const soap = data.soap || "";
        const prescricao = data.prescricao || "";

        updateSoapFromString(soap);
        prescriptionOutput.value = prescricao;
        printBtn.style.display = prescricao ? "inline-block" : "none";

        micStatus.innerText = "Atualização concluída.";
        micStatus.classList.remove("loading-dot");

        await updateClassifications();
        await updateRiskTriage();
        } catch (e) {
        console.error(e);
        soapError.textContent = "Erro ao gerar evolução e plano de cuidados (falha de rede ou backend).";
        micStatus.innerText = "Falha ao gerar o resumo.";
        micStatus.classList.remove("loading-dot");
      }
    }

    async function applyPatientContextAndRefreshAll() {
      const rawCandidate = (baseTranscriptRaw || "").trim() || (finalTranscript || "").trim() || (baseTranscript || "").trim();
      if (!rawCandidate) {
        patientInfoStatus.textContent = "Não há transcrição da consulta para atualizar.";
        return;
      }

      const cleanedRaw = rawCandidate.replace(/^Dados do paciente:[\s\S]*?\n{2,}/i, "").trim();
      baseTranscriptRaw = cleanedRaw;

      const transcricaoAtualizada = buildTranscriptWithPatientContext(cleanedRaw);
      baseTranscript = transcricaoAtualizada;

      await generateSoapAndPrescriptionFromTranscript(transcricaoAtualizada, "Atualizando SOAP e prescrição com nome/idade/peso...");
}

    async function startPatientInfoRecording() {
      if (!patientInfoBtn) return;

      patientInfoStatus.textContent = "Gravando... Dite nome completo, idade e peso.";
      patientInfoStatus.classList.add("loading-dot");
      patientInfoBtn.textContent = "Finalizar nome/idade/peso";

      patientInfoFinalTranscript = "";
      resetPatientInfoTimer();
      startPatientInfoTimer();

      try { if (recognition) recognition.stop(); } catch (e) {}
      try { if (questionsRecognition) questionsRecognition.stop(); } catch (e) {}
      try { if (reportRecognition) reportRecognition.stop(); } catch (e) {}

      if (!patientInfoRecognition) {
        const ok = initPatientInfoSpeech();
        if (!ok) {
          patientInfoStatus.classList.remove("loading-dot");
          patientInfoStatus.textContent = "Navegador sem suporte a reconhecimento de voz.";
          patientInfoBtn.textContent = "Coletar dados essenciais";
          stopPatientInfoTimer();
          return;
        }
      }

      patientInfoIsRecording = true;
      try {
        patientInfoRecognition.start();
      } catch (e) {
        console.warn("Erro ao iniciar reconhecimento (dados do paciente):", e);
      }
    }

    async function stopPatientInfoRecordingAndApply() {
      patientInfoIsRecording = false;
      stopPatientInfoTimer();

      patientInfoBtn.textContent = "Coletar dados essenciais";

      if (patientInfoRecognition) {
        try { patientInfoRecognition.stop(); } catch (e) {}
      }

      const transcricaoCurta = patientInfoFinalTranscript.trim();
      if (!transcricaoCurta) {
        patientInfoStatus.classList.remove("loading-dot");
        patientInfoStatus.textContent = "Nenhuma fala foi capturada.";
        return;
      }

      patientInfoStatus.textContent = "Processando nome/idade/peso...";
      patientInfoStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/extrair-dados-paciente", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao: transcricaoCurta })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (dados do paciente):", resp.status, txt);
          patientInfoStatus.classList.remove("loading-dot");
          patientInfoStatus.textContent = "Não foi possível extrair os dados do paciente.";
          return;
        }

        const data = await resp.json();
        patientContext = {
          nome: (data?.nome || null),
          idade: (data?.idade || null),
          peso_kg: (typeof data?.peso_kg === "number" && Number.isFinite(data.peso_kg)) ? data.peso_kg : null
        };

        const resumo = formatPatientSummary(patientContext);
        patientInfoSummary.textContent = resumo ? resumo : "Dados do paciente não identificados com segurança.";
        patientInfoStatus.classList.remove("loading-dot");
        patientInfoStatus.textContent = resumo ? "Dados do paciente atualizados." : "Sem dados suficientes para atualizar.";

        await applyPatientContextAndRefreshAll();
      } catch (e) {
        console.error(e);
        patientInfoStatus.classList.remove("loading-dot");
        patientInfoStatus.textContent = "Falha de rede ou backend ao extrair dados do paciente.";
      }
    }

    if (patientInfoBtn) {
      patientInfoBtn.addEventListener("click", async () => {
        if (patientInfoIsRecording) {
          await stopPatientInfoRecordingAndApply();
        } else {
          await startPatientInfoRecording();
        }
      });
    }

    const reportRecordBtn = document.getElementById("reportRecordBtn");
    const reportStatus = document.getElementById("reportStatus");
    const reportOutput = document.getElementById("reportOutput");


    let reportRecognition = null;
    let reportIsRecording = false;
    let reportIsPaused = false;
    let reportFinalTranscript = "";

    // Rodada adicional de perguntas (aba lateral)
    let questionsRecognition = null;
    let questionsIsRecording = false;
    let questionsFinalTranscript = "";
    let questionsTimerInterval = null;
    let questionsStartTime = null;
    let questionsAccumulatedSeconds = 0;

    function escapeHtml(text) {
      return String(text || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }

    // ============================
    // ============================
    // Perguntas e procedimentos essenciais em tempo real (FLUXO CONTROLADO)
    // ============================
    function renderLiveGuidance() {
      if (!liveGuidance || !liveGuidanceList || !liveGuidanceStatus || !liveGuidanceContext) return;

      if (!isRecording) {
        liveGuidanceContext.textContent = "";
        liveGuidanceStatus.textContent = "Inicie o atendimento para receber perguntas e procedimentos necessários em tempo real.";
        liveGuidanceList.innerHTML = "<div class=\"live-guidance-empty\">Nenhuma sugestão por enquanto.</div>";
        return;
      }

      const ctx = (guidanceContextLabel || "").trim();
      const tipoTxt = (guidanceConsultType || "").trim();
      const parts = [];
      if (ctx) parts.push("Atendimento: " + ctx);
      if (tipoTxt) parts.push("Tipo de consulta: " + tipoTxt);
      liveGuidanceContext.textContent = parts.length ? parts.join(" | ") : "";

      if (guidanceStage === "aguardando_motivo") {
        liveGuidanceStatus.textContent = "Aguardando o motivo da consulta. Após o paciente informar o motivo, as perguntas essenciais serão sugeridas.";
        liveGuidanceList.innerHTML = `
          <div class="live-guidance-empty">
            Oriente: acolha e pergunte o motivo da consulta. Após a resposta do paciente, as perguntas essenciais serão sugeridas automaticamente.
            <div style="margin-top:10px;">
              <button id="forceStartGuidanceBtn" class="mini-red-btn" style="background:#b00020;">Motivo já foi informado</button>
            </div>
          </div>
        `;
        const btn = document.getElementById("forceStartGuidanceBtn");
        if (btn) {
          btn.onclick = () => {
            if (guidanceStage !== "aguardando_motivo") return;
            guidanceStage = "perguntas";
            // reinicia detecção de turnos a partir do ponto atual
            guidanceTurnState = "aguardando_pergunta";
            guidanceAskedQuestion = "";
            guidanceAskedAtLen = getCombinedTranscript().length;
            guidanceAskedAtTs = Date.now();
            guidanceChunkStartLen = getCombinedTranscript().length;
            requestGuidanceFromBackend({ evento: "inicial" });
          };
        }
        return;
      }

      // estágio perguntas (controle por turnos: pergunta -> resposta -> atualizar)
      const confTxt = (typeof guidanceConfidence === "number" && guidanceConfidence > 0)
        ? ("Nível de confiança da hipótese principal: " + Math.round(guidanceConfidence) + "% (não chega a 100%).")
        : "";

      const hypo = (guidanceHypothesis || "").trim();
      const hypoTxt = hypo ? ("Hipótese principal: " + hypo + ". " + confTxt) : confTxt;

      if (guidanceTurnState === "aguardando_resposta") {
        liveGuidanceStatus.textContent = "Pergunta em andamento. Aguardando resposta do paciente para atualizar as próximas perguntas...";
      } else if (guidanceInFlight) {
        liveGuidanceStatus.textContent = "Atualizando perguntas essenciais...";
      } else {
        liveGuidanceStatus.textContent = hypoTxt || "Perguntas essenciais sugeridas. Faça uma das perguntas e aguarde a resposta do paciente.";
      }

      
      const baseProcs = Array.isArray(guidanceProceduresBase) ? guidanceProceduresBase : [];
      const extraProcs = Array.isArray(guidanceProceduresExtra) ? guidanceProceduresExtra : [];

      liveGuidanceList.innerHTML = "";

      const makeTitle = (txt) => {
        const t = document.createElement("div");
        t.className = "live-guidance-section-title";
        t.textContent = txt;
        return t;
      };

      const makeItem = (txt, prefix, cls) => {
        const el = document.createElement("div");
        el.className = cls || "live-guidance-item";
        const safe = escapeHtml(String(txt || ""));
        const pfx = prefix ? (escapeHtml(String(prefix)) + " ") : "";
        el.innerHTML = `<div class="live-guidance-item-text">${pfx}${safe}</div>`;
        return el;
      };

      // Perguntas (máximo 3)
      liveGuidanceList.appendChild(makeTitle("Perguntas essenciais (máximo 3)"));

      if (!guidancePending || !guidancePending.length) {
        liveGuidanceList.appendChild(makeItem("Nenhuma pergunta essencial no momento.", "", "live-guidance-empty-item"));
      } else {
        guidancePending.slice(0, 3).forEach((q, idx) => {
          const askedMark = (guidanceAskedQuestion && guidanceAskedQuestion.toLowerCase() === String(q || "").toLowerCase())
            ? " (pergunta feita)"
            : "";
          liveGuidanceList.appendChild(makeItem(String(q || "") + askedMark, (idx + 1) + ".", "live-guidance-item"));
        });
      }

      // Procedimentos (baseados no tipo de consulta) - não devem ficar mudando a toda hora
      if (baseProcs.length) {
        liveGuidanceList.appendChild(makeTitle("Procedimentos do tipo de consulta"));
        baseProcs.forEach((p) => {
          liveGuidanceList.appendChild(makeItem(p, "-", "live-guidance-proc"));
        });
      }

      // Procedimentos adicionais conforme queixa (pode variar)
      if (extraProcs.length) {
        liveGuidanceList.appendChild(makeTitle("Procedimentos adicionais conforme queixa"));
        extraProcs.forEach((p) => {
          liveGuidanceList.appendChild(makeItem(p, "-", "live-guidance-proc"));
        });
      }

    function getCombinedTranscript() {
      const combined = ((finalTranscript || "") + " " + (interimTranscript || "")).trim();
      if (!combined) return "";
      const MAX = 8000;
      return combined.length > MAX ? combined.slice(combined.length - MAX) : combined;
    }

    function hashForGuidancePayload(obj) {
      try {
        const raw = JSON.stringify(obj || {});
        let h = 0;
        for (let i = 0; i < raw.length; i++) {
          h = ((h << 5) - h) + raw.charCodeAt(i);
          h |= 0;
        }
        return String(h);
      } catch {
        return String(Date.now());
      }
    }

    function resetLiveGuidanceState() {
      guidanceEnabled = true;
      guidanceStage = "aguardando_motivo";
      guidancePending = [];
      guidanceConsultType = "";
      guidanceProceduresBase = [];
      guidanceProceduresExtra = [];
      guidanceContextLabel = "";
      guidanceHypothesis = "";
      guidanceConfidence = 0;

      guidanceInFlight = false;

      guidanceTurnState = "aguardando_pergunta";
      guidanceAskedQuestion = "";
      guidanceAskedAtLen = 0;
      guidanceAskedAtTs = 0;

      guidanceChunkStartLen = 0;
      guidanceSilenceTimer && clearTimeout(guidanceSilenceTimer);
      guidanceSilenceTimer = null;

      guidanceLastPayloadHash = "";
      guidanceLastChunkTs = 0;

      renderLiveGuidance();
    }

    function startGuidanceLoop() {
      // Sem polling: só reage a eventos (inicial após motivo e após cada resposta)
      guidanceEnabled = true;
      renderLiveGuidance();
      maybeStartInitialGuidance(false);
    }

    function stopGuidanceLoop() {
      guidanceEnabled = false;
      guidanceInFlight = false;
      guidanceTurnState = "aguardando_pergunta";
      guidanceAskedQuestion = "";
      guidanceSilenceTimer && clearTimeout(guidanceSilenceTimer);
      guidanceSilenceTimer = null;
      renderLiveGuidance();
    }

    function hasLikelyChiefComplaint(text) {
      const t = String(text || "").toLowerCase();
      if (!t) return false;
      const kw = [
        "motivo", "queixa", "pré-natal", "prenatal", "gestante", "pós-parto", "pos parto", "resguardo", "puerp", "puerper", "puericultura", "criança", "crianca", "bebê", "bebe", "vacina", "hiperdia", "planejamento familiar", "anticoncepc", "diu", "dor", "febre", "tosse", "falta de ar", "dispne", "diarre", "vômit",
        "náuse", "enjoo", "garganta", "cefale", "tont", "desmai", "urina", "ardor",
        "corrimento", "sangr", "pressão", "hipertens", "glic", "diabetes", "infec",
        "ferida", "queda", "trauma", "alerg", "coceira", "mancha"
      ];
      return kw.some(k => t.includes(k));
    }

    function maybeStartInitialGuidance(force) {
      if (!guidanceEnabled || !isRecording || isPaused) return;
      if (guidanceStage !== "aguardando_motivo") return;

      const combined = getCombinedTranscript();
      if (!combined || combined.length < 120) return;

      // Evita iniciar antes do paciente realmente falar algo clínico
      if (!force && !hasLikelyChiefComplaint(combined)) return;

      guidanceStage = "perguntas";
      guidanceTurnState = "aguardando_pergunta";
      guidanceAskedQuestion = "";
      guidanceAskedAtLen = combined.length;
      guidanceAskedAtTs = Date.now();
      guidanceChunkStartLen = combined.length;

      requestGuidanceFromBackend({ evento: "inicial" });
    }

    function onTranscriptUpdateForGuidance() {
      if (!guidanceEnabled || !isRecording || isPaused) return;

      // 1) Detecta automaticamente o momento de iniciar (após motivo)
      if (guidanceStage === "aguardando_motivo") {
        maybeStartInitialGuidance(false);
        return;
      }

      // 2) A partir daqui: está em "perguntas". Controla por turnos usando silêncio.
      scheduleGuidanceSilenceFinalize();
    }

    function scheduleGuidanceSilenceFinalize() {
      if (!guidanceEnabled || !isRecording || isPaused) return;

      if (guidanceSilenceTimer) clearTimeout(guidanceSilenceTimer);
      guidanceSilenceTimer = setTimeout(() => {
        finalizeGuidanceChunk();
      }, 1400);
    }

    function finalizeGuidanceChunk() {
      if (!guidanceEnabled || !isRecording || isPaused) return;

      const combined = getCombinedTranscript();
      if (!combined) return;

      if (guidanceChunkStartLen <= 0) {
        guidanceChunkStartLen = combined.length;
        return;
      }

      // Captura apenas o que foi acrescentado desde o último “silêncio”
      const chunk = combined.slice(guidanceChunkStartLen).trim();
      guidanceChunkStartLen = combined.length;

      if (!chunk || chunk.length < 10) return;

      // Evita processar chunks colados em sequência que são só repetição do reconhecimento
      const now = Date.now();
      if (guidanceLastChunkTs && (now - guidanceLastChunkTs) < 900) return;
      guidanceLastChunkTs = now;

      handleGuidanceUtteranceChunk(chunk);
    }

    function stripAccents(s) {
      return String(s || "")
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "");
    }

    function tokenizePt(s) {
      const t = stripAccents(String(s || "").toLowerCase())
        .replace(/[^a-z0-9\s]/g, " ")
        .replace(/\s+/g, " ")
        .trim();

      if (!t) return [];

      const stop = new Set([
        "a","o","os","as","um","uma","uns","umas","de","do","da","dos","das","no","na","nos","nas",
        "em","para","por","com","sem","e","ou","que","qual","quais","quando","como","onde","porque",
        "ao","aos","à","às","se","já","não","sim","me","te","lhe","eles","elas","você","vocês",
        "eu","tu","ele","ela","nós","vos","isso","isto","aquilo","essa","esse","este","esta",
        "tem","tá","está","foi","era","são","ser","ter","há"
      ]);

      return t.split(" ").filter(w => w && w.length > 2 && !stop.has(w));
    }

    function jaccardSimilarity(aTokens, bTokens) {
      const A = new Set(aTokens || []);
      const B = new Set(bTokens || []);
      if (!A.size || !B.size) return 0;
      let inter = 0;
      for (const w of A) if (B.has(w)) inter++;
      const union = A.size + B.size - inter;
      return union ? (inter / union) : 0;
    }

    function matchQuestionFromUtterance(utterance, questions) {
      const qs = Array.isArray(questions) ? questions : [];
      if (!qs.length) return "";
      const uTok = tokenizePt(utterance);
      if (!uTok.length) return "";

      let bestQ = "";
      let bestScore = 0;

      for (const q of qs.slice(0, 3)) {
        const score = jaccardSimilarity(uTok, tokenizePt(q));
        if (score > bestScore) {
          bestScore = score;
          bestQ = q;
        }
      }

      // Se a similaridade for baixa, não “chuta” qual foi, para não apagar/alterar errado.
      if (bestScore < 0.18) return "";
      return String(bestQ || "").trim();
    }

    function handleGuidanceUtteranceChunk(chunkText) {
      if (!chunkText) return;
      if (!guidancePending || !guidancePending.length) return;
      if (guidanceInFlight) return;

      // Turno 1: o enfermeiro faz uma pergunta (a partir das 3 sugeridas)
      if (guidanceTurnState === "aguardando_pergunta") {
        const matched = matchQuestionFromUtterance(chunkText, guidancePending);

        guidanceAskedQuestion = matched ? matched : "";
        guidanceAskedAtTs = Date.now();
        guidanceAskedAtLen = getCombinedTranscript().length;

        guidanceTurnState = "aguardando_resposta";
        renderLiveGuidance();
        return;
      }

      // Turno 2: o paciente responde -> atualiza as perguntas
      if (guidanceTurnState === "aguardando_resposta") {
        const dt = Date.now() - (guidanceAskedAtTs || 0);
        if (dt < 900) return; // evita disparo imediato

        // Atualiza com base no diálogo novo
        requestGuidanceFromBackend({ evento: "resposta", ultima_fala: chunkText });
        return;
      }
    }

    async function requestGuidanceFromBackend({ evento, ultima_fala }) {
      if (guidanceInFlight) return;
      if (!guidanceEnabled || !isRecording || isPaused) return;

      const combined = getCombinedTranscript();
      if (!combined || combined.length < 50) {
        renderLiveGuidance();
        return;
      }

      const payload = {
        transcricao: combined,
        estado: guidanceStage,
        evento: evento || "stream",
        pergunta_feita: guidanceAskedQuestion || "",
        perguntas_pendentes: Array.isArray(guidancePending) ? guidancePending.slice(0, 3) : [],
        tipo_consulta_atual: (guidanceConsultType || ""),
        confianca_atual: typeof guidanceConfidence === "number" ? guidanceConfidence : 0,
        hipotese_atual: guidanceHypothesis || "",
        ultima_fala: typeof ultima_fala === "string" ? ultima_fala.slice(0, 800) : ""
      };

      const h = hashForGuidancePayload(payload);
      if (h === guidanceLastPayloadHash && evento !== "inicial" && evento !== "resposta") return;
      guidanceLastPayloadHash = h;

      guidanceInFlight = true;
      renderLiveGuidance();

      try {
        const resp = await fetch(BACKEND_URL + "/api/guia-tempo-real", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        if (!resp.ok) {
          const txt = await resp.text();
          console.error("Erro HTTP do backend (guia em tempo real):", resp.status, txt);
          return;
        }

        const data = await resp.json();

        const prevTipo = (guidanceConsultType || "").trim();
        const tipo = String(
          data.tipo_consulta || data.tipo_consulta_identificada || data.tipo || ""
        ).trim();

        if (tipo && tipo !== prevTipo) {
          guidanceConsultType = tipo;

          const pb = Array.isArray(data.procedimentos_base) ? data.procedimentos_base : [];
          const pbNorm = pb.map(x => String(x || "").trim()).filter(Boolean);
          if (pbNorm.length) guidanceProceduresBase = pbNorm;

        } else if (tipo && !prevTipo) {
          guidanceConsultType = tipo;
        }

        const pe = Array.isArray(data.procedimentos_adicionais) ? data.procedimentos_adicionais : [];
        guidanceProceduresExtra = pe.map(x => String(x || "").trim()).filter(Boolean).slice(0, 10);

        guidanceContextLabel = data.contexto || guidanceContextLabel || "";
        guidanceHypothesis = data.hipotese_principal || guidanceHypothesis || "";
        if (typeof data.confianca === "number") guidanceConfidence = data.confianca;

        const itens = Array.isArray(data.perguntas) ? data.perguntas : (Array.isArray(data.itens) ? data.itens : []);
        const normalized = itens.map(x => String(x || "").trim()).filter(Boolean);

        guidancePending = normalized.slice(0, 3);

        // Após atualizar, volta a aguardar a próxima pergunta do enfermeiro
        if (evento === "resposta") {
          guidanceTurnState = "aguardando_pergunta";
          guidanceAskedQuestion = "";
          guidanceAskedAtLen = combined.length;
          guidanceAskedAtTs = Date.now();
          guidanceChunkStartLen = combined.length;
        }

        // Após gerar as perguntas iniciais, aguarda a primeira pergunta do enfermeiro
        if (evento === "inicial") {
          guidanceTurnState = "aguardando_pergunta";
          guidanceAskedQuestion = "";
          guidanceAskedAtLen = combined.length;
          guidanceAskedAtTs = Date.now();
          guidanceChunkStartLen = combined.length;
        }
      } catch (err) {
        console.error("Falha ao buscar guia em tempo real:", err);
      } finally {
        guidanceInFlight = false;
        renderLiveGuidance();
      }
    }
function initSpeech() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        micStatus.innerText =
          "Seu navegador não suporta reconhecimento de voz. Use Google Chrome em um computador.";
        return;
      }
      recognition = new SR();
      recognition.lang = "pt-BR";
      recognition.continuous = true;
      recognition.interimResults = true;

      recognition.onresult = (event) => {
        let interim = "";
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            finalTranscript += transcript + " ";
          } else {
            interim += transcript;
          }
        }

        interimTranscript = interim.trim();
        // Atualiza o fluxo de perguntas/procedimentos (somente quando necessário)
        onTranscriptUpdateForGuidance();
      };

      recognition.onerror = (event) => {
        console.error("Erro no reconhecimento de voz:", event.error);
        if (event.error === "not-allowed" || event.error === "service-not-allowed") {
          micStatus.innerText =
            "Permita o acesso ao microfone nas configurações do navegador e tente novamente.";
        } else {
          micStatus.innerText =
            "Ocorreu um erro no reconhecimento de voz. Tente novamente.";
        }
      };

      recognition.onend = () => {
        if (isRecording && !isPaused) {
          try {
            recognition.start();
          } catch (err) {
            console.warn("Não foi possível retomar reconhecimento:", err);
          }
        }
      };
    }

    function updateTimer() {
      const now = Date.now();
      const seconds = accumulatedSeconds + Math.floor((now - startTime) / 1000);
      const m = ("0" + Math.floor(seconds / 60)).slice(-2);
      const s = ("0" + (seconds % 60)).slice(-2);
      timerEl.innerText = `${m}:${s}`;
    }

    function startTimer() {
      startTime = Date.now();
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(updateTimer, 500);
    }

    function pauseTimer() {
      if (!startTime) return;
      const now = Date.now();
      accumulatedSeconds += Math.floor((now - startTime) / 1000);
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
    }

    function resetTimer() {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
      startTime = null;
      accumulatedSeconds = 0;
      timerEl.innerText = "00:00";
    }

    function resetNewModulesUI() {
      hospitalPrescriptionOutput.value = "";
      hospitalPrescriptionStatus.textContent = "";
      classificationsStatus.textContent = "";
      pregnancyBox.textContent = "Nenhum conteúdo disponível.";
      lactationBox.textContent = "Nenhum conteúdo disponível.";
      if (interactionsBox) interactionsBox.textContent = "Nenhum conteúdo disponível.";
      if (interactionsStatus) interactionsStatus.textContent = "";
      if (presentationsMaxDoseBox) presentationsMaxDoseBox.textContent = "Nenhum conteúdo disponível.";
      if (presentationsMaxDoseStatus) presentationsMaxDoseStatus.textContent = "";
    }

    async function finalizarConsulta() {
      soapError.textContent = "";
      micStatus.innerText = "Gerando SOAP e prescrição com base na gravação...";
      micStatus.classList.add("loading-dot");

      if (recognition) {
        try {
          recognition.stop();
        } catch (e) {
          console.warn("Erro ao parar reconhecimento:", e);
        }
      }

      pauseTimer();

      const transcricao = finalTranscript.trim();
      if (!transcricao) {
        micStatus.classList.remove("loading-dot");
        micStatus.innerText =
          "Nenhuma fala foi capturada. Verifique o microfone e tente novamente.";
        return;
      }

      baseTranscriptRaw = transcricao;

      const transcricaoParaGeracao = buildTranscriptWithPatientContext(transcricao);
      baseTranscript = transcricaoParaGeracao;

      try {
        const resp = await fetch(BACKEND_URL + "/api/gerar-soap", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao: transcricaoParaGeracao })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend:", resp.status, txt);
          soapError.textContent =
            "Erro ao gerar evolução/plano de cuidados. Verifique o backend e tente novamente.";
          micStatus.innerText = "Falha ao gerar o resumo.";
          micStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const soap = data.soap || "";
        const prescricao = data.prescricao || "";

        updateSoapFromString(soap);

        prescriptionOutput.value = prescricao;
        printBtn.style.display = prescricao ? "inline-block" : "none";

        micStatus.innerText = "Consulta encerrada. SOAP e prescrição gerados.";
        micStatus.classList.remove("loading-dot");

        await updateClassifications();
        await updateRiskTriage();
        } catch (e) {
        console.error(e);
        soapError.textContent =
          "Erro ao gerar evolução e plano de cuidados (falha de rede ou backend).";
        micStatus.innerText = "Falha ao gerar o resumo.";
        micStatus.classList.remove("loading-dot");
      }
    }

    function splitSoap(soapText) {
      const sections = { S: "", O: "", A: "", P: "" };
      if (!soapText) return sections;

      const regex = /\b([SOAP])\s*:\s*([\s\S]*?)(?=\b[SOAP]\s*:|$)/g;
      let match;
      while ((match = regex.exec(soapText)) !== null) {
        const key = match[1].toUpperCase();
        sections[key] = match[2].trim();
      }
      return sections;
    }

    function updateSoapFromString(soapText) {
      currentSoapRaw = soapText || "";
      const parts = splitSoap(currentSoapRaw);

      soapS.value = parts.S || "";
      soapO.value = parts.O || "";
      soapA.value = parts.A || "";
      soapP.value = parts.P || "";

      resultsCard.classList.remove("hidden");
    }

    function getCombinedSoapFromFields() {
      const s = soapS.value.trim();
      const o = soapO.value.trim();
      const a = soapA.value.trim();
      const p = soapP.value.trim();

      let combined = "";
      if (s) combined += "S: " + s + "\n";
      if (o) combined += "O: " + o + "\n";
      if (a) combined += "A: " + a + "\n";
      if (p) combined += "P: " + p;
      currentSoapRaw = combined;
      return combined;
    }


    function formatInteractionsList(interacoes, observacoes) {
      const items = Array.isArray(interacoes) ? interacoes : [];
      if (!items.length) {
        const obs = (observacoes || "").trim();
        return obs
          ? ("Nenhuma interação clinicamente relevante identificada com segurança para os medicamentos prescritos.\n\nObservações:\n" + obs)
          : "Nenhuma interação clinicamente relevante identificada com segurança para os medicamentos prescritos.";
      }

      const parts = [];
      for (const it of items) {
        const meds = Array.isArray(it?.medicamentos) ? it.medicamentos : [];
        const a = meds[0] ? String(meds[0]) : "não informado";
        const b = meds[1] ? String(meds[1]) : "não informado";
        const grav = it?.gravidade ? String(it.gravidade) : "indeterminada";
        const desc = it?.descricao ? String(it.descricao) : "";
        const riscos = it?.riscos ? String(it.riscos) : "";
        const conduta = it?.conduta ? String(it.conduta) : "";

        let block = a + " + " + b + " (gravidade: " + grav + ")";
        if (desc.trim()) block += "\nInteração: " + desc.trim();
        if (riscos.trim()) block += "\nRiscos: " + riscos.trim();
        if (conduta.trim()) block += "\nConduta: " + conduta.trim();
        parts.push(block);
      }

      const obs = (observacoes || "").trim();
      if (obs) {
        parts.push("Observações:\n" + obs);
      }
      return parts.join("\n\n");
    }


    async function updateMedicationSafetyFromContext(contexto) {
      if (!interactionsBox || !interactionsStatus) return;

      interactionsStatus.textContent = "Gerando registro de administração segura...";
      interactionsStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/interacoes-medicamentosas", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ contexto })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP:", resp.status, txt);
          interactionsBox.textContent = "Falha ao gerar registro.";
          return;
        }

        const data = await resp.json().catch(() => ({}));
        interactionsBox.textContent = (data.registro || "").trim() || "Nenhum conteúdo disponível.";
      } catch (e) {
        console.error(e);
        interactionsBox.textContent = "Falha ao gerar registro (rede/backend).";
      } finally {
        interactionsStatus.classList.remove("loading-dot");
        interactionsStatus.textContent = "";
      }
    }

    function formatPresentationsMaxDoseList(itens) {
      const items = Array.isArray(itens) ? itens : [];
      if (!items.length) {
        return "Nenhuma informação disponível para os medicamentos prescritos.";
      }

      const lines = [];
      for (const it of items) {
        const med = it?.medicamento ? String(it.medicamento).trim() : "não informado";
        const a = it?.apresentacoes || {};
        const doseMax = it?.dosagem_maxima_diaria ? String(it.dosagem_maxima_diaria).trim() : "";

        lines.push("Medicamento: " + med);
        lines.push("Apresentações disponíveis:");

        const map = [
          ["Comprimido simples", a.comprimido_simples],
          ["Comprimido revestido", a.comprimido_revestido],
          ["Cápsula", a.capsula],
          ["Suspensão oral", a.suspensao_oral],
          ["Gotas", a.gotas],
          ["Solução oral", a.solucao_oral],
          ["Solução injetável", a.solucao_injetavel],
          ["Endovenosa", a.endovenosa],
          ["Intramuscular", a.intramuscular]
        ];

        for (const [label, val] of map) {
          const v = String(val || "").trim() || "não informado";
          lines.push("- " + label + ": " + v);
        }

        lines.push("Dosagem máxima diária: " + (doseMax || "não informado"));
        lines.push("");
      }

      return lines.join("\n").trim();
    }


    async function updateWoundCareFromContext(contexto) {
      if (!presentationsMaxDoseBox || !presentationsMaxDoseStatus) return;

      presentationsMaxDoseStatus.textContent = "Gerando registro de curativos e feridas...";
      presentationsMaxDoseStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/apresentacoes-dosagem-maxima", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ contexto })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP:", resp.status, txt);
          presentationsMaxDoseBox.textContent = "Falha ao gerar curativos.";
          return;
        }

        const data = await resp.json().catch(() => ({}));
        presentationsMaxDoseBox.textContent = (data.curativos || "").trim() || "Nenhum conteúdo disponível.";
      } catch (e) {
        console.error(e);
        presentationsMaxDoseBox.textContent = "Falha ao gerar curativos (rede/backend).";
      } finally {
        presentationsMaxDoseStatus.classList.remove("loading-dot");
        presentationsMaxDoseStatus.textContent = "";
      }
    }

    function updateQuestionsTimer() {
      const now = Date.now();
      const seconds = questionsAccumulatedSeconds + Math.floor((now - questionsStartTime) / 1000);
      const m = ("0" + Math.floor(seconds / 60)).slice(-2);
      const s = ("0" + (seconds % 60)).slice(-2);
      questionsTimerEl.innerText = `${m}:${s}`;
    }

    function startQuestionsTimer() {
      questionsStartTime = Date.now();
      if (questionsTimerInterval) clearInterval(questionsTimerInterval);
      questionsTimerInterval = setInterval(updateQuestionsTimer, 500);
    }

    function pauseQuestionsTimer() {
      if (!questionsStartTime) return;
      const now = Date.now();
      questionsAccumulatedSeconds += Math.floor((now - questionsStartTime) / 1000);
      if (questionsTimerInterval) clearInterval(questionsTimerInterval);
      questionsTimerInterval = null;
    }

    function resetQuestionsTimer() {
      if (questionsTimerInterval) clearInterval(questionsTimerInterval);
      questionsTimerInterval = null;
      questionsStartTime = null;
      questionsAccumulatedSeconds = 0;
      questionsTimerEl.innerText = "00:00";
    }

    function initQuestionsSpeech() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        return null;
      }

      const rec = new SR();
      rec.lang = "pt-BR";
      rec.continuous = true;
      rec.interimResults = true;

      rec.onresult = (event) => {
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            questionsFinalTranscript += transcript + " ";
          }
        }
      };

      rec.onerror = (event) => {
        console.error("Erro no reconhecimento das perguntas:", event.error);
        recommendationsStatus.textContent =
          "Ocorreu um erro no reconhecimento de voz das perguntas. Tente novamente.";
        recommendationsStatus.classList.remove("loading-dot");
      };

      rec.onend = () => {
        if (questionsIsRecording) {
          try {
            rec.start();
          } catch (err) {
            console.warn("Não foi possível retomar reconhecimento das perguntas:", err);
          }
        }
      };

      return rec;
    }

    function startQuestionsRecording() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        recommendationsStatus.textContent =
          "Seu navegador não suporta reconhecimento de voz. Use Google Chrome em um computador.";
        return;
      }

      if (!questionsRecognition) {
        questionsRecognition = initQuestionsSpeech();
        if (!questionsRecognition) return;
      }

      questionsIsRecording = true;
      questionsFinalTranscript = "";

      questionsTimerEl.classList.remove("hidden");
      resetQuestionsTimer();
      startQuestionsTimer();

      askQuestionsBtn.textContent = "Encerrar perguntas";
      closeRecommendationsBtn.disabled = true;
      closeRecommendationsBtn.style.opacity = "0.5";

      recommendationsStatus.textContent =
        "Gravando perguntas e respostas. Quando terminar, clique em \"Encerrar perguntas\".";
      recommendationsStatus.classList.remove("loading-dot");

      try {
        questionsRecognition.start();
      } catch (e) {
        console.warn("Erro ao iniciar reconhecimento das perguntas:", e);
      }
    }

    async function stopQuestionsRecordingAndUpdateSoap() {
      questionsIsRecording = false;

      if (questionsRecognition) {
        try {
          questionsRecognition.stop();
        } catch (e) {
          console.warn("Erro ao parar reconhecimento das perguntas:", e);
        }
      }

      pauseQuestionsTimer();

      const qa = (questionsFinalTranscript || "").trim();
      if (!qa) {
        recommendationsStatus.textContent = "Nenhuma fala foi capturada nesta rodada de perguntas.";
        askQuestionsBtn.textContent = "Complementar avaliação";
        closeRecommendationsBtn.disabled = false;
        closeRecommendationsBtn.style.opacity = "1";
        askQuestionsBtn.disabled = false;
        resetQuestionsTimer();
        questionsTimerEl.classList.add("hidden");
        return;
      }

      const soapAtual = getCombinedSoapFromFields();
      if (!soapAtual) {
        recommendationsStatus.textContent = "Não há SOAP disponível para atualizar.";
        askQuestionsBtn.textContent = "Complementar avaliação";
        closeRecommendationsBtn.disabled = false;
        closeRecommendationsBtn.style.opacity = "1";
        askQuestionsBtn.disabled = false;
        return;
      }

      askQuestionsBtn.disabled = true;
      recommendationsStatus.textContent = "Atualizando SOAP e módulos com as novas respostas...";
      recommendationsStatus.classList.add("loading-dot");

      const transcricaoBase = (baseTranscript || finalTranscript || "").trim();

      try {
        const resp = await fetch(BACKEND_URL + "/api/atualizar-soap-perguntas", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            soap_atual: soapAtual,
            perguntas_e_respostas: qa,
            transcricao_base: transcricaoBase
          })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (atualizar perguntas):", resp.status, txt);
          recommendationsStatus.textContent = "Não foi possível atualizar o SOAP com as novas respostas.";
          recommendationsStatus.classList.remove("loading-dot");
          askQuestionsBtn.disabled = false;
          return;
        }

        const data = await resp.json();
        const soap = data.soap || "";
        const prescricao = data.prescricao || "";

        if (soap) {
          updateSoapFromString(soap);
        }
        if (prescricao) {
          prescriptionOutput.value = prescricao;
          printBtn.style.display = "inline-block";
        }

        const appended =
          (transcricaoBase ? transcricaoBase + "\n\n" : "") +
          "RODADA ADICIONAL DE PERGUNTAS E RESPOSTAS:\n" +
          qa +
          "\n";
        baseTranscript = appended;
        finalTranscript = appended;

        recommendationsStatus.textContent = "SOAP atualizado com as novas respostas.";
        recommendationsStatus.classList.remove("loading-dot");

        await updateClassifications();
        await updateRiskTriage();
      } catch (err) {
        console.error("Erro geral ao atualizar SOAP com perguntas:", err);
        recommendationsStatus.textContent = "Erro ao atualizar o SOAP com as novas respostas.";
        recommendationsStatus.classList.remove("loading-dot");
      } finally {
        askQuestionsBtn.textContent = "Complementar avaliação";
        askQuestionsBtn.disabled = false;
        closeRecommendationsBtn.disabled = false;
        closeRecommendationsBtn.style.opacity = "1";
        resetQuestionsTimer();
        questionsTimerEl.classList.add("hidden");
        recommendationsPanel.classList.remove("visible");
      }
    }

    async function fetchRecommendations() {
      const combinedSoap = getCombinedSoapFromFields();
      if (!combinedSoap) {
        soapError.textContent =
          "Não há SOAP gerado ainda para sugerir perguntas complementares.";
        return;
      }

      // Reseta qualquer rodada anterior de perguntas
      if (questionsIsRecording && questionsRecognition) {
        try {
          questionsIsRecording = false;
          questionsRecognition.stop();
        } catch (e) {}
      }
      askQuestionsBtn.textContent = "Complementar avaliação";
      askQuestionsBtn.disabled = true;
      closeRecommendationsBtn.disabled = false;
      closeRecommendationsBtn.style.opacity = "1";
      resetQuestionsTimer();
      questionsTimerEl.classList.add("hidden");

      recommendationsPanel.classList.add("visible");
      recommendationsStatus.textContent =
        "Gerando perguntas complementares essenciais com base na queixa e no SOAP...";
      recommendationsStatus.classList.add("loading-dot");
      recommendationsList.innerHTML = "";


      try {
        const resp = await fetch(BACKEND_URL + "/api/recomendacoes-anamnese", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            soap: combinedSoap
          })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error(
            "Erro HTTP do backend (recomendações):",
            resp.status,
            txt
          );
          recommendationsStatus.textContent =
            "Não foi possível gerar as recomendações de perguntas.";
          recommendationsStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const perguntas = Array.isArray(data.perguntas) ? data.perguntas : [];

        if (!perguntas.length) {
          recommendationsStatus.textContent =
            "Nenhuma pergunta complementar foi sugerida para este caso.";
          recommendationsStatus.classList.remove("loading-dot");
          return;
        }

        recommendationsList.innerHTML = "";
        perguntas.forEach((q, index) => {
          const item = document.createElement("div");
          item.className = "recommendation-item";
          item.textContent = (index + 1) + ". " + q;
          recommendationsList.appendChild(item);
        });

        recommendationsStatus.textContent =
          "Use estas perguntas para aprofundar a anamnese com o paciente.";
        recommendationsStatus.classList.remove("loading-dot");
        askQuestionsBtn.disabled = false;
      } catch (err) {
        console.error("Erro geral ao buscar recomendações:", err);
        recommendationsStatus.textContent =
          "Erro ao gerar recomendações de perguntas.";
        recommendationsStatus.classList.remove("loading-dot");
      }
    }

    async function handleAskQuestionsFromPanel() {
      if (!questionsIsRecording) {
        startQuestionsRecording();
      } else {
        await stopQuestionsRecordingAndUpdateSoap();
      }
    }

    function startRecording() {
      if (!recognition) {
        initSpeech();
        if (!recognition) {
          return;
        }
      }

      isRecording = true;
      isPaused = false;
      finalTranscript = "";
      baseTranscript = "";
      resultsCard.classList.add("hidden");
      printBtn.style.display = "none";
      prescriptionOutput.value = "";
      soapS.value = "";
      soapO.value = "";
      soapA.value = "";
      soapP.value = "";
      resetNewModulesUI();

      pauseBtn.style.display = "inline-block";
      pauseBtn.innerText = "Pausar";
      recordBtn.className = "recording";
      recordBtn.innerText = "Encerrar consulta";
      micStatus.innerText = "Gravando consulta...";
      soapError.textContent = "";
      resultsCard.classList.add("hidden");

      resetLiveGuidanceState();
      renderLiveGuidance();
      startGuidanceLoop();

      resetTimer();
      startTimer();

      try {
        recognition.start();
      } catch (e) {
        console.warn("Erro ao iniciar reconhecimento:", e);
      }
    }

    function stopRecording() {
      isRecording = false;
      isPaused = false;

      stopGuidanceLoop();
      interimTranscript = "";
      renderLiveGuidance();

      if (recognition) {
        try {
          recognition.stop();
        } catch (e) {
          console.warn("Erro ao parar reconhecimento:", e);
        }
      }
      pauseTimer();
      recordBtn.className = "start";
      recordBtn.innerText = "Iniciar atendimento";
      pauseBtn.style.display = "none";
    }

    function pauseRecording() {
      if (!isRecording || isPaused) return;
      isPaused = true;

      stopGuidanceLoop();
      if (liveGuidanceStatus) liveGuidanceStatus.textContent = "Consulta pausada. As sugestões em tempo real serão retomadas ao retomar a gravação.";

      if (recognition) {
        try {
          recognition.stop();
        } catch (e) {
          console.warn("Erro ao pausar reconhecimento:", e);
        }
      }
      pauseTimer();
      pauseBtn.innerText = "Retomar";
      micStatus.innerText = "Consulta pausada.";
    }

    function resumeRecording() {
      if (!isRecording || !isPaused) return;
      isPaused = false;

      startGuidanceLoop();

      if (recognition) {
        try {
          recognition.start();
        } catch (e) {
          console.warn("Erro ao retomar reconhecimento:", e);
        }
      }
      startTimer();
      pauseBtn.innerText = "Pausar";
      micStatus.innerText = "Gravando consulta...";
    }

    
    function copyToClipboard(text) {
      if (!text) return;
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).catch(() => {
          alert("Não foi possível copiar o texto.");
        });
      } else {
        const temp = document.createElement("textarea");
        temp.value = text;
        document.body.appendChild(temp);
        temp.select();
        try {
          document.execCommand("copy");
        } catch (e) {
          alert("Não foi possível copiar o texto.");
        }
        document.body.removeChild(temp);
      }
    }

    function showImageChoice(cameraInputEl, fileInputEl) {
      pendingCameraInput = cameraInputEl || null;
      pendingFileInput = fileInputEl || null;
      if (!imageChoiceOverlay) return;
      imageChoiceOverlay.classList.remove("hidden");
    }

    function hideImageChoice() {
      if (!imageChoiceOverlay) return;
      imageChoiceOverlay.classList.add("hidden");
      pendingCameraInput = null;
      pendingFileInput = null;
    }

    async function fileToDataUrl(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(String(reader.result || ""));
        reader.onerror = () => reject(new Error("Falha ao ler a imagem."));
        reader.readAsDataURL(file);
      });
    }

    async function analyzeWoundWithImage(dataUrl) {
      if (!presentationsMaxDoseStatus || !presentationsMaxDoseBox) return;
      presentationsMaxDoseStatus.textContent = "Analisando imagem da lesão.";
      presentationsMaxDoseBox.textContent = "Processando.";
      try {
        const resp = await fetch(BACKEND_URL + "/api/analisar-lesao-imagem", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ image_data_url: dataUrl })
        });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) throw new Error(data?.error || "Falha ao analisar imagem.");
        const texto = (data?.texto || "").trim();
        presentationsMaxDoseBox.textContent = texto || "Nenhum conteúdo disponível.";
        presentationsMaxDoseStatus.textContent = "Análise concluída.";
      } catch (e) {
        presentationsMaxDoseStatus.textContent = "Falha ao analisar imagem.";
        presentationsMaxDoseBox.textContent = "Nenhum conteúdo disponível.";
      }
    }

    async function analyzePrescriptionWithImage(dataUrl) {
      if (!interactionsStatus || !interactionsBox) return;
      interactionsStatus.textContent = "Analisando prescrição.";
      interactionsBox.textContent = "Processando.";
      try {
        const resp = await fetch(BACKEND_URL + "/api/analisar-prescricao-imagem", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ image_data_url: dataUrl })
        });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) throw new Error(data?.error || "Falha ao analisar prescrição.");
        const texto = (data?.texto || "").trim();
        interactionsBox.textContent = texto || "Nenhum conteúdo disponível.";
        interactionsStatus.textContent = "Análise concluída.";
      } catch (e) {
        interactionsStatus.textContent = "Falha ao analisar prescrição.";
        interactionsBox.textContent = "Nenhum conteúdo disponível.";
      }
    }

    function getSoapSectionText(letter) {
      switch (letter) {
        case "S":
          return soapS.value.trim();
        case "O":
          return soapO.value.trim();
        case "A":
          return soapA.value.trim();
        case "P":
          return soapP.value.trim();
        default:
          return "";
      }
    }

    function openPrintWindow(title, text) {
      const content = (text || "").trim();
      if (!content) {
        alert("Não há conteúdo para imprimir.");
        return;
      }

      const w = window.open("", "_blank", "width=800,height=600");
      if (!w) {
        alert("Não foi possível abrir a janela de impressão.");
        return;
      }

      w.document.write("<html><head><title>" + escapeHtml(title) + "</title></head><body>");
      w.document.write("<pre style='font-family: Arial, sans-serif; white-space: pre-wrap;'>" +
        escapeHtml(content) +
        "</pre>");
      w.document.write("</body></html>");
      w.document.close();
      w.focus();
      w.print();
    }

    
    function extractMedicationsFromPrescriptionText(text) {
      const raw = String(text || "").replace(/\r/g, "").trim();
      if (!raw) return [];

      const lines = raw.split("\n").map(l => l.trim()).filter(Boolean);

      const meds = [];

      // Heurística principal:
      // - Prescrição ambulatorial: medicamentos aparecem em lista numerada e a seção "Orientações:" deve ser ignorada.
      // - Prescrição hospitalar: medicamentos aparecem em bullets dentro das seções
      //   "Medicamentos contínuos:" e/ou "Medicamentos se necessário:".

      const isHospital =
        lines.some(l => /^medicamentos\s+cont[ií]nuos\s*:/i.test(l)) ||
        lines.some(l => /^medicamentos\s+se\s+necess[aá]rio\s*:/i.test(l)) ||
        lines.some(l => /^medicamentos\s+se\s+necessario\s*:/i.test(l));

      if (!isHospital) {
        for (const line of lines) {
          const low = line.toLowerCase();

          // Para de coletar ao entrar em orientações/assinatura
          if (low.startsWith("orientações:") || low.startsWith("orientacoes:")) break;
          if (low.startsWith("assinatura:")) break;
          if (low.startsWith("médico") || low.startsWith("medico")) break;

          const m = line.match(/^\s*\d+\s*[\.\)]\s*([^—–-]+?)\s*(?:[—–-].*)?$/);
          if (m && m[1]) {
            const name = m[1].trim();
            if (name && name.length >= 2) meds.push(name);
          }
        }
      } else {
        let section = null; // "cont", "prn", "other"

        for (const line of lines) {
          const low = line.toLowerCase();

          if (/^medicamentos\s+cont[ií]nuos\s*:/i.test(line) || /^medicamentos\s+continuos\s*:/i.test(line)) {
            section = "cont";
            continue;
          }
          if (/^medicamentos\s+se\s+necess[aá]rio\s*:/i.test(line) || /^medicamentos\s+se\s+necessario\s*:/i.test(line)) {
            section = "prn";
            continue;
          }

          // Qualquer outro cabeçalho em formato "X:" encerra a seção de medicamentos
          if (/^[a-zA-ZÀ-ÿ].*:\s*$/.test(line) && !/^medicamentos\s+/i.test(line)) {
            section = "other";
            continue;
          }

          // Captura bullets apenas nas seções corretas
          const isBullet = /^\s*[-•]\s+/.test(line);
          if (!isBullet) continue;
          if (section !== "cont" && section !== "prn") continue;

          const m = line.match(/^\s*[-•]\s*([^—–-]+?)\s*(?:[—–-].*)?$/);
          if (!m || !m[1]) continue;

          const name = m[1].trim();
          if (!name || name.length < 2) continue;
          if (/^(n[aã]o informado)$/i.test(name)) continue;

          meds.push(name);
        }
      }

      // Deduplicação preservando ordem
      const seen = new Set();
      const unique = [];
      for (const x of meds) {
        const key = x.toLowerCase();
        if (seen.has(key)) continue;
        seen.add(key);
        unique.push(x);
      }

      return unique.slice(0, 60);
    }

    function getAllPrescribedMedications() {
      const amb = prescriptionOutput.value || "";
      const hosp = hospitalPrescriptionOutput.value || "";
      const meds = [
        ...extractMedicationsFromPrescriptionText(amb),
        ...extractMedicationsFromPrescriptionText(hosp)
      ];

      const seen = new Set();
      const unique = [];
      for (const x of meds) {
        const key = x.toLowerCase();
        if (seen.has(key)) continue;
        seen.add(key);
        unique.push(x);
      }
      return unique.slice(0, 60);
    }

    async function generateHospitalPrescription() {
      hospitalPrescriptionStatus.textContent = "";
      const transcricao = (baseTranscript || finalTranscript || "").trim();

      if (!transcricao) {
        hospitalPrescriptionStatus.textContent = "Não há transcrição disponível para gerar o SBAR.";
        return;
      }

      hospitalPrescriptionStatus.textContent = "Gerando SBAR...";
      hospitalPrescriptionStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/prescricao-hospitalar", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (SBAR):", resp.status, txt);
          hospitalPrescriptionStatus.textContent = "Não foi possível gerar a SBAR.";
          hospitalPrescriptionStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const presc = data.prescricao_hospitalar || "";

        hospitalPrescriptionOutput.value = presc;
        hospitalPrescriptionStatus.textContent = presc ? "Prescrição hospitalar gerada." : "Não foi possível gerar a SBAR.";
        hospitalPrescriptionStatus.classList.remove("loading-dot");

        await updateClassifications();
        await updateRiskTriage();
      } catch (err) {
        console.error("Erro ao gerar SBAR:", err);
        hospitalPrescriptionStatus.textContent = "Erro ao gerar SBAR.";
        hospitalPrescriptionStatus.classList.remove("loading-dot");
      }
    }

    function formatClassificationList(items) {
      if (!Array.isArray(items) || !items.length) {
        return "Nenhum conteúdo disponível.";
      }
      const lines = [];
      for (const it of items) {
        const med = (it && it.medicamento) ? String(it.medicamento) : "não informado";
        const cat = (it && it.categoria) ? String(it.categoria) : "NA";
        const desc = (it && it.descricao) ? String(it.descricao) : "categoria não informada (dados insuficientes)";
        if (cat === "NA") {
          lines.push(med + ": categoria não informada (dados insuficientes)");
        } else {
          lines.push(med + ": " + cat + " (" + desc + ")");
        }
      }
      return lines.join("\n");
    }

    async function updateClassifications() {
      classificationsStatus.textContent = "";

      const contexto = getNursingContext();
      if (!contexto) {
        pregnancyBox.textContent = "Nenhum conteúdo disponível.";
        lactationBox.textContent = "Nenhum conteúdo disponível.";
        return;
      }

      classificationsStatus.textContent = "Gerando SAE e orientações...";
      classificationsStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/classificar-gestacao-lactacao", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ contexto })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP:", resp.status, txt);
          pregnancyBox.textContent = "Falha ao gerar SAE.";
          lactationBox.textContent = "Falha ao gerar orientações.";
          return;
        }

        const data = await resp.json().catch(() => ({}));
        pregnancyBox.textContent = (data.sae || "").trim() || "Nenhum conteúdo disponível.";
        lactationBox.textContent = (data.orientacoes || "").trim() || "Nenhum conteúdo disponível.";
      } catch (e) {
        console.error(e);
        pregnancyBox.textContent = "Falha ao gerar SAE (rede/backend).";
        lactationBox.textContent = "Falha ao gerar orientações (rede/backend).";
      } finally {
        classificationsStatus.classList.remove("loading-dot");
        classificationsStatus.textContent = "";
      }
    }

    let reportTimerInterval = null;
    let reportTimerSeconds = 0;

    function formatSecondsMMSS(totalSeconds) {
      const secs = Math.max(0, Number(totalSeconds) || 0);
      const m = ("0" + Math.floor(secs / 60)).slice(-2);
      const s = ("0" + (secs % 60)).slice(-2);
      return `${m}:${s}`;
    }

    function updateReportStatusTimer() {
      if (!reportIsRecording) return;
      const mmss = formatSecondsMMSS(reportTimerSeconds);
      reportStatus.textContent = `Gravando relatório... ${mmss}`;
    }

    function startReportStatusTimer() {
      reportTimerSeconds = 0;
      if (reportTimerInterval) clearInterval(reportTimerInterval);
      updateReportStatusTimer();
      reportTimerInterval = setInterval(() => {
        reportTimerSeconds += 1;
        updateReportStatusTimer();
      }, 1000);
    }

    function stopReportStatusTimer() {
      if (reportTimerInterval) clearInterval(reportTimerInterval);
      reportTimerInterval = null;
    }


    function initReportSpeech() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        reportStatus.textContent =
          "Seu navegador não suporta reconhecimento de voz. Use Google Chrome em um computador.";
        return null;
      }

      const rec = new SR();
      rec.lang = "pt-BR";
      rec.continuous = true;
      rec.interimResults = true;

      rec.onresult = (event) => {
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            reportFinalTranscript += transcript + " ";
          }
        }
      };

      rec.onerror = (event) => {
        console.error("Erro no reconhecimento do relatório:", event.error);
        reportStatus.textContent =
          "Ocorreu um erro no reconhecimento de voz do relatório. Tente novamente.";
      };

      rec.onend = () => {
        if (reportIsRecording && !reportIsPaused) {
          try {
            rec.start();
          } catch (err) {
            console.warn("Não foi possível retomar reconhecimento do relatório:", err);
          }
        }
      };

      return rec;
    }

    async function startReportRecording() {
      reportStatus.textContent = "";
      reportOutput.value = "";
      reportFinalTranscript = "";

      if (!reportRecognition) {
        reportRecognition = initReportSpeech();
        if (!reportRecognition) return;
      }

      reportIsRecording = true;
      reportIsPaused = false;

      reportRecordBtn.className = "small-record-btn recording";
      reportRecordBtn.innerText = "Encerrar gravação";
      reportStatus.textContent = "Gravando relatório...";
      reportStatus.classList.remove("loading-dot");
      reportStatus.classList.add("loading-dot");

      startReportStatusTimer();

      try {
        reportRecognition.start();
      } catch (e) {
        console.warn("Erro ao iniciar reconhecimento do relatório:", e);
      }
    }

    async function stopReportRecordingAndGenerate() {
      reportIsRecording = false;
      reportIsPaused = false;

      if (reportRecognition) {
        try {
          reportRecognition.stop();
        } catch (e) {
          console.warn("Erro ao parar reconhecimento do relatório:", e);
        }
      }

      stopReportStatusTimer();

      reportRecordBtn.className = "small-record-btn start";
      reportRecordBtn.innerText = "Gravar relatório";

      const transcricao = reportFinalTranscript.trim();
      if (!transcricao) {
        reportStatus.classList.remove("loading-dot");
        reportStatus.textContent = "Nenhuma fala foi capturada no relatório.";
        return;
      }

      reportStatus.textContent = "Gerando relatório clínico...";
      reportStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/gerar-relatorio", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (relatório):", resp.status, txt);
          reportStatus.textContent = "Não foi possível gerar o relatório.";
          reportStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const relatorio = data.relatorio || "";
        reportOutput.value = relatorio;

        reportStatus.textContent = relatorio ? "Relatório gerado." : "Não foi possível gerar o relatório.";
        reportStatus.classList.remove("loading-dot");
      } catch (err) {
        console.error("Erro ao gerar relatório:", err);
        reportStatus.textContent = "Erro ao gerar relatório.";
        reportStatus.classList.remove("loading-dot");
      }
    }

    async function submitMedicalDoubt() {
      const q = (medicalDoubtInput.value || "").trim();
      if (!q) return;

      medicalDoubtStatus.textContent = "Respondendo dúvida...";
      medicalDoubtStatus.classList.add("loading-dot");
      medicalDoubtAnswer.textContent = "";

      try {
        const resp = await fetch(BACKEND_URL + "/api/duvidas-enfermagem", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ duvida: q })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (dúvidas):", resp.status, txt);
          medicalDoubtStatus.textContent = "Não foi possível responder a dúvida.";
          medicalDoubtStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const resposta = data.resposta || "";
        medicalDoubtAnswer.textContent = resposta || "Sem resposta disponível.";
        medicalDoubtStatus.textContent = "Resposta gerada.";
        medicalDoubtStatus.classList.remove("loading-dot");
      } catch (err) {
        console.error("Erro ao responder dúvida:", err);
        medicalDoubtStatus.textContent = "Erro ao responder a dúvida.";
        medicalDoubtStatus.classList.remove("loading-dot");
      }
    }

    recordBtn.onclick = () => {
      if (!isRecording) {
        startRecording();
      } else {
        stopRecording();
        finalizarConsulta();
      }
    };

    pauseBtn.onclick = () => {
      if (!isRecording) return;
      if (!isPaused) {
        pauseRecording();
      } else {
        resumeRecording();
      }
    };

    printBtn.onclick = () => {
      openPrintWindow("Plano de Cuidados (Prescrição de Enfermagem)", prescriptionOutput.value);
    };

    recommendationsBtn.addEventListener("click", () => {
      fetchRecommendations();
    });

    closeRecommendationsBtn.addEventListener("click", () => {
      if (questionsIsRecording) {
        recommendationsStatus.textContent =
          "Finalize a gravação das perguntas clicando em \"Encerrar perguntas\" antes de fechar.";
        return;
      }
      recommendationsPanel.classList.remove("visible");
    });

    askQuestionsBtn.addEventListener("click", () => {
      handleAskQuestionsFromPanel();
    });

    soapCopyButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const part = btn.getAttribute("data-part");
        const sectionText = getSoapSectionText(part);
        if (!sectionText) {
          alert("Seção " + part + " está vazia.");
          return;
        }
        copyToClipboard(part + ": " + sectionText);
      });

    if (copyFullSoapBtn) {
      copyFullSoapBtn.addEventListener("click", () => {
        const full = getCombinedSoapFromFields();
        if (!full.trim()) {
          alert("Não há SOAP disponível para copiar.");
          return;
        }
        copyToClipboard(full);
      });
    }

    if (printSoapBtn) {
      printSoapBtn.addEventListener("click", () => {
        const full = getCombinedSoapFromFields();
        openPrintWindow("SOAP", full);
      });
    }

    copyPrescriptionBtn.addEventListener("click", () => {
      const text = prescriptionOutput.value.trim();
      if (!text) {
        alert("Não há prescrição para copiar.");
        return;
      }
      copyToClipboard(text);
    });

    generateHospitalPrescriptionBtn.addEventListener("click", () => {
      generateHospitalPrescription();
    });

    copyHospitalPrescriptionBtn.addEventListener("click", () => {
      const text = hospitalPrescriptionOutput.value.trim();
      if (!text) {
        alert("Não há SBAR para copiar.");
        return;
      }
      copyToClipboard(text);
    });

    printHospitalPrescriptionBtn.addEventListener("click", () => {
      openPrintWindow("Passagem de Plantão (SBAR)", hospitalPrescriptionOutput.value);
    });

    if (printRiskTriageBtn) {
      printRiskTriageBtn.addEventListener("click", () => {
        const text = (riskTriageMeaning && riskTriageMeaning.dataset && riskTriageMeaning.dataset.printText) ? riskTriageMeaning.dataset.printText : "";
        openPrintWindow("Classificação de risco por cores", text);
      });
    }

    
    if (copySaeBtn) {
      copySaeBtn.addEventListener("click", () => {
        const text = (pregnancyBox && pregnancyBox.textContent) ? pregnancyBox.textContent.trim() : "";
        if (!text) {
          alert("Não há SAE para copiar.");
          return;
        }
        copyToClipboard(text);
      });
    }

    if (copyOrientationsBtn) {
      copyOrientationsBtn.addEventListener("click", () => {
        const text = (lactationBox && lactationBox.textContent) ? lactationBox.textContent.trim() : "";
        if (!text) {
          alert("Não há orientações para copiar.");
          return;
        }
        copyToClipboard(text);
      });
    }

    if (copyRiskTriageBtn) {
      copyRiskTriageBtn.addEventListener("click", () => {
        const text = (riskTriageMeaning && riskTriageMeaning.dataset && riskTriageMeaning.dataset.printText) ? riskTriageMeaning.dataset.printText : "";
        if (!text.trim()) {
          alert("Não há classificação de risco para copiar.");
          return;
        }
        copyToClipboard(text);
      });
    }
    });

    printPregnancyBtn.addEventListener("click", () => {
      openPrintWindow("SAE (Processo de Enfermagem)", pregnancyBox.textContent);
    });

    printLactationBtn.addEventListener("click", () => {
      openPrintWindow("Orientações ao paciente", lactationBox.textContent);
    });


    if (chooseCameraBtn) {
      chooseCameraBtn.addEventListener("click", () => {
        const input = pendingCameraInput;
        hideImageChoice();
        if (input) input.click();
      });
    }

    if (chooseFileBtn) {
      chooseFileBtn.addEventListener("click", () => {
        const input = pendingFileInput;
        hideImageChoice();
        if (input) input.click();
      });
    }

    if (cancelImageChoiceBtn) {
      cancelImageChoiceBtn.addEventListener("click", () => {
        hideImageChoice();
      });
    }

    if (imageChoiceOverlay) {
      imageChoiceOverlay.addEventListener("click", (e) => {
        if (e.target === imageChoiceOverlay) hideImageChoice();
      });
    }

    if (woundPhotoBtn) {
      woundPhotoBtn.addEventListener("click", () => {
        showImageChoice(woundCameraInput, woundFileInput);
      });
    }

    if (medPhotoBtn) {
      medPhotoBtn.addEventListener("click", () => {
        showImageChoice(medCameraInput, medFileInput);
      });
    }

    if (woundCameraInput) {
      woundCameraInput.addEventListener("change", async (e) => {
        const file = e.target.files && e.target.files[0];
        woundCameraInput.value = "";
        if (!file) return;
        const dataUrl = await fileToDataUrl(file);
        await analyzeWoundWithImage(dataUrl);
      });
    }

    if (woundFileInput) {
      woundFileInput.addEventListener("change", async (e) => {
        const file = e.target.files && e.target.files[0];
        woundFileInput.value = "";
        if (!file) return;
        const dataUrl = await fileToDataUrl(file);
        await analyzeWoundWithImage(dataUrl);
      });
    }

    if (medCameraInput) {
      medCameraInput.addEventListener("change", async (e) => {
        const file = e.target.files && e.target.files[0];
        medCameraInput.value = "";
        if (!file) return;
        const dataUrl = await fileToDataUrl(file);
        await analyzePrescriptionWithImage(dataUrl);
      });
    }

    if (medFileInput) {
      medFileInput.addEventListener("change", async (e) => {
        const file = e.target.files && e.target.files[0];
        medFileInput.value = "";
        if (!file) return;
        const dataUrl = await fileToDataUrl(file);
        await analyzePrescriptionWithImage(dataUrl);
      });
    }

    if (copyWoundBtn) {
      copyWoundBtn.addEventListener("click", () => {
        const text = (presentationsMaxDoseBox && presentationsMaxDoseBox.textContent) ? presentationsMaxDoseBox.textContent.trim() : "";
        if (!text) {
          alert("Não há prescrição e cuidados para copiar.");
          return;
        }
        copyToClipboard(text);
      });
    }

    if (printWoundBtn) {
      printWoundBtn.addEventListener("click", () => {
        openPrintWindow("Curativos e feridas", presentationsMaxDoseBox ? presentationsMaxDoseBox.textContent : "");
      });
    }

    if (copyMedSafetyBtn) {
      copyMedSafetyBtn.addEventListener("click", () => {
        const text = (interactionsBox && interactionsBox.textContent) ? interactionsBox.textContent.trim() : "";
        if (!text) {
          alert("Não há conteúdo para copiar.");
          return;
        }
        copyToClipboard(text);
      });
    }

    if (printMedSafetyBtn) {
      printMedSafetyBtn.addEventListener("click", () => {
        openPrintWindow("Administração segura de medicamentos (registro de enfermagem)", interactionsBox ? interactionsBox.textContent : "");
      });
    }



    const consultTypeButtons = Array.from(document.querySelectorAll(".consult-type-btn"));
    const consultGuideDrawer = document.getElementById("consultGuideDrawer");
    const consultGuideTitle = document.getElementById("consultGuideTitle");
    const consultGuideSubtitle = document.getElementById("consultGuideSubtitle");
    const consultGuideContent = document.getElementById("consultGuideContent");
    const closeConsultGuideBtn = document.getElementById("closeConsultGuideBtn");
    const prenatalTrimesterRow = document.getElementById("prenatalTrimesterRow");
    const trimesterButtons = Array.from(document.querySelectorAll(".trimester-btn"));

    let selectedConsultType = null;
    let selectedPrenatalTrimester = "1";

    const guideData = {
      puericultura: {
        title: "Consulta de puericultura",
        subtitle: "Sequência sugerida para orientar perguntas e procedimentos iniciais.",
        sections: [
          {
            title: "Perguntas essenciais",
            items: [
              "Identificação e contexto: idade, cuidador presente, motivo da consulta, dúvidas principais da família.",
              "História desde a última consulta: intercorrências, internações, uso de medicamentos, alergias, exposição a doentes.",
              "Alimentação: aleitamento materno (exclusivo ou não), fórmula, frequência, aceitação, introdução alimentar (se aplicável), consumo de água, ingestão de ultraprocessados.",
              "Eliminações: diurese, evacuações (frequência, consistência, sangue, dor), sinais de desidratação.",
              "Sono e rotina: padrão de sono, despertares, ambiente, segurança do sono, telas.",
              "Desenvolvimento: marcos motores e linguagem conforme idade, interação social, audição/visão percebidas, comportamento.",
              "Segurança e ambiente: quedas, engasgo, afogamento, acidentes domésticos, cadeira no carro, fumaça, violência, condições de moradia.",
              "Vacinas: conferir caderneta, doses atrasadas, reações prévias.",
              "Saúde bucal: higiene, erupção dentária, uso de flúor (conforme orientação local)."
            ]
          },
          {
            title: "Procedimentos e exame físico",
            items: [
              "Sinais vitais quando indicado: temperatura, frequência cardíaca e respiratória, saturação se sintomas respiratórios.",
              "Antropometria: peso, estatura/comprimento, perímetro cefálico (especialmente em menores), cálculo e registro na curva (OMS).",
              "Exame físico direcionado: pele e mucosas, hidratação, orofaringe, otoscopia se queixa, ausculta cardíaca e pulmonar, abdome, genitais quando indicado.",
              "Triagem de sinais de gravidade: prostração, desconforto respiratório, sinais de desidratação, febre persistente, convulsão, cianose, recusa de líquidos.",
              "Orientações finais: alimentação por faixa etária, sinais de alarme, retorno programado e vacinação."
            ]
          }
        ]
      },

      planejamento: {
        title: "Consulta de planejamento familiar",
        subtitle: "Sequência sugerida para escolha do método com segurança.",
        sections: [
          {
            title: "Perguntas essenciais",
            items: [
              "Objetivo do paciente: evitar gestação, espaçar, planejar para quando, ou tratar sintomas (sangramento, cólica).",
              "História reprodutiva: gestações, partos, abortos, complicações, lactação atual, desejo reprodutivo do casal.",
              "Data da última menstruação, regularidade do ciclo, sangramentos anormais, suspeita de gestação atual.",
              "Doenças e riscos: hipertensão, diabetes, enxaqueca com aura, trombose, doença hepática, câncer de mama, tabagismo, pós-parto recente.",
              "Medicamentos em uso e possíveis interações (ex.: indutores enzimáticos).",
              "História ginecológica: IST prévias, corrimentos, dor pélvica, última citologia conforme protocolo local.",
              "Risco de IST e necessidade de dupla proteção (preservativo).",
              "Preferências: método diário ou de longa duração, desejo de método sem hormônio, tolerância a sangramento irregular."
            ]
          },
          {
            title: "Procedimentos e orientações",
            items: [
              "Sinais vitais e avaliação clínica básica: pressão arterial e peso/IMC (essencial antes de métodos combinados).",
              "Teste de gravidez quando houver dúvida ou critério clínico.",
              "Aconselhamento estruturado: eficácia, modo de uso, efeitos adversos, contraindicações e sinais de alarme do método escolhido.",
              "Reforçar preservativo para IST e como usar corretamente.",
              "Planejar retorno: adaptação do método, manejo de efeitos e revisão de segurança."
            ]
          }
        ]
      },

      hiperdia: {
        title: "Consulta de Hiperdia (HAS e/ou DM)",
        subtitle: "Sequência sugerida para acompanhamento e segurança do cuidado.",
        sections: [
          {
            title: "Perguntas essenciais",
            items: [
              "Motivo da consulta: rotina, sintomas, aferições alteradas, falta de medicação, intercorrências recentes.",
              "Adesão ao tratamento: horários, esquecimento, efeitos adversos, dificuldades de acesso aos medicamentos.",
              "Pressão e glicemias: valores recentes, sintomas de hipo/hiperglicemia, desmaios, palpitações, cefaleia, visão turva.",
              "Estilo de vida: alimentação, sal, açúcar, atividade física, álcool, tabagismo, sono e estresse.",
              "Complicações e rastreios: dor torácica, dispneia, edema, claudicação, feridas nos pés, perda de sensibilidade, alterações visuais, sintomas urinários.",
              "Comorbidades: doença renal, AVC prévio, infarto, dislipidemia; vacinas e cuidados preventivos."
            ]
          },
          {
            title: "Procedimentos e exame físico",
            items: [
              "Aferir sinais vitais: pressão arterial, frequência cardíaca, peso, circunferência abdominal quando aplicável.",
              "Glicemia capilar quando indicado; registrar jejum/pós-prandial conforme contexto.",
              "Avaliação de pés (DM): inspeção, pulsos, sensibilidade (monofilamento se disponível), orientações de autocuidado.",
              "Sinais de gravidade: PA muito elevada com sintomas, hipoglicemia, hiperglicemia importante com sinais de desidratação, dor torácica, dispneia.",
              "Reforçar plano: metas, adesão, autocuidado, retorno e quando procurar urgência."
            ]
          }
        ]
      },

      prenatal: {
        title: "Consulta pré-natal",
        subtitle: "Escolha o trimestre para ver perguntas e procedimentos em ordem.",
        trimesters: {
          "1": {
            subtitle: "1º trimestre (até 13 semanas e 6 dias)",
            sections: [
              {
                title: "Perguntas essenciais",
                items: [
                  "Identificação e dados essenciais: nome completo, idade, peso, sinais vitais iniciais e queixa/objetivo da consulta.",
                  "Data da última menstruação, regularidade menstrual, cálculo de idade gestacional e data provável do parto conforme rotina do serviço.",
                  "História obstétrica: gestações anteriores, partos, abortos, complicações (pré-eclâmpsia, hemorragia, prematuridade).",
                  "Sintomas atuais: náuseas/vômitos, dor abdominal, sangramento vaginal, corrimento, febre, disúria.",
                  "Comorbidades: hipertensão, diabetes, epilepsia, doença renal, tireoide, trombofilias; uso de medicamentos e suplementos.",
                  "Alergias, uso de álcool/tabaco/outras substâncias, situação social e apoio.",
                  "Vacinação e exames anteriores, histórico de IST e testagens."
                ]
              },
              {
                title: "Procedimentos e exame físico",
                items: [
                  "Aferir sinais vitais e peso; calcular IMC e registrar.",
                  "Avaliar edema, sinais de anemia/desidratação e exame clínico direcionado.",
                  "Solicitar/confirmar exames iniciais conforme rotina local: hemograma, tipagem ABO/Rh e Coombs indireto quando indicado, glicemia, sorologias (sífilis, HIV, hepatites), exame de urina e urocultura, outros conforme protocolo.",
                  "Orientações: sinais de alarme (sangramento, dor forte, febre, perda de líquidos), suplementação prescrita e hábitos saudáveis.",
                  "Se idade gestacional permitir e houver recurso, auscultar batimentos cardíacos fetais conforme prática do serviço."
                ]
              }
            ]
          },
          "2": {
            subtitle: "2º trimestre (14 a 27 semanas e 6 dias)",
            sections: [
              {
                title: "Perguntas essenciais",
                items: [
                  "Evolução desde a última consulta: intercorrências, urgências, uso e adesão a medicamentos/suplementos.",
                  "Movimentação fetal (quando aplicável): início, frequência percebida, redução de movimentos.",
                  "Sintomas de alerta: cefaleia intensa, escotomas, dor epigástrica, edema importante, sangramento, perda de líquido, febre, disúria.",
                  "Revisar exames e vacinação; reforçar orientações e plano de retorno."
                ]
              },
              {
                title: "Procedimentos e exame físico",
                items: [
                  "Aferir sinais vitais e peso; avaliar edema.",
                  "Medir altura uterina e comparar com idade gestacional; avaliar apresentação quando possível.",
                  "Auscultar batimentos cardíacos fetais conforme rotina do serviço.",
                  "Revisar/solicitar exames do período conforme rotina local (inclui rastreios de anemia e diabetes gestacional quando indicado).",
                  "Orientar sinais de trabalho de parto prematuro e quando procurar urgência."
                ]
              }
            ]
          },
          "3": {
            subtitle: "3º trimestre (28 semanas até o parto)",
            sections: [
              {
                title: "Perguntas essenciais",
                items: [
                  "Movimentos fetais e percepção materna; redução de movimentos é sinal de alerta.",
                  "Sintomas de pré-eclâmpsia e urgência: cefaleia intensa, visão turva, dor epigástrica, edema súbito, falta de ar.",
                  "Sinais de trabalho de parto: contrações ritmadas, perda de tampão mucoso, sangramento, perda de líquido.",
                  "Plano de parto e rede de referência: onde buscar assistência, transporte, acompanhante, documentação.",
                  "Revisar exames do final da gestação conforme rotina local e vacinação."
                ]
              },
              {
                title: "Procedimentos e exame físico",
                items: [
                  "Aferir sinais vitais e peso; atenção reforçada à pressão arterial e edema.",
                  "Medir altura uterina, avaliar apresentação fetal e auscultar batimentos cardíacos fetais.",
                  "Reforçar orientações: sinais de alarme, preparo para o parto, amamentação e cuidados no pós-parto imediato.",
                  "Planejar retorno mais frequente conforme idade gestacional e risco."
                ]
              }
            ]
          }
        }
      }
    };

    function renderGuideSections(sections) {
      if (!consultGuideContent) return;
      const parts = [];
      for (const section of sections || []) {
        parts.push(`<div class="guide-section-title">${escapeHtml(section.title)}</div>`);
        parts.push("<ol>");
        for (const item of section.items || []) {
          parts.push(`<li>${escapeHtml(item)}</li>`);
        }
        parts.push("</ol>");
      }
      consultGuideContent.innerHTML = parts.join("");
    }

    function openGuideFor(type) {
      selectedConsultType = type;
      consultTypeButtons.forEach(btn => {
        btn.classList.toggle("active", btn.dataset.consult === type);
      });

      if (!consultGuideDrawer || !consultGuideTitle || !consultGuideSubtitle) return;

      consultGuideDrawer.classList.remove("hidden");
      const data = guideData[type];

      if (!data) {
        consultGuideTitle.textContent = "Guia não disponível";
        consultGuideSubtitle.textContent = "";
        consultGuideContent.innerHTML = "";
        prenatalTrimesterRow?.classList.add("hidden");
        return;
      }

      consultGuideTitle.textContent = data.title || "";
      consultGuideSubtitle.textContent = data.subtitle || "";

      if (type === "prenatal") {
        prenatalTrimesterRow?.classList.remove("hidden");
        setPrenatalTrimester(selectedPrenatalTrimester);
      } else {
        prenatalTrimesterRow?.classList.add("hidden");
        renderGuideSections(data.sections || []);
      }
    }

    function setPrenatalTrimester(tri) {
      selectedPrenatalTrimester = String(tri || "1");
      trimesterButtons.forEach(b => {
        b.classList.toggle("active", b.dataset.tri === selectedPrenatalTrimester);
      });

      const data = guideData.prenatal;
      const t = data?.trimesters?.[selectedPrenatalTrimester];
      if (!t) {
        consultGuideSubtitle.textContent = guideData.prenatal.subtitle || "";
        consultGuideContent.innerHTML = "";
        return;
      }

      consultGuideSubtitle.textContent = t.subtitle || guideData.prenatal.subtitle || "";
      renderGuideSections(t.sections || []);
    }

    function closeGuide() {
      consultGuideDrawer?.classList.add("hidden");
      consultTypeButtons.forEach(btn => btn.classList.remove("active"));
      selectedConsultType = null;
    }

    if (consultTypeButtons.length) {
      consultTypeButtons.forEach(btn => {
        btn.addEventListener("click", () => openGuideFor(btn.dataset.consult || ""));
      });
    }

    if (trimesterButtons.length) {
      trimesterButtons.forEach(btn => {
        btn.addEventListener("click", () => setPrenatalTrimester(btn.dataset.tri || "1"));
      });
    }

    if (closeConsultGuideBtn) {
      closeConsultGuideBtn.addEventListener("click", closeGuide);
    }


    medicalDoubtInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        submitMedicalDoubt();
      }
    });

    reportRecordBtn.addEventListener("click", () => {
      if (!reportIsRecording) {
        startReportRecording();
      } else {
        stopReportRecordingAndGenerate();
      }
    });
  </script>

  <div class="whatsapp-fab-label">Entrar em contato</div>
  <a
    class="whatsapp-fab"
    href="https://wa.me/5575981457012?text=Ol%C3%A1%21%20Gostaria%20de%20reportar%20um%20erro%2C%20tirar%20uma%20d%C3%BAvida%20ou%20enviar%20uma%20sugest%C3%A3o."
    target="_blank"
    rel="noopener"
    aria-label="Entrar em contato pelo WhatsApp"
    title="Reportar erros, dúvidas e sugestões"
  >
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M19.5 14.5c-.7 0-1.4-.1-2.1-.3a1 1 0 0 0-1 .2l-1.3 1.3a13.1 13.1 0 0 1-5.8-5.8l1.3-1.3a1 1 0 0 0 .2-1c-.2-.7-.3-1.4-.3-2.1a1 1 0 0 0-1-1H6.5a1 1 0 0 0-1 1c0 6.1 4.9 11 11 11a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1z"></path>
    </svg>
  </a>

</body>
</html>

<!-- index.html -->
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Atendimento de Enfermagem</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
    }
    :root {
      --brand-green: #28a745;
      --round-btn-size: 180px;
      --wa-safe-space: 140px;
    }
    body {
      font-family: Arial, Helvetica, sans-serif;
      margin: 0;
      padding: 0;
      background: #f5f5f5;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    .page {
      width: 100%;
      max-width: 800px;
      padding: 20px 20px var(--wa-safe-space) 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin: 20px 0 10px 0;
      text-align: center;
    }
    .center-card {
      background: #ffffff;
      border-radius: 16px;
      padding: 30px 20px 25px 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 420px;
      margin-top: 10px;
    }

    .live-guidance {
      width: 100%;
      background: #f9fbff;
      border: 1px solid #d7e6ff;
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 14px;
    }
    .live-guidance-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }
    .live-guidance-title {
      font-weight: bold;
      font-size: 13px;
      color: #0c5460;
      margin: 0;
    }
    .live-guidance-context {
      font-size: 12px;
      color: #555;
      text-align: right;
      margin: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 55%;
    }
    .live-guidance-status {
      font-size: 12px;
      color: #555;
      margin: 0 0 8px 0;
      min-height: 16px;
    }
    .live-guidance-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .live-guidance-item {
      background: #ffffff;
      border-radius: 10px;
      border: 1px solid #e4eefc;
      padding: 8px;
      font-size: 13px;
      line-height: 1.35;
      color: #1f2937;
    }
    .live-guidance-empty {
      font-size: 12px;
      color: #666;
      background: #ffffff;
      border-radius: 10px;
      border: 1px dashed #c8d8f5;
      padding: 8px;
    }
    .live-guidance-item-text {
      margin-bottom: 6px;
    }
    .live-guidance-item-actions {
      display: flex;
      justify-content: flex-end;
    }
    .mini-red-btn {
      border: none;
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 12px;
      color: #fff;
      cursor: pointer;
    }
    .mini-red-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    #recordBtn {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      font-size: 20px;
      font-weight: bold;
      color: #fff;
      margin-bottom: 10px;
      transition: background 0.2s, transform 0.1s;
    }
    #recordBtn.start {
      background: #28a745;
    }
    #recordBtn.recording {
      background: #dc3545;
    }
    #recordBtn:active {
      transform: scale(0.97);
    }

    /* Padronizacao: todos os botoes redondos principais */
    #recordBtn,
    #triageRecordBtn,
    #docsRecordBtn,
    #handoffRecordBtn {
      width: var(--round-btn-size);
      height: var(--round-btn-size);
      border-radius: 50%;
      font-size: 20px;
    }
    
    /* Triagem hospitalar: botão e separador */
    .module-divider {
      width: 100%;
      height: 1px;
      background: #e7e7e7;
      margin: 18px 0 14px 0;
    }
    .module-title {
      margin: 0 0 10px 0;
      font-size: 16px;
      font-weight: bold;
      color: #1f2937;
      text-align: center;
      width: 100%;
    }
    .module-subtitle {
      font-size: 12px;
      color: #555;
      text-align: center;
      margin: 0 0 12px 0;
      width: 100%;
    }

    #triageRecordBtn {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      color: #fff;
      margin-top: 6px;
      margin-bottom: 10px;
      transition: background 0.2s, transform 0.1s;
    }
    #triageRecordBtn.start { background: var(--brand-green); }
    #triageRecordBtn.recording { background: #dc3545; }
    #triageRecordBtn:active { transform: scale(0.97); }

    /* Documentos: botão e controles (mesmo padrão do Iniciar atendimento) */
    #docsRecordBtn {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      color: #fff;
      margin-top: 6px;
      margin-bottom: 10px;
      transition: background 0.2s, transform 0.1s;
    }
    #docsRecordBtn.start { background: #28a745; }
    #docsRecordBtn.recording { background: #dc3545; }
    #docsRecordBtn:active { transform: scale(0.97); }

    #docsPauseBtn {
      padding: 6px 14px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: #6c757d;
      color: #fff;
      font-size: 13px;
      display: none;
    }
    #docsTimer {
      font-size: 26px;
      margin-top: 10px;
      font-family: "Courier New", monospace;
    }
    #docsMicStatus {
      margin-top: 8px;
      font-size: 14px;
      text-align: center;
      color: #333;
      min-height: 20px;
    }
    #docsPauseLabel {
      margin-top: 6px;
      font-size: 12px;
      color: #555;
      text-align: center;
    }
    #docsFinishHint {
      margin-top: 10px;
      font-size: 12px;
      color: #333;
      text-align: center;
    }


    #triagePauseBtn {
      padding: 6px 14px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: #6c757d;
      color: #fff;
      font-size: 13px;
      display: none;
    }
    #triageTimer {
      font-size: 26px;
      margin-top: 10px;
      font-family: "Courier New", monospace;
    }
    #triageMicStatus {
      margin-top: 8px;
      font-size: 14px;
      text-align: center;
      color: #333;
      min-height: 20px;
    }

    #triagePauseLabel {
      margin-top: 6px;
      font-size: 12px;
      color: #555;
      text-align: center;
    }
    #triageFinishHint {
      margin-top: 10px;
      font-size: 12px;
      color: #333;
      text-align: center;
    }
    /* ============================
       MÓDULO: Passagem de plantão
       (mesma identidade do botão de triagem)
       ============================ */
    #handoffRecordBtn {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      color: #fff;
      margin-top: 6px;
      margin-bottom: 10px;
      transition: background 0.2s, transform 0.1s;
    }
    #handoffRecordBtn.start { background: var(--brand-green); }
    #handoffRecordBtn.recording { background: #dc3545; }
    #handoffRecordBtn:active { transform: scale(0.97); }

    #handoffPauseBtn {
      padding: 6px 14px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: #6c757d;
      color: #fff;
      font-size: 13px;
      display: none;
    }
    #handoffTimer {
      font-size: 26px;
      margin-top: 10px;
      font-family: "Courier New", monospace;
    }
    #handoffMicStatus {
      margin-top: 8px;
      font-size: 14px;
      text-align: center;
      color: #333;
      min-height: 20px;
    }
    #handoffPauseLabel {
      margin-top: 6px;
      font-size: 12px;
      color: #555;
      text-align: center;
    }
    #handoffFinishHint {
      margin-top: 10px;
      font-size: 12px;
      color: #333;
      text-align: center;
    }


    .triage-report-panel {
      border: 1px solid #ddd;
      border-radius: 12px;
      padding: 14px;
      background: #ffffff;
      margin-bottom: 18px;
    }
    .triage-report-panel h2 {
      margin: 0 0 10px 0;
    }
    .triage-report-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    .triage-report-grid h3 {
      margin: 0 0 6px 0;
      font-size: 14px;
    }
    .triage-small-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    #triageCopyFullBtn, #triagePrintFullBtn {
      padding: 8px 18px;
      border-radius: 20px;
      border: 1px solid #0c5460;
      background: #ffffff;
      color: #0c5460;
      font-size: 14px;
      cursor: pointer;
    }
    #triageCopyFullBtn:hover, #triagePrintFullBtn:hover { background: #e6f2f5; }
#startNotice {
      font-size: 13px;
      color: #555;
      text-align: center;
      margin-top: 8px;
      margin-bottom: 8px;
    }
    #timer {
      font-size: 26px;
      margin-top: 16px;
      font-family: "Courier New", monospace;
    }
    #micStatus {
      margin-top: 8px;
      font-size: 14px;
      text-align: center;
      color: #333;
      min-height: 20px;
    }
    .controls-row {
      margin-top: 12px;
      display: flex;
      gap: 8px;
      align-items: center;
    }
    #pauseBtn {
      padding: 6px 14px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: #6c757d;
      color: #fff;
      font-size: 13px;
      display: none;
    }
    #pauseLabel {
      font-size: 12px;
      color: #555;
      margin-top: 6px;
      text-align: center;
    }
    #finishHint {
      font-size: 12px;
      color: #555;
      margin-top: 10px;
      text-align: center;
    }
    .results-card {
      background: #ffffff;
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      width: 100%;
      max-width: 800px;
      margin-top: 20px;
    }
    .results-card h2 {
      margin-top: 0;
    }
    .error {
      color: #b00020;
      margin-top: 8px;
      font-size: 13px;
      text-align: center;
    }
    .loading-dot::after {
      content: "...";
      animation: dots 1s steps(3, end) infinite;
    }
    @keyframes dots {
      0% { content: ""; }
      33% { content: "."; }
      66% { content: ".."; }
      100% { content: "..."; }
    }

    .soap-block {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 10px;
      background: #fafafa;
    }
    .soap-block-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }
    .soap-label {
      font-weight: bold;
      font-size: 14px;
    }
    .soap-textarea {
      width: 100%;
      min-height: 60px;
      resize: vertical;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #ddd;
      font-size: 14px;
      font-family: inherit;
      background: #ffffff;
    }
    .copy-soap-btn {
      padding: 4px 8px;
      border-radius: 12px;
      border: 1px solid #0c5460;
      background: #ffffff;
      color: #0c5460;
      font-size: 12px;
      cursor: pointer;
    }
    .copy-soap-btn:hover {
      background: #e6f2f5;
    }

    .prescription-textarea {
      width: 100%;
      min-height: 140px;
      resize: vertical;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #ddd;
      font-size: 14px;
      font-family: inherit;
      background: #fafafa;
      white-space: pre-wrap;
    }

    .prescription-actions {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    #copyPrescriptionBtn,
    #copySbarBtn,
    #printSbarBtn,
    #sbarRecordBtn,
    #copySaeBtn,
    #printPregnancyBtn,
    #printLactationBtn,
        #copyFullSoapBtn,
    #printSoapBtn,
    #updateInteractionsBtn,
    #printInteractionsBtn
{
      padding: 8px 18px;
      border-radius: 20px;
      border: 1px solid #0c5460;
      background: #ffffff;
      color: #0c5460;
      font-size: 14px;
      cursor: pointer;
    }
    #copyPrescriptionBtn:hover,
    #copySbarBtn:hover,
    #printSbarBtn:hover,
    #sbarRecordBtn:hover,
    #copySaeBtn:hover,
    #printPregnancyBtn:hover,
    #printLactationBtn:hover,
        #copyFullSoapBtn:hover,
    #printSoapBtn:hover,
    #updateInteractionsBtn:hover,
    #printInteractionsBtn:hover
{
      background: #e6f2f5;
    }

    #printBtn {
      margin-top: 0;
      padding: 8px 18px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: #0c5460;
      color: #fff;
      font-size: 14px;
      display: none;
    }

    #recommendationsBtn {
      margin-left: 0;
      padding: 8px 18px;
      border-radius: 20px;
      border: 1px solid #dc3545;
      background: #dc3545;
      color: #fff;
      cursor: pointer;
      font-size: 14px;
    }
    #recommendationsBtn:hover {
      background: #c82333;
      border-color: #c82333;
    }

    
    #sbarRecordBtn {
      border: 1px solid #dc3545;
      background: #dc3545;
      color: #fff;
    }
    #sbarRecordBtn:hover {
      background: #c82333;
      border-color: #c82333;
    }
.soap-title-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .recommendations-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 360px;
      max-width: 100%;
      height: 100vh;
      background: #ffffff;
      box-shadow: -2px 0 8px rgba(0,0,0,0.15);
      display: none;
      flex-direction: column;
      padding: 16px;
      z-index: 1000;
    }
    .recommendations-panel.visible {
      display: flex;
    }
    .recommendations-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .recommendations-header h3 {
      margin: 0;
      font-size: 16px;
    }
    .close-panel-btn {
      border: none;
      background: transparent;
      font-size: 18px;
      cursor: pointer;
      padding: 4px 8px;
    }
    .recommendations-status {
      font-size: 13px;
      color: #555;
      margin-bottom: 8px;
    }
    .recommendations-list {
      flex: 1;
      overflow-y: auto;
      margin-bottom: 12px;
      font-size: 14px;
    }
    .recommendation-item {
      background: #f5f5f5;
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 6px;
    }
    .ask-questions-btn {
      padding: 8px 16px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: #007bff;
      color: #fff;
      font-size: 14px;
    }
    .ask-questions-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .recommendations-footer {
      font-size: 11px;
      color: #666;
      margin-top: 8px;
    }

    .questions-timer {
      font-size: 18px;
      margin-top: 10px;
      font-family: "Courier New", monospace;
      text-align: center;
      color: #333;
    }

    .mini-status {
      margin-top: 6px;
      font-size: 12px;
      color: #555;
      min-height: 16px;
    }

    .classification-box {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 10px;
      background: #fafafa;
      white-space: pre-wrap;
      font-size: 14px;
      line-height: 1.35;
      min-height: 48px;
    }

    .risk-triage-box {
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 12px;
      background: #fafafa;
    }
    .risk-triage-current {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    .risk-badge {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      color: #fff;
      font-weight: bold;
      font-size: 13px;
      min-width: 120px;
      text-align: center;
    }
    .risk-none { background: #6c757d; }
    .risk-vermelho { background: #dc3545; }
    .risk-laranja { background: #fd7e14; }
    .risk-amarelo { background: #ffc107; color: #1f2937; }
    .risk-verde { background: #28a745; }
    .risk-azul { background: #0d6efd; }

    .risk-meaning {
      font-size: 14px;
      line-height: 1.35;
      color: #1f2937;
      white-space: pre-wrap;
      flex: 1;
      min-width: 180px;
    }

    .risk-legend {
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 13px;
      color: #1f2937;
    }
    .risk-legend-row {
      display: flex;
      align-items: flex-start;
      gap: 10px;
    }
    .risk-legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 4px;
      margin-top: 2px;
      flex: 0 0 14px;
    }
    .swatch-vermelho { background: #dc3545; }
    .swatch-laranja { background: #fd7e14; }
    .swatch-amarelo { background: #ffc107; }
    .swatch-verde { background: #28a745; }
    .swatch-azul { background: #0d6efd; }


    .section-header-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .section-header-row h2 {
      margin: 0;
    }

    .module-card {
      background: #ffffff;
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      width: 100%;
      max-width: 800px;
      margin-top: 20px;
    }
    .module-card h2 {
      margin-top: 0;
    }
    .inline-input-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 10px;
    }
    .text-input {
      flex: 1;
      min-width: 220px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #ddd;
      font-size: 14px;
      font-family: inherit;
      background: #ffffff;
    }
    .answer-box {
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 12px;
      background: #fafafa;
      white-space: pre-wrap;
      font-size: 14px;
      line-height: 1.4;
      min-height: 70px;
      margin-top: 12px;
    }
    

    /* Saídas formatadas: espaçamento entre parágrafos e tópicos em vermelho/negrito */
    .formatted-output {
      white-space: normal !important;
    }
    .formatted-output p {
      margin: 0 0 10px 0;
    }
    .formatted-output p:last-child {
      margin-bottom: 0;
    }
    .formatted-output ul,
    .formatted-output ol {
      margin: 0 0 10px 18px;
      padding: 0;
    }
    .formatted-output li {
      margin: 0 0 6px 0;
    }
    .formatted-output .topic {
      color: #b00020;
      font-weight: bold;
    }
.small-record-btn {
      padding: 10px 16px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      color: #fff;
      transition: background 0.2s, transform 0.1s;
    }
    .small-record-btn.start {
      background: #28a745;
    }
    .small-record-btn.recording {
      background: #dc3545;
    }
    .small-record-btn:active {
      transform: scale(0.98);
    }
    .report-actions {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    @media (max-width: 480px) {
      #recordBtn {
        width: 150px;
        height: 150px;
        font-size: 18px;
      }
      .prescription-actions {
        flex-direction: column;
        align-items: flex-start;
      }
    }

    
    .guide-inline {
      margin: 10px 0 12px;
      padding: 12px;
      border: 1px solid #e6e6e6;
      border-radius: 12px;
      background: #fafafa;
      color: #1f1f1f;
    }
    .guide-inline h3 {
      margin: 0 0 8px;
      font-size: 16px;
    }
    .guide-inline h4 {
      margin: 10px 0 6px;
      font-size: 14px;
    }
    .guide-inline p {
      margin: 8px 0;
    }
    .guide-inline ul {
      margin: 0 0 8px 18px;
    }
    .sbar-guide-btn {
      border-color: #0c5460;
      color: #0c5460;
      background: #ffffff;
    }

.hidden {
      display: none !important;
    }
  

    .patientinfo-panel {
      border: 1px solid #e6e6e6;
      border-radius: 10px;
      padding: 12px;
      margin-bottom: 12px;
      background: #fafafa;
    }
    .patientinfo-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .mini-timer {
      font-size: 16px;
      font-weight: bold;
      min-width: 64px;
    }
    .patient-summary {
      margin-top: 8px;
      font-size: 14px;
      color: #333;
      white-space: pre-wrap;
    }


  
    #patientInfoBtn {
      background: #b00020;
      border-color: #b00020;
    }
    #patientInfoBtn:hover {
      filter: brightness(0.95);
    }

  
    .photo-btn {
      background: #dc3545;
      border: none;
      color: #fff;
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
    }
    .photo-btn:hover {
      filter: brightness(0.95);
    }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.45);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      padding: 16px;
    }
    .modal {
      background: #fff;
      border-radius: 14px;
      width: 100%;
      max-width: 420px;
      padding: 16px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.25);
    }
    .modal h3 {
      margin: 0 0 8px 0;
      font-size: 16px;
    }
    .modal p {
      margin: 0 0 12px 0;
      font-size: 13px;
      color: #555;
    }
    .modal-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .modal-actions button {
      flex: 1 1 140px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #d1d5db;
      background: #f9fafb;
      cursor: pointer;
      font-weight: 600;
    }
    .modal-actions button.primary {
      background: #2563eb;
      color: #fff;
      border-color: #2563eb;
    }
    .modal-actions button.danger {
      background: #dc3545;
      color: #fff;
      border-color: #dc3545;
    }
        .hidden-input {
      position: absolute !important;
      left: -9999px !important;
      top: auto !important;
      width: 1px !important;
      height: 1px !important;
      opacity: 0 !important;
      overflow: hidden !important;
    }

    /* Mantém o modal antigo oculto para evitar interferência com os módulos de foto/arquivo. */
    #imageChoiceOverlay { display: none !important; }

.consult-type-panel {
      width: 100%;
      background: #ffffff;
      border-radius: 12px;
      border: 1px solid #e5e7eb;
      padding: 12px;
      margin-bottom: 12px;
    }
    .consult-type-title {
      margin: 0 0 10px 0;
      font-weight: bold;
      font-size: 13px;
      color: #111827;
    }
    .consult-type-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 10px;
    }
    .consult-type-btn {
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid #0c5460;
      background: #ffffff;
      color: #0c5460;
      font-size: 13px;
      cursor: pointer;
      flex: 1 1 160px;
      text-align: center;
      font-weight: 600;
    }
    .consult-type-btn:hover {
      background: #e6f2f5;
    }
    .consult-type-btn.active {
      background: #0c5460;
      color: #ffffff;
    }
    .consult-guide-drawer {
      width: 100%;
      background: #f9fbff;
      border: 1px solid #d7e6ff;
      border-radius: 12px;
      padding: 12px;
    }
    .consult-guide-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 10px;
      margin-bottom: 10px;
    }
    .consult-guide-title {
      font-weight: bold;
      font-size: 14px;
      color: #0c5460;
      margin: 0 0 4px 0;
    }
    .consult-guide-subtitle {
      font-size: 12px;
      color: #555;
      margin: 0;
    }
    .consult-guide-close {
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid #d1d5db;
      background: #ffffff;
      cursor: pointer;
      font-weight: 600;
      font-size: 12px;
    }
    .trimester-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin: 8px 0 10px 0;
    }
    .trimester-btn {
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid #0c5460;
      background: #ffffff;
      color: #0c5460;
      font-size: 12px;
      cursor: pointer;
      font-weight: 600;
    }
    .trimester-btn.active {
      background: #0c5460;
      color: #ffffff;
    }
    .consult-guide-content {
      font-size: 13px;
      color: #111827;
      line-height: 1.4;
    }
    .guide-section-title {
      font-weight: bold;
      margin: 10px 0 6px 0;
      color: #111827;
    }
    .consult-guide-content ol {
      margin: 0 0 6px 18px;
      padding: 0;
    }
    .consult-guide-content li {
      margin: 0 0 6px 0;
    }


  
    /* Padronização de botões de copiar e imprimir */
    .btn-copy {
      padding: 8px 18px;
      border-radius: 20px;
      border: 1px solid #fd7e14 !important;
      background: #fd7e14 !important;
      color: #ffffff !important;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.05s, opacity 0.15s;
    }
    .btn-copy:hover { opacity: 0.92; }
    .btn-copy:active { transform: scale(0.98); }

    .btn-print {
      padding: 8px 18px;
      border-radius: 20px;
      border: 1px solid #0d6efd !important;
      background: #0d6efd !important;
      color: #ffffff !important;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.05s, opacity 0.15s;
    }
    .btn-print:hover { opacity: 0.92; }
    .btn-print:active { transform: scale(0.98); }


    .guide-main-btn {
      padding: 7px 12px;
      font-size: 12px;
      border-radius: 14px;
      white-space: normal;
      line-height: 1.15;
    }

    /* Botões "Copiar" por seção do SOAP (mesma identidade visual, tamanho menor) */
    .copy-soap-btn {
      border: 1px solid #fd7e14 !important;
      background: #fd7e14 !important;
      color: #ffffff !important;
      border-radius: 20px;
      padding: 4px 10px;
      font-size: 12px;
      cursor: pointer;
    }
    .copy-soap-btn:hover { opacity: 0.92; }

    /* Botão flutuante de contato via WhatsApp */
    .whatsapp-fab {
      position: fixed;
      right: 18px;
      bottom: 18px;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: none;
      background: #25D366;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 8px 18px rgba(0,0,0,0.20);
      cursor: pointer;
      text-decoration: none;
      z-index: 2000;
    }
    .whatsapp-fab:active { transform: scale(0.98); }
    .whatsapp-fab svg { width: 28px; height: 28px; fill: #ffffff; }
    
    .whatsapp-fab-label {
      position: fixed;
      right: 84px;
      bottom: 18px;
      background: #ffffff;
      border: 1px solid #e5e7eb;
      border-radius: 14px;
      padding: 10px 12px;
      font-size: 12px;
      color: #111827;
      box-shadow: 0 6px 16px rgba(0,0,0,0.12);
      z-index: 2000;
      user-select: none;
      max-width: 270px;
      line-height: 1.2;
    }
    .whatsapp-fab-label .wa-label-title {
      font-weight: 800;
      font-size: 12px;
      margin-bottom: 3px;
    }
    .whatsapp-fab-label .wa-label-sub {
      font-weight: 600;
      font-size: 11px;
      color: #374151;
    }
    @media (max-width: 520px) {
      .whatsapp-fab-label {
        right: 72px;
        bottom: 12px;
        padding: 8px 10px;
        max-width: 210px;
      }
      .whatsapp-fab-label .wa-label-sub {
        font-size: 10px;
      }
    }

/* =========================
       AUTENTICAÇÃO E ADMIN
       ========================= */
    .auth-shell {
      min-height: 100vh;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 8px 16px 16px 16px;
    }
    .auth-card {
      width: 100%;
      max-width: 420px;
      background: #ffffff;
      border-radius: 16px;
      padding: 26px 20px 20px 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      margin-top: 0px;
    }
    .auth-subtitle {
      margin-top: 6px;
      margin-bottom: 16px;
      font-size: 13px;
      color: #555;
    }
    .auth-label {
      width: 100%;
      display: block;
      margin: 10px 0 6px 0;
      font-size: 13px;
      color: #333;
      font-weight: bold;
    }
    .auth-input {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #ddd;
      font-size: 14px;
      outline: none;
      background: #fff;
    }
    .auth-btn {
      width: 100%;
      margin-top: 14px;
      padding: 10px 12px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      background: #0c5460;
      color: #fff;
      font-size: 14px;
      font-weight: 700;
    }
    .auth-btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .auth-error {
      margin-top: 10px;
      font-size: 13px;
      color: #b00020;
      min-height: 18px;
    }
    .auth-help {
      margin-top: 12px;
      font-size: 12px;
      color: #666;
    }

    .nurse-bar {
      width: 100%;
      border: 1px solid #e5e7eb;
      border-radius: 14px;
      background: #ffffff;
      padding: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }
    .nurse-bar-line { font-size: 13px; color: #111827; }
    .nurse-bar-label { color: #6b7280; font-weight: 700; margin-right: 6px; }
    .nurse-bar-actions { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .danger-btn {
      padding: 10px 14px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      background: #dc3545;
      color: #fff;
      font-weight: 800;
      font-size: 13px;
    }
    .pill {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      border: 1px solid #ddd;
      background: #f2f2f2;
      color: #555;
      font-weight: 800;
      white-space: nowrap;
    }
    .pill.green { background: #e7f7ec; border-color: #bfe8c9; color: #145a22; }
    .pill.red { background: #fde8ea; border-color: #f3c2c7; color: #7a1420; }

    .admin-shell {
      width: 100%;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    .admin-wrap {
      width: 100%;
      max-width: 980px;
    }
    .admin-card {
      background: #ffffff;
      border-radius: 16px;
      padding: 18px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      margin-top: 14px;
    }
    .admin-row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .admin-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }
    @media (max-width: 720px) {
      .admin-grid { grid-template-columns: 1fr; }
    }
    .admin-field label {
      display: block;
      font-size: 12px;
      color: #555;
      margin: 0 0 6px 0;
      font-weight: 700;
    }
    .admin-field input {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid #ddd;
      font-size: 14px;
      outline: none;
    }
    .admin-btn {
      padding: 10px 14px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      background: #0c5460;
      color: #fff;
      font-weight: 800;
      font-size: 13px;
    }
    .admin-btn.secondary { background: #6c757d; }
    .admin-btn.danger { background: #dc3545; }
    .admin-status {
      margin-top: 10px;
      font-size: 12px;
      color: #333;
      min-height: 18px;
      white-space: pre-wrap;
    }
    .admin-table-wrap { overflow-x: auto; margin-top: 10px; }
    table.admin-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }
    table.admin-table th, table.admin-table td {
      border-bottom: 1px solid #eee;
      padding: 10px 8px;
      text-align: left;
      vertical-align: top;
      white-space: nowrap;
    }
    table.admin-table th { background: #f7f7f7; font-weight: 900; }
    .admin-actions { display: flex; gap: 8px; flex-wrap: wrap; }
    .admin-actions button { padding: 8px 10px; border-radius: 10px; font-size: 12px; }
    .modal-overlay.hidden { display: none; }


    .admin-form-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;}
    @media (max-width: 720px){.admin-form-grid{grid-template-columns:1fr;}}


    /* Ajustes visuais e responsividade (computador e celular) */
    .page { width: 100%; }
    .center-card, .results-card, .admin-card { width: 100%; }
    input, textarea, select { max-width: 100%; }

    .nurse-bar {
      width: 100%;
      max-width: 900px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      padding: 12px 14px;
      border-radius: 14px;
      background: #ffffff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.10);
      margin: 10px auto 14px auto;
    }
    .nurse-bar-line { margin: 2px 0; }

    .consult-type-btn { white-space: normal; }

    @media (max-width: 720px) {
      body { align-items: flex-start; }
      .page { padding: 12px; }
      h1 { font-size: 26px; margin-top: 14px; }
      .center-card { padding: 18px 14px; max-width: 100%; }
      .results-card { padding: 16px 14px; }
      .nurse-bar { flex-direction: column; align-items: flex-start; }
      .nurse-bar-actions { width: 100%; display: flex; justify-content: flex-end; }
      .consult-type-buttons { flex-direction: column; }
      .consult-type-btn { width: 100%; text-align: left; }
      .admin-row { flex-wrap: wrap; }
      .admin-btn { width: 100%; justify-content: center; }
      .admin-table-wrap { border: 1px solid #eee; border-radius: 12px; }
    }

    @media (max-width: 420px) {
      .page { padding: 10px; }
      h1 { font-size: 24px; }
      #recordBtn { width: 145px; height: 145px; }
    }



    /* =========================
       AJUSTES MOBILE (RESPONSIVO)
       ========================= */
    html, body {
      width: 100%;
      max-width: 100%;
      overflow-x: hidden;
    }
    body {
      display: block;
    }
    .page {
      align-items: stretch;
      margin: 0 auto;
      max-width: 980px;
      min-width: 0;
    }
    .center-card,
    .results-card,
    .module-card,
    .auth-card,
    .admin-wrap {
      min-width: 0;
      max-width: 100%;
    }

    /* Evitar cortes por itens flex/grids */
    .section-header-row > * { min-width: 0; }
    .inline-input-row > * { min-width: 0; }
    input, select, textarea, button { max-width: 100%; }
    .answer-box, .classification-box, .patient-summary {
      word-break: break-word;
      overflow-wrap: anywhere;
    }

    @media (max-width: 720px) {
      h1 { font-size: 22px; margin: 14px 0 8px 0; }
      .page { padding: 12px; }
      .center-card { padding: 16px 12px 14px 12px; }
      .results-card, .module-card { padding: 14px; }
      .nurse-bar { padding: 10px; }
      .nurse-bar-actions { width: 100%; justify-content: flex-end; }
    }

    @media (max-width: 520px) {
      .inline-input-row,
      .patientinfo-row,
      .controls-row,
      .section-header-row {
        flex-direction: column;
        align-items: stretch;
      }

      .prescription-actions,
      .report-actions {
        flex-direction: column;
        align-items: stretch;
      }
      .prescription-actions > button,
      .report-actions > button,
      .nurse-bar-actions > button,
      #recommendationsBtn {
        width: 100%;
      }

      .text-input {
        min-width: 0 !important;
        width: 100%;
      }

      /* Guias de consulta: compacto no celular */
      .consult-type-buttons {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
      }
      .consult-type-btn {
        flex: initial;
        width: 100%;
        text-align: center;
        font-size: 12px;
        padding: 8px 10px;
        border-radius: 12px;
        line-height: 1.15;
      }

      .consult-guide-header {
        flex-direction: column;
        align-items: stretch;
      }
      .consult-guide-close { width: 100%; }

      .recommendations-panel {
        width: 100%;
        right: 0;
      }

      .whatsapp-fab {
        width: 52px;
        height: 52px;
        right: 12px;
        bottom: 12px;
      }
    }

    @media (max-width: 360px) {
      .consult-type-buttons { grid-template-columns: 1fr; }
    }


    /* =========================
       MÓDULO: CALCULADORAS CLÍNICAS
       ========================= */
    .calc-panel {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #eee;
    }
    .calc-title {
      font-weight: 800;
      margin: 0 0 8px 0;
      font-size: 14px;
      color: #111827;
    }
    .calc-help {
      margin: 0 0 10px 0;
      font-size: 12px;
      color: #555;
      line-height: 1.35;
    }
    .calc-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 10px;
    }
    .calc-row .text-input {
      min-width: 160px;
    }
    .calc-link {
      display: inline-block;
      margin-top: 8px;
      font-size: 13px;
      color: #0c5460;
      text-decoration: underline;
      cursor: pointer;
    }
    .calc-muted {
      font-size: 12px;
      color: #666;
      margin-top: 8px;
      white-space: pre-wrap;
      line-height: 1.35;
    }

  

    .module-title-row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:6px;
    }
    .mini-consult-btn{
      padding:7px 12px;
      font-size:12px;
      border-radius:12px;
      white-space:nowrap;
    }

    #sbarRecordBtn{
      width:180px;
      height:180px;
      border-radius:50%;
      border:none;
      cursor:pointer;
      font-size:18px;
      font-weight:800;
      color:#fff;
      margin:10px auto 6px auto;
      display:block;
      transition:transform 0.15s ease, background-color 0.15s ease;
    }
    #sbarRecordBtn:active{
      transform:scale(0.97);
    }
    
    #sbarRecordBtn.start{
      background:#28a745;
    }
    #sbarRecordBtn.recording{
      background:#dc3545;
    }
    #sbarRecordBtn:disabled{
      opacity:0.72;
      cursor:not-allowed;
    }

#sbarRecordBtn.generating{
      background:#dc3545 !important;
    }

    .mini-timer{
      text-align:center;
      font-size:18px;
      font-weight:700;
      margin:6px 0 10px 0;
      color:#fff;
      opacity:0.92;
    }


    .site-verse{
      text-align:center;
      font-size:13px;
      color:#374151;
      margin:0 0 10px 0;
      line-height:1.35;
    }
    


    .page-refresh{
      max-width: 980px;
      margin: 10px auto 12px auto;
      padding: 12px 14px;
      background: #ffffff;
      border: 1px solid #e5e7eb;
      border-radius: 14px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    .page-refresh-text{
      margin: 0;
      color: #374151;
      font-size: 13px;
      line-height: 1.35;
      flex: 1 1 320px;
    }

    .page-refresh-btn{
      border: 0;
      border-radius: 12px;
      padding: 10px 14px;
      font-weight: 800;
      font-size: 13px;
      cursor: pointer;
      background: #0b5563;
      color: #ffffff;
      transition: filter 0.15s ease;
    }

    .page-refresh-btn:hover{
      filter: brightness(0.96);
    }

    .page-refresh-btn:active{
      filter: brightness(0.92);
    }

    @media (max-width: 520px){
      .page-refresh{
        padding: 12px;
      }
      .page-refresh-btn{
        width: 100%;
      }
    }
/* =========================
   MÓDULO: APRAZAMENTO DE PRESCRIÇÃO (folha editável e imprimível)
   ========================= */
.rx-sheet-wrapper{
  background: #f8fafc;
  border: 1px solid #e5e7eb;
  border-radius: 10px;
  padding: 12px;
}
.rx-sheet-placeholder{
  color: #6b7280;
  font-size: 13px;
  padding: 8px;
}
.rx-sheet{
  background: #ffffff;
  border: 1px solid #d1d5db;
  border-radius: 10px;
  padding: 14px;
  font-family: Arial, sans-serif;
  color: #111827;
}
.rx-sheet .rx-title{
  font-size: 16px;
  font-weight: 700;
  margin: 0 0 8px 0;
}
.rx-sheet .rx-subtitle{
  font-size: 12px;
  color: #374151;
  margin: 0 0 10px 0;
}
.rx-grid{
  width: 100%;
  border-collapse: collapse;
  table-layout: fixed;
}
.rx-grid th, .rx-grid td{
  border: 1px solid #d1d5db;
  padding: 6px 6px;
  font-size: 12px;
  vertical-align: top;
  word-break: break-word;
}
.rx-grid th{
  background: #f3f4f6;
  font-weight: 700;
}
.rx-kv{
  width: 100%;
  border-collapse: collapse;
  margin-bottom: 10px;
}
.rx-kv td{
  border: 1px solid #d1d5db;
  padding: 6px 6px;
  font-size: 12px;
}
.rx-kv .label{
  width: 140px;
  background: #f9fafb;
  font-weight: 700;
  color: #374151;
}
.rx-field{
  outline: none;
  min-height: 16px;
}
.rx-field[contenteditable="true"]:focus{
  box-shadow: 0 0 0 2px rgba(59,130,246,0.25);
  border-radius: 4px;
}
.rx-hours{
  margin-top: 10px;
}
.rx-hours-title{
  font-size: 12px;
  font-weight: 700;
  margin: 0 0 6px 0;
}
.rx-hours-grid{
  width: 100%;
  border-collapse: collapse;
  table-layout: fixed;
}
.rx-hours-grid th, .rx-hours-grid td{
  border: 1px solid #d1d5db;
  font-size: 10px;
  padding: 4px 2px;
  text-align: center;
}
.rx-hours-grid th{
  background: #f3f4f6;
  font-weight: 700;
}
.rx-hours-grid td.due{
  background: #d32f2f;
  color: #ffffff;
  -webkit-print-color-adjust: exact;
  print-color-adjust: exact;
}
.rx-hours-grid td.due .rx-field{ color: #ffffff; }
.rx-details{
  margin-top: 10px;
}
.rx-original-grid{
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 8px;
  margin-top: 8px;
}
.rx-original-grid img{
  width: 100%;
  border-radius: 8px;
  border: 1px solid #e5e7eb;
}
@media print{
  body{
    background: #ffffff !important;
  }
  .module-card, .top-bar, .tabs, .nav, .sidebar, .btn-print, .btn-copy, .photo-btn, .recommendations-panel{
    display: none !important;
  }
  .rx-sheet-wrapper{
    border: none !important;
    padding: 0 !important;
    background: transparent !important;
  }
  .rx-sheet{
    border: 1px solid #111827 !important;
    border-radius: 0 !important;
    padding: 12px !important;
  }
  .rx-field[contenteditable="true"]:focus{
    box-shadow: none !important;
  }
}


    /* MÓDULO: Escala de plantão */
    .roster-shell {
      width: 100%;
      background: #ffffff;
      border: 1px solid #e7e7e7;
      border-radius: 14px;
      padding: 12px;
      margin-top: 10px;
    }
    .roster-step-title {
      font-size: 14px;
      font-weight: bold;
      color: #1f2937;
      margin: 8px 0 8px 0;
    }
    .roster-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      width: 100%;
    }
    @media (max-width: 720px) {
      .roster-grid { grid-template-columns: 1fr; }
    }
    .roster-field label {
      display: block;
      font-size: 12px;
      color: #444;
      margin-bottom: 4px;
      font-weight: bold;
    }
    .roster-field input, .roster-field select, .roster-field textarea {
      width: 100%;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid #ddd;
      font-size: 14px;
      background: #fff;
    }
    .roster-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
    }
    .roster-actions button {
      border: none;
      border-radius: 10px;
      padding: 10px 12px;
      cursor: pointer;
      font-size: 13px;
      background: var(--brand-green);
      color: #fff;
    }
    .roster-actions button.secondary {
      background: #6c757d;
    }
    .roster-actions button.danger {
      background: #dc3545;
    }
    .roster-actions button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .roster-note {
      font-size: 12px;
      color: #555;
      margin-top: 8px;
      line-height: 1.45;
    }
    .roster-coverage-box {
      width: 100%;
      margin-top: 10px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid #d7e6ff;
      background: #f9fbff;
      font-size: 12px;
      color: #1f2937;
      line-height: 1.45;
    }
    .roster-coverage-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 8px;
    }
    @media (max-width: 720px) {
      .roster-coverage-grid { grid-template-columns: 1fr; }
    }
    .roster-coverage-item {
      background: #ffffff;
      border-radius: 10px;
      border: 1px solid #e4eefc;
      padding: 8px;
      font-size: 12px;
    }

    .roster-table-wrap {
      width: 100%;
      overflow: auto;
      border: 1px solid #e7e7e7;
      border-radius: 12px;
      margin-top: 10px;
      background: #fff;
    }
    table.roster-table {
      width: 100%;
      border-collapse: collapse;
      min-width: 820px;
    }
    table.roster-table th, table.roster-table td {
      border-bottom: 1px solid #eee;
      padding: 8px;
      font-size: 13px;
      text-align: left;
      vertical-align: top;
    }
    table.roster-table th {
      background: #f7f7f7;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .roster-mini-input {
      width: 100%;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid #ddd;
      font-size: 13px;
      background: #fff;
    }
    .roster-warn {
      font-size: 12px;
      color: #8a3b12;
      background: #fff3cd;
      border: 1px solid #ffeeba;
      border-radius: 12px;
      padding: 10px;
      margin-top: 10px;
      white-space: pre-wrap;
    }

    .roster-team-cards {
      display: none;
      width: 100%;
      margin-top: 10px;
      gap: 10px;
    }
    .roster-team-card {
      background: #ffffff;
      border: 1px solid #e7e7e7;
      border-radius: 14px;
      padding: 10px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.06);
    }
    .roster-team-card-title {
      font-weight: bold;
      font-size: 13px;
      color: #1f2937;
      margin: 0 0 8px 0;
    }
    .roster-team-card-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }
    .roster-team-card-actions {
      margin-top: 10px;
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    .roster-output {
      margin-top: 12px;
      width: 100%;
    }
    .roster-output-mobile {
      display: none;
      width: 100%;
      margin-top: 10px;
      gap: 10px;
    }
    .roster-out-card {
      background: #ffffff;
      border: 1px solid #e7e7e7;
      border-radius: 14px;
      padding: 10px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.06);
      font-size: 13px;
      color: #1f2937;
      line-height: 1.45;
    }
    .roster-out-card-title {
      font-weight: bold;
      margin: 0 0 6px 0;
      font-size: 13px;
    }
    .roster-out-card-line {
      margin: 0 0 6px 0;
    }
    .roster-pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid #e4eefc;
      background: #f9fbff;
      font-size: 12px;
      color: #1f2937;
      margin-right: 6px;
    }

    @media (max-width: 720px) {
      .roster-table-wrap.roster-desktop-only { display: none; }
      table.roster-table { min-width: 0; }
      .roster-team-cards { display: flex; flex-direction: column; }
      .roster-output-mobile { display: flex; flex-direction: column; }
    }

  
    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    @media (max-width: 720px) {
      .grid-2 { grid-template-columns: 1fr; }
    }
    .simple-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .simple-list-item {
      border: 1px solid #e7e7e7;
      border-radius: 12px;
      padding: 10px;
      background: #fff;
      font-size: 13px;
      line-height: 1.45;
      color: #1f2937;
    }
    .simple-list-item .muted {
      color: #6b7280;
      font-size: 12px;
      margin-top: 4px;
    }
  .rx-subsection { margin-top: 12px; }
  .rx-subsection-title { font-size: 13px; font-weight: 700; margin: 0 0 8px 0; }
  .pill-buttons { display: flex; flex-wrap: wrap; gap: 8px; }
  .pill-buttons button { border: 1px solid #cbd5e1; background: #ffffff; padding: 8px 10px; border-radius: 999px; font-size: 12px; cursor: pointer; }
  .pill-buttons button:hover { background: #f1f5f9; }
  .mono-pre { white-space: pre-wrap; border: 1px solid #e5e7eb; border-radius: 12px; padding: 12px; background: #ffffff; max-height: 60vh; overflow: auto; }

  .tutorial-module { margin: 14px 0 16px 0; padding: 12px; border: 1px solid #e5e7eb; border-radius: 14px; background: #ffffff; }
  .tutorial-title { font-size: 14px; font-weight: 800; margin: 0 0 6px 0; }
  .tutorial-desc { font-size: 12px; color: #6b7280; margin: 0 0 10px 0; line-height: 1.35; }
  .tutorial-video { width: 100%; max-height: 320px; border-radius: 12px; background: #0b1220; display: block; }

  
/* ===== Avaliar receita (módulo) ===== */
.rx-topic {
  color: var(--danger, #c1121f);
  font-weight: 700;
  margin: 16px 0 6px;
}
.rx-paragraph {
  margin: 0 0 10px;
  line-height: 1.45;
}
.rx-details {
  margin-top: 14px;
}
.rx-pill-wrap {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-top: 10px;
}
.rx-pill-btn {
  border: 1px solid rgba(255,255,255,0.18);
  background: rgba(255,255,255,0.06);
  color: inherit;
  padding: 10px 12px;
  border-radius: 10px;
  cursor: pointer;
  font-weight: 600;
}
.rx-pill-btn:hover {
  background: rgba(255,255,255,0.1);
}
.rx-editable {
  width: 100%;
  min-height: 180px;
  resize: vertical;
  border: 1px solid rgba(255,255,255,0.18);
  background: rgba(255,255,255,0.04);
  color: inherit;
  border-radius: 12px;
  padding: 12px;
  font-family: inherit;
  font-size: 14px;
  line-height: 1.45;
}
.rx-links {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-top: 10px;
}
.rx-link-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border: 1px solid rgba(255,255,255,0.18);
  background: rgba(255,255,255,0.06);
  color: inherit;
  padding: 10px 12px;
  border-radius: 10px;
  text-decoration: none;
  font-weight: 600;
}
.rx-link-btn:hover {
  background: rgba(255,255,255,0.1);
}
</style>
</head>
<body>

  <div id="loginView" class="auth-shell">
    <div class="auth-card">
      <p class="site-verse">Provérbios 16:3: "Consagre ao Senhor tudo o que você faz, e os seus planos serão bem-sucedidos"</p>

      <h1>Atendimento de Enfermagem</h1>
      <p class="auth-subtitle">Ferramenta para auxiliar os profissionais de enfermagem.<br>Acesso restrito para profissionais cadastrados.</p>

      <label class="auth-label" for="loginField">CPF (Login)</label>
      <input id="loginField" class="auth-input" autocomplete="username" inputmode="numeric" />

      <label class="auth-label" for="passwordField">Senha</label>
      <input id="passwordField" class="auth-input" type="password" autocomplete="current-password" />

      <button id="loginBtn" class="auth-btn" type="button">Entrar</button>
      <div id="loginError" class="auth-error"></div>

      <button id="openSignupBtn" class="auth-btn outline" type="button">Cadastrar enfermeiro(a)</button>

      <div class="auth-help">
        Se não conseguir acessar, use o botão “Entrar em contato”.
      </div>

      <div class="tutorial-module" id="tutorial1">
        <div class="tutorial-title">Tutorial 1</div>
        <div class="tutorial-desc">Assista este vídeo antes de fazer login para entender o fluxo da plataforma e evitar dúvidas no primeiro acesso.</div>
        <video class="tutorial-video" controls preload="metadata">
          <source src="tutorial-1.mp4" type="video/mp4" />
        </video>
      </div>

      <div class="tutorial-module" id="tutorial2">
        <div class="tutorial-title">Tutorial 2</div>
        <div class="tutorial-desc">Continuação do treinamento inicial. Se o Tutorial 1 terminar e você ainda tiver dúvidas, assista este segundo vídeo.</div>
        <video class="tutorial-video" controls preload="metadata">
          <source src="tutorial-2.mp4" type="video/mp4" />
        </video>
      </div>

      <div class="tutorial-module" id="tutorial3">
        <div class="tutorial-title">Tutorial 3</div>
        <div class="tutorial-desc">Parte final do treinamento. Assista este vídeo para tirar dúvidas comuns e aprender boas práticas no uso diário da plataforma.</div>
        <video class="tutorial-video" controls preload="metadata">
          <source src="tutorial-3.mp4" type="video/mp4" />
        </video>
      </div>

    </div>
  </div>

<div id="nurseSignupView" class="auth-shell hidden">
    <div class="auth-card">
      <p class="site-verse">Provérbios 16:3: "Consagre ao Senhor tudo o que você faz, e os seus planos serão bem-sucedidos"</p>
      <h1>Cadastro de enfermeiro(a)</h1>
      <p class="auth-subtitle">Preencha os dados para criar seu cadastro.</p>

      <label class="auth-label" for="signupFullName">Nome completo</label>
      <input id="signupFullName" class="auth-input" autocomplete="name" inputmode="text" />

      <label class="auth-label" for="signupDob">Data de nascimento</label>
      <input id="signupDob" class="auth-input" type="date" />

      <label class="auth-label" for="signupPhone">Telefone</label>
      <input id="signupPhone" class="auth-input" type="tel" autocomplete="tel" inputmode="tel" />

      <label class="auth-label" for="signupLogin">CPF (Login)</label>
      <input id="signupLogin" class="auth-input" autocomplete="username" inputmode="numeric" />

      <label class="auth-label" for="signupPassword">Senha</label>
      <input id="signupPassword" class="auth-input" type="password" autocomplete="new-password" />

      <button id="signupBtn" class="auth-btn" type="button">Cadastrar</button>
      <button id="signupBackBtn" class="auth-btn secondary" type="button">Voltar</button>
      <div id="signupError" class="auth-error"></div>

      <div class="auth-help">
        Após o cadastro, o acesso ao sistema pode depender de liberação/regularização com o administrador.
      </div>
    </div>
  </div>


  <div id="adminView" class="admin-shell hidden">
    <div class="admin-wrap">
      <div class="admin-row" style="justify-content: space-between; align-items: flex-end;">
        <div>
                 <p class="site-verse">Provérbios 16:3: "Consagre ao Senhor tudo o que você faz, e os seus planos serão bem-sucedidos"</p>
           <h1 style="margin: 10px 0 4px 0;">Painel do Administrador</h1>
          <div id="adminSubtitle" style="font-size: 12px; color: #555;"></div>
          <div id="adminLocalBackupInfo" style="font-size: 12px; color: #555; margin-top: 2px;"></div>
        </div>
        <div class="admin-row">
          <button id="adminRefreshBtn" class="admin-btn secondary" type="button">Atualizar</button>
          <button id="adminBackupBtn" class="admin-btn secondary" type="button">Baixar backup</button>
          <button id="adminRestoreBtn" class="admin-btn secondary" type="button">Restaurar backup</button>
          <input id="adminRestoreFile" type="file" accept="application/json" style="display:none" />
          <button id="adminLogoutBtn" class="admin-btn danger" type="button">Sair</button>
        </div>
      </div>

      <div class="admin-card">
        <h2 style="margin: 0 0 10px 0;">Cadastrar enfermeiro(a)</h2>
        <div class="admin-grid">
          <div class="admin-field">
            <label for="newFullName">Nome completo</label>
            <input id="newFullName" type="text" />
          </div>
          <div class="admin-field">
            <label for="newDob">Data de nascimento</label>
            <input id="newDob" type="date" />
          </div>
          <div class="admin-field">
            <label for="newPhone">Telefone</label>
            <input id="newPhone" type="tel" />
          </div>
          <div class="admin-field">
            <label for="newLogin">CPF (Login)</label>
            <input id="newLogin" type="text" inputmode="numeric" />
          </div>
          <div class="admin-field">
            <label for="newPassword">Senha</label>
            <input id="newPassword" type="text" />
          </div>
          <div class="admin-field" style="display:flex; align-items:flex-end;">
            <button id="createUserBtn" class="admin-btn" type="button" style="width:100%;">Cadastrar</button>
          </div>
        </div>
        <div id="createUserStatus" class="admin-status"></div>
      </div>

      <div class="admin-card">
        <div class="admin-row" style="justify-content: space-between;">
          <h2 style="margin: 0;">Enfermeiros cadastrados</h2>
          <input id="adminSearch" class="auth-input" placeholder="Buscar por nome, login ou telefone" style="max-width: 360px;" />
        </div>
        <div class="admin-table-wrap">
          <table class="admin-table">
            <thead>
              <tr>
                <th>Nome</th>
                <th>CPF (Login)</th>
                <th>Telefone</th>
                <th>Online</th>
                <th>Mensalidade</th>
                <th>Último login</th>
                <th>Ações</th>
              </tr>
            </thead>
            <tbody id="usersTbody"></tbody>
          </table>
        </div>
        <div id="adminStatus" class="admin-status"></div>
      </div>

      <div class="admin-card">
        <h2 style="margin: 0 0 10px 0;">Auditoria administrativa (somente leitura)</h2>
        <div class="admin-table-wrap">
          <table class="admin-table">
            <thead>
              <tr>
                <th>Registro de pagamento</th>
                <th>Recebido por (Admin)</th>
              </tr>
            </thead>
            <tbody id="auditTbody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <div id="paymentsModal" class="modal-overlay hidden">
    <div class="modal" style="max-width: 720px;">
      <h3 style="margin:0 0 8px 0;">Histórico de pagamentos</h3>
      <p id="paymentsModalSubtitle" style="margin:0 0 10px 0; font-size: 12px; color: #555;"></p>
      <div class="admin-table-wrap" style="max-height: 55vh; overflow:auto;">
        <table class="admin-table">
          <thead>
            <tr>
              <th>Mês</th>
              <th>Pago em</th>
              <th>Valor</th>
              <th>Método</th>
              <th>Observações</th>
            </tr>
          </thead>
          <tbody id="paymentsTbody"></tbody>
        </table>
      </div>
      <div class="admin-row" style="justify-content:flex-end; margin-top: 12px;">
        <button id="closePaymentsBtn" class="admin-btn secondary" type="button">Fechar</button>
      </div>
      <div style="margin-top: 10px; font-size: 12px; color: #666;">Este histórico é permanente. Não há opção de editar ou apagar registros.</div>
    </div>
    <div id="editUserModal" class="modal-overlay hidden">
    <div class="modal" style="max-width: 720px;">
      <h3 style="margin:0 0 8px 0;">Editar enfermeiro(a)</h3>
      <p id="editUserSubtitle" style="margin:0 0 10px 0; font-size: 12px; color: #555;"></p>

      <div class="admin-form-grid">
        <div>
          <label class="auth-label">Nome completo</label>
          <input id="editFullName" class="auth-input" placeholder="Nome completo" />
        </div>
        <div>
          <label class="auth-label">Data de nascimento</label>
          <input id="editDob" class="auth-input" placeholder="dd/mm/aaaa" />
        </div>
        <div>
          <label class="auth-label">Telefone</label>
          <input id="editPhone" class="auth-input" placeholder="Telefone" />
        </div>
        <div>
          <label class="auth-label">Login</label>
          <input id="editLogin" class="auth-input" placeholder="Login" />
        </div>
        <div style="grid-column: 1 / -1;">
          <label class="auth-label">Nova senha (opcional)</label>
          <input id="editPassword" class="auth-input" placeholder="Deixe em branco para não alterar" />
          <div style="margin-top:6px; font-size: 12px; color:#666;">Se preencher, a senha será atualizada. O histórico de pagamentos não é alterado.</div>
        </div>
      </div>

      <div class="admin-row" style="justify-content:flex-end; margin-top: 14px;">
        <button id="cancelEditUserBtn" class="admin-btn secondary" type="button">Cancelar</button>
        <button id="saveEditUserBtn" class="admin-btn" type="button" style="margin-left: 10px;">Salvar</button>
      </div>
    </div>
  </div>

</div>

  
  <div id="addFriendModal" class="modal-overlay hidden">
    <div class="modal" style="max-width: 520px;">
      <div class="modal-header">
        <div>
          <h2 class="modal-title">Adicionar amigo</h2>
          <p class="modal-subtitle">Cadastre um subusuário vinculado ao seu acesso.</p>
        </div>
        <button id="closeAddFriendModalBtn" class="modal-close" type="button">Fechar</button>
      </div>

      <div class="modal-body">
        <div class="grid-2">
          <div>
            <label class="auth-label" for="friendFullName">Nome completo</label>
            <input id="friendFullName" class="auth-input" inputmode="text" />
          </div>
          <div>
            <label class="auth-label" for="friendDob">Data de nascimento</label>
            <input id="friendDob" class="auth-input" placeholder="DD/MM/AAAA" inputmode="text" />
          </div>
        </div>

        <div class="grid-2">
          <div>
            <label class="auth-label" for="friendPhone">Telefone</label>
            <input id="friendPhone" class="auth-input" inputmode="tel" />
          </div>
          <div>
            <label class="auth-label" for="friendLogin">CPF (Login) do amigo</label>
            <input id="friendLogin" class="auth-input" inputmode="numeric" />
          </div>
        </div>

        <label class="auth-label" for="friendPassword">Senha do amigo</label>
        <input id="friendPassword" class="auth-input" type="password" autocomplete="new-password" />

        <div id="addFriendError" class="auth-error"></div>
        <div style="margin-top: 10px; display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap;">
          <button id="saveFriendBtn" class="auth-btn" type="button">Cadastrar</button>
        </div>
      </div>
    </div>
  </div>

  <div id="clientBillingModal" class="modal-overlay hidden">
    <div class="modal" style="max-width: 720px;">
      <div class="modal-header">
        <div>
          <h2 class="modal-title">Pagamento</h2>
          <p class="modal-subtitle">Veja seus subusuários e o valor com desconto (quando aplicável).</p>
        </div>
        <button id="closeClientBillingModalBtn" class="modal-close" type="button">Fechar</button>
      </div>

      <div class="modal-body">
        <div id="clientBillingStatus" class="auth-help"></div>

        <div class="module-divider"></div>
        <p class="module-title" style="margin-bottom: 8px;">Subusuários cadastrados</p>
        <div id="clientFriendsList" class="simple-list"></div>

        <div class="module-divider"></div>
        <p class="module-title" style="margin-bottom: 8px;">Valores</p>
        <div id="clientBillingAmounts" class="answer-box"></div>

        <div style="margin-top: 10px; display:flex; gap:10px; flex-wrap:wrap;">
          <button id="payMonthlyBtn" class="auth-btn" type="button">Pagamento mensal</button>
          <button id="payAnnualBtn" class="auth-btn outline" type="button">Pagamento anual</button>
        </div>

        <div id="clientBillingHint" class="auth-help" style="margin-top: 10px;"></div>
      </div>
    </div>
  </div>


<div id="nurseView" class="hidden">
  <div class="page">
                <p class="site-verse">Provérbios 16:3: "Consagre ao Senhor tudo o que você faz, e os seus planos serão bem-sucedidos"</p>
    
    <div class="page-refresh">
      <div class="page-refresh-text">Se notar qualquer instabilidade, travamento ou algo fora do padrão na tela, clique em "Atualizar página" para recarregar o sistema e retomar o uso com segurança.</div>
      <button type="button" class="page-refresh-btn" onclick="window.location.reload();">Atualizar página</button>
    </div>
     <h1>Atendimento de Enfermagem</h1>


    <div class="nurse-bar" id="nurseBar">
      <div>
        <div class="nurse-bar-line"><span class="nurse-bar-label">Usuário:</span><span id="nurseUserLabel">-</span></div>
        <div class="nurse-bar-line"><span class="nurse-bar-label">Login:</span><span id="nurseLoginLabel">-</span></div>
        <div class="nurse-bar-line"><span class="nurse-bar-label">Mensalidade:</span><span id="nursePaymentLabel" class="pill">-</span></div>
      </div>
      <div class="nurse-bar-actions">
        <button id="addFriendBtn" type="button" class="auth-btn outline">Adicionar amigo</button>
        <button id="openClientBillingBtn" type="button" class="auth-btn">Pagamento</button>
        <button id="nurseLogoutBtn" type="button" class="danger-btn">Sair</button>
      </div>
    </div>


    <div class="center-card">

      <div id="consultTypePanel" class="consult-type-panel">
        <p class="consult-type-title">Guias de consulta</p>
        <div class="consult-type-buttons">
          <button class="consult-type-btn" type="button" data-consult="prenatal">Consulta pré-natal por trimestre</button>
          <button class="consult-type-btn" type="button" data-consult="puericultura">Consulta puericultura</button>
          <button class="consult-type-btn" type="button" data-consult="planejamento">Consulta planejamento familiar</button>
          <button class="consult-type-btn" type="button" data-consult="hiperdia">Consulta hiperdia</button>
          <button class="consult-type-btn" type="button" data-consult="puerperio">Consulta de puerpério</button>
        </div>

        <div id="consultGuideDrawer" class="consult-guide-drawer hidden">
          <div class="consult-guide-header">
            <div>
              <p id="consultGuideTitle" class="consult-guide-title"></p>
              <p id="consultGuideSubtitle" class="consult-guide-subtitle"></p>
            </div>
            <button id="closeConsultGuideBtn" class="consult-guide-close" type="button">Fechar</button>
          </div>

          <div id="prenatalTrimesterRow" class="trimester-row hidden">
            <button class="trimester-btn" type="button" data-tri="1">1º trimestre</button>
            <button class="trimester-btn" type="button" data-tri="2">2º trimestre</button>
            <button class="trimester-btn" type="button" data-tri="3">3º trimestre</button>
          </div>

          <div id="consultGuideContent" class="consult-guide-content"></div>
        </div>
      </div>

      <button id="recordBtn" class="start">Iniciar atendimento</button>

      <p id="startNotice">
        Assim que iniciar a gravação, informe sempre o nome completo do paciente, idade, peso e sinais vitais (PA, FC, FR, SpO2 e temperatura) para que o SOAP e a prescrição sejam gerados corretamente.
      </p>

      <div id="timer">00:00</div>
      <div id="micStatus">Clique em "Iniciar atendimento" para começar.</div>
      <div id="liveGuidance" class="live-guidance">
        <div class="live-guidance-header">
          <div class="live-guidance-title">Perguntas e procedimentos essenciais (tempo real)</div>
          <div id="liveGuidanceContext" class="live-guidance-context"></div>
        </div>
        <div id="liveGuidanceStatus" class="live-guidance-status">Inicie o atendimento para receber perguntas e procedimentos necessários em tempo real.</div>
        <div id="liveGuidanceList" class="live-guidance-list">
          <div class="live-guidance-empty">Nenhuma sugestão por enquanto.</div>
        </div>
      </div>


      <div class="controls-row">
        <button id="pauseBtn">Pausar</button>
      </div>
      <div id="pauseLabel">Use o botão pequeno para pausar e retomar a consulta.</div>

      <div id="finishHint">
        Para encerrar a consulta e gerar o SOAP, clique novamente no botão grande vermelho.
      </div>

      <div id="soapError" class="error"></div>

      <div id="soapResultsMount"></div>

      <div class="module-divider"></div>
      <p class="module-title">Triagem hospitalar</p>
      <p class="module-subtitle">
        Use este módulo para triagem na porta do hospital. Fale identificação do paciente, queixa principal, sinais vitais, achados do ABCDE, comorbidades, alergias e medicações em uso. Ao encerrar, será gerado um relatório técnico de triagem, condutas iniciais e passagem rápida ao médico.
      </p>

      <button id="triageRecordBtn" class="start" type="button">Iniciar triagem hospitalar</button>

      <div id="triageTimer">00:00</div>
      <div id="triageMicStatus">Clique em "Iniciar triagem hospitalar" para começar.</div>
      <div id="triageLiveGuidance" class="live-guidance">
        <div class="live-guidance-header">
          <div class="live-guidance-title">Perguntas e procedimentos essenciais (tempo real)</div>
          <div id="triageLiveGuidanceContext" class="live-guidance-context"></div>
        </div>
        <div id="triageLiveGuidanceStatus" class="live-guidance-status">Inicie a triagem para receber perguntas e procedimentos necessários em tempo real.</div>
        <div id="triageLiveGuidanceList" class="live-guidance-list">
          <div class="live-guidance-empty">Nenhuma sugestão por enquanto.</div>
        </div>
      </div>


      <div class="controls-row">
        <button id="triagePauseBtn" type="button">Pausar</button>
      </div>
      <div id="triagePauseLabel">Use o botão pequeno para pausar e retomar a gravação da triagem.</div>

      <div id="triageFinishHint">
        Para encerrar e gerar o relatório de triagem, clique novamente no botão grande vermelho.
      </div>

      <div id="triageError" class="error"></div>

      <div id="triageResultsMount"></div>

      <div class="module-divider"></div>

      <div class="module-divider"></div>

      <div class="section-header-row" style="justify-content: center;">
        <div class="soap-title-actions" style="justify-content: center;">
          <button id="handoffGuideBtn" class="btn-print guide-main-btn" type="button">Guia de Passagem de Plantão</button>
          <p class="module-title" style="margin: 0;">Passagem de plantão</p>
        </div>
      </div>

      <p class="module-subtitle">
        Use este módulo para registrar de forma objetiva a passagem de plantão. Fale identificação do paciente, situação atual, principais riscos, dispositivos, medicações em uso, exames pendentes e condutas/pendências para o próximo turno. Ao encerrar, será gerado um texto pronto para repassar ao colega e colar no prontuário.
      </p>

      <button id="handoffRecordBtn" class="start" type="button">Iniciar passagem de plantão</button>

      <div id="handoffTimer">00:00</div>
      <div id="handoffMicStatus">Clique em "Iniciar passagem de plantão" para começar.</div>
      <div id="handoffLiveGuidance" class="live-guidance">
        <div class="live-guidance-header">
          <div class="live-guidance-title">Sugestões essenciais SBAR (tempo real)</div>
          <div id="handoffLiveGuidanceContext" class="live-guidance-context"></div>
        </div>
        <div id="handoffLiveGuidanceStatus" class="live-guidance-status">Inicie a passagem de plantão para receber sugestões essenciais SBAR em tempo real.</div>
        <div id="handoffLiveGuidanceList" class="live-guidance-list">
          <div class="live-guidance-empty">Nenhuma sugestão por enquanto.</div>
        </div>
      </div>


      <div class="controls-row">
        <button id="handoffPauseBtn" type="button">Pausar</button>
      </div>
      <div id="handoffPauseLabel">Use o botão pequeno para pausar e retomar a gravação.</div>

      <div id="handoffFinishHint">
        Para encerrar e gerar a passagem de plantão, clique novamente no botão grande vermelho.
      </div>

      <div id="handoffError" class="error"></div>

      <div id="handoffResultsMount"></div>

      <div class="module-divider"></div>

      <div class="section-header-row" style="justify-content: center;">
        <div class="soap-title-actions" style="justify-content: center;">
          <button id="rosterHelpBtn" class="btn-print guide-main-btn" type="button">Guia Escala</button>
          <p class="module-title" style="margin: 0;">Escala de plantão</p>
        </div>
      </div>

      <p class="module-subtitle">
        Cadastre a equipe, defina regras simples e gere a escala do mês com um clique. Você pode salvar a configuração e reaproveitar no próximo mês.
      </p>

      
      <div id="rosterHelpDrawer" class="consult-guide-drawer hidden" style="margin-bottom: 10px;">
        <div class="consult-guide-header">
          <div>
            <p class="consult-guide-title">Guia completo do gerador de escala</p>
            <p class="consult-guide-subtitle">Passo a passo simples para qualquer pessoa gerar a escala com segurança</p>
          </div>
          <button id="closeRosterHelpBtn" class="consult-guide-close" type="button">Fechar</button>
        </div>

        <div class="consult-guide-content">
          <div class="consult-guide-card">
            <div class="consult-guide-card-title">Visão geral</div>
            <div class="consult-guide-card-text">
              O gerador funciona em três passos: configurar o mês e o modelo, cadastrar a equipe e gerar a escala. 
              O sistema tenta distribuir os plantões de forma equilibrada e respeitar folgas e limites mensais. 
              Se faltar gente ou se houver muitas restrições, o sistema gera avisos e pode relaxar regras para não deixar buracos.
            </div>
          </div>

          <div class="consult-guide-card">
            <div class="consult-guide-card-title">Passo 1. Escolha do mês</div>
            <div class="consult-guide-card-text">
              Selecione o mês no campo "Mês da escala". Sempre escolha o mês antes de gerar, porque as folgas por data precisam bater com o mês certo.
            </div>
          </div>

          <div class="consult-guide-card">
            <div class="consult-guide-card-title">Passo 2. Escolha do modelo</div>
            <div class="consult-guide-card-text">
              Selecione um dos modelos.
              No 12x36, você informa quantas pessoas precisa no turno 07:00–19:00 e no turno 19:00–07:00. A escala aparece como ciclos de 24 horas iniciando às 07:00 ou às 19:00, conforme a "Hora de início do ciclo".
              No 18x36 e no 24x48, você informa "Pessoas por plantão". O sistema cria uma sequência automática de plantões e rotaciona as pessoas em rodízio, respeitando o descanso.
              No modelo Manhã, Tarde e Noite, a escala é por dia e você informa quantas pessoas precisa em cada turno.
            </div>
          </div>

          <div class="consult-guide-card">
            <div class="consult-guide-card-title">Hora de início do ciclo</div>
            <div class="consult-guide-card-text">
              Use 07:00 se a sua unidade considera o dia como 07:00–07:00. Use 19:00 se a sua unidade considera o ciclo como 19:00–19:00. 
              No 12x36, isso muda como a tabela é exibida. Por exemplo, com 19:00, a linha do dia 2026-01-01 mostra o plantão 19:00–07:00 e o plantão 07:00–19:00 do dia seguinte.
              No 18x36 e 24x48, isso define o horário do primeiro plantão e alinha o rodízio.
            </div>
          </div>

          <div class="consult-guide-card">
            <div class="consult-guide-card-title">Passo 3. Quantas pessoas por plantão</div>
            <div class="consult-guide-card-text">
              Informe o número de profissionais necessários por turno na sua unidade.
              Esse número varia por unidade e por serviço (exemplo: 2, 4, 8, 10, 15). O sistema mostra automaticamente um "mínimo estimado" e um "recomendado com reserva". No 12x36, o mínimo estimado é 2 vezes (necessidade do dia + necessidade da noite). No 18x36 e 24x48, o mínimo estimado é 3 vezes (pessoas por plantão). 
              Se a equipe cadastrada estiver abaixo do mínimo, a escala pode sair com repetição de nomes e avisos.
            </div>
          </div>

          <div class="consult-guide-card">
            <div class="consult-guide-card-title">Passo 4. Cadastro da equipe</div>
            <div class="consult-guide-card-text">
              Clique em "Adicionar pessoa" para inserir um por um, ou use "Colar lista" para colar vários nomes de uma vez.
              Em "Folgas (datas)", escreva as datas no formato AAAA-MM-DD separadas por vírgula.
              Em "Máx plantões/mês", deixe em branco se não quiser limitar, ou coloque um número para evitar sobrecarga.
              Nos modelos com plantão noturno (12x36 e Manhã/Tarde/Noite), você pode marcar "Somente dia", "Somente noite" e se a pessoa "Pode noite".
            </div>
          </div>

          <div class="consult-guide-card">
            <div class="consult-guide-card-title">Passo 5. Gerar e revisar</div>
            <div class="consult-guide-card-text">
              Clique em "Gerar escala". 
              Revise a tabela e a "Distribuição por pessoa" (resumo no final) para verificar se a carga ficou equilibrada.
              Se houver avisos, eles aparecem em destaque. Em geral, os avisos indicam falta de profissionais, folgas em excesso no mesmo período, limite mensal muito baixo ou muitas pessoas sem possibilidade de noite.
            </div>
          </div>

          <div class="consult-guide-card">
            <div class="consult-guide-card-title">Passo 6. Salvar, baixar e imprimir</div>
            <div class="consult-guide-card-text">
              "Salvar configuração" guarda seus parâmetros e equipe para reutilizar. "Carregar configuração" recupera.
              Depois de gerar, você pode "Salvar escala gerada" no servidor, "Baixar CSV" para abrir no Excel, e "Imprimir" para assinar e fixar na unidade.
            </div>
          </div>

          <div class="consult-guide-card">
            <div class="consult-guide-card-title">Como evitar avisos e gerar uma escala mais perfeita</div>
            <div class="consult-guide-card-text">
              Confira se as folgas foram digitadas no formato correto e se realmente pertencem ao mês escolhido.
              Em 12x36, se você precisa de muitas pessoas à noite, cadastre gente suficiente com "Pode noite" e evite marcar muitos como "Somente dia".
              Se você colocou "Máx plantões/mês" muito baixo para vários profissionais, a escala fica impossível de fechar sem repetição.
              Se a unidade trabalha com equipes fixas (ex.: equipe A e equipe B), você pode cadastrar os nomes na ordem desejada e usar o rodízio automático como base, ajustando manualmente no CSV se necessário.
            </div>
          </div>
        </div>
      </div>


      
      <div class="roster-shell" id="rosterToggleShell">
        <div class="roster-actions" style="margin-top:0;">
          <button id="rosterToggleBtn" type="button">Gerar escala de plantão</button>
        </div>
      </div>

<div class="roster-shell" id="rosterShell" style="display:none;">
        <div class="roster-step-title">Passo 1: Configuração do mês</div>

        <div class="roster-grid">
          <div class="roster-field">
            <label for="rosterMonth">Mês da escala</label>
            <input id="rosterMonth" type="month" />
          </div>

          <div class="roster-field">
            <label for="rosterShiftModel">Modelo de escala</label>
            <select id="rosterShiftModel">
              <option value="12x36">12x36 (12h de trabalho, 36h de descanso)</option>
              <option value="18x36">18x36 (18h de trabalho, 36h de descanso)</option>
              <option value="24x48">24x48 (24h de trabalho, 48h de descanso)</option>
              <option value="mtn">Manhã, Tarde e Noite</option>
            </select>
          </div>

          <div class="roster-field">
            <label for="rosterStartTime">Hora de início do ciclo</label>
            <select id="rosterStartTime">
              <option value="07:00">07:00</option>
              <option value="19:00">19:00</option>
            </select>
          </div>

          <div class="roster-field" id="rosterNeedPerShiftWrap">
            <label for="rosterNeedPerShift">Pessoas por plantão</label>
            <input id="rosterNeedPerShift" type="number" min="1" max="50" value="1" />
          </div>

          <div class="roster-field" id="rosterNeedDayWrap">
            <label for="rosterNeedDay">Pessoas 07:00–19:00</label>
            <input id="rosterNeedDay" type="number" min="1" max="50" value="1" />
          </div>

          <div class="roster-field" id="rosterNeedNightWrap">
            <label for="rosterNeedNight">Pessoas 19:00–07:00</label>
            <input id="rosterNeedNight" type="number" min="1" max="50" value="1" />
          </div>

          <div class="roster-field" id="rosterNeedAfternoonWrap">
            <label for="rosterNeedAfternoon">Pessoas por turno (Tarde)</label>
            <input id="rosterNeedAfternoon" type="number" min="0" max="50" value="1" />
          </div>

          <div class="roster-field" id="rosterMaxConsecNightsWrap">
            <label for="rosterMaxConsecNights">Máximo de noites consecutivas</label>
            <input id="rosterMaxConsecNights" type="number" min="1" max="14" value="2" />
          </div>
        </div>

        <div id="rosterCoverageBox" class="roster-coverage-box"></div>

        <div class="roster-note" id="rosterModelNote">
          No modelo 12x36, a saída é exibida como ciclo de 24 horas. Se você escolher início 19:00, cada linha da escala mostra o plantão 19:00–07:00 e o plantão 07:00–19:00 do dia seguinte.
        </div>

        <div class="module-divider"></div>

        <div class="roster-step-title">Passo 2: Equipe</div>

        <div class="roster-actions">
          <button id="rosterAddPersonBtn" type="button">Adicionar pessoa</button>
          <button id="rosterBulkAddBtn" class="secondary" type="button">Colar lista</button>
          <button id="rosterSaveConfigBtn" class="secondary" type="button">Salvar configuração</button>
          <button id="rosterLoadConfigBtn" class="secondary" type="button">Carregar configuração</button>
        </div>

        <div class="roster-note">
          Folgas por data: use AAAA-MM-DD separadas por vírgula (ex.: 2026-01-05, 2026-01-20). Se o campo "Máx plantões/mês" ficar em branco, não limita.
        </div>

        <div id="rosterTeamCards" class="roster-team-cards"></div>

        <div class="roster-table-wrap roster-desktop-only">
          <table class="roster-table">
            <thead>
              <tr>
                <th style="min-width: 220px;">Nome</th>
                <th style="min-width: 170px;">Preferência</th>
                <th style="min-width: 120px;">Pode noite</th>
                <th style="min-width: 260px;">Folgas (datas)</th>
                <th style="min-width: 160px;">Máx plantões/mês</th>
                <th style="min-width: 120px;">Remover</th>
              </tr>
            </thead>
            <tbody id="rosterTeamTbody"></tbody>
          </table>
        </div>

        <div class="module-divider"></div>

        <div class="roster-step-title">Passo 3: Gerar, revisar e exportar</div>

        <div class="roster-actions">
          <button id="rosterGenerateBtn" type="button">Gerar escala</button>
          <button id="rosterSaveScheduleBtn" class="secondary" type="button" disabled>Salvar escala gerada</button>
          <button id="rosterExportCsvBtn" class="secondary" type="button" disabled>Baixar CSV</button>
          <button id="rosterPrintBtn" class="secondary" type="button" disabled>Imprimir</button>
        </div>

        <div id="rosterWarnBox" class="roster-warn hidden"></div>

        <div id="rosterOutput" class="roster-output hidden">
          <div class="roster-table-wrap roster-desktop-only">
            <table id="rosterTableOut" class="roster-table"></table>
          </div>

          <div id="rosterOutputMobile" class="roster-output-mobile"></div>

          <div style="height: 12px;"></div>

          <div class="roster-table-wrap roster-desktop-only">
            <table id="rosterSummaryOut" class="roster-table"></table>
          </div>
        </div>
      </div>


    </div>

    <div id="resultsCard" class="results-card hidden">

      <div id="patientInfoPanel" class="patientinfo-panel">
        <p class="mini-status patientinfo-hint" style="margin: 0 0 8px 0;">Use este botão para gravar rapidamente nome completo, idade e peso do paciente. Esses dados melhoram a qualidade do SOAP e das condutas geradas.</p>
        <div class="patientinfo-row">
          <button id="patientInfoBtn" class="small-record-btn">Coletar dados essenciais</button>
          <div id="patientInfoTimer" class="mini-timer">00:00</div>
          <div id="patientInfoStatus" class="mini-status"></div>
        </div>
        <div id="patientInfoSummary" class="patient-summary"></div>
      </div>



      <div id="triageReportPanel" class="triage-report-panel hidden">
        <div class="section-header-row">
          <div class="soap-title-actions">
            <h2>Triagem hospitalar</h2>
          </div>
        </div>

        <h3 style="margin: 8px 0 10px 0;">Classificação de risco por cores</h3>

        <div class="risk-triage-box" style="margin-bottom: 12px;">
          <div class="risk-triage-current">
            <span id="triageRiskBadge" class="risk-badge risk-none">Não informado</span>
            <div id="triageRiskMeaning" class="risk-meaning">Nenhum conteúdo disponível.</div>
          </div>
        </div>

        <div class="triage-report-grid">
          <div>
            <h3>Texto para prontuário</h3>
            <textarea id="triageProntuario" class="prescription-textarea"></textarea>
            <div class="prescription-actions">
              <button id="triageCopyProntuarioBtn" class="btn-copy" type="button">Copiar prontuário</button>
              <button id="triagePrintProntuarioBtn" class="btn-print" type="button">Imprimir prontuário</button>
            </div>
          </div>

          <div>
            <h3>Passagem rápida ao médico</h3>
            <textarea id="triagePassagemMedico" class="prescription-textarea"></textarea>
            <div class="prescription-actions">
              <button id="triageCopyPassagemBtn" class="btn-copy" type="button">Copiar passagem</button>
              <button id="triagePrintPassagemBtn" class="btn-print" type="button">Imprimir passagem</button>
            </div>
          </div>

          <div>
            <h3>Alertas e sinais de gravidade</h3>
            <textarea id="triageAlertas" class="prescription-textarea"></textarea>
          </div>

          <div>
            <h3>Tratamento não medicamentoso e cuidados</h3>
            <textarea id="triageCondutasNaoMed" class="prescription-textarea"></textarea>
          </div>

          <div>
            <h3>Tratamento medicamentoso sugerido (se aplicável)</h3>
            <textarea id="triageCondutasMed" class="prescription-textarea"></textarea>
          </div>

          <div>
            <h3>Medidas e exames imediatos sugeridos</h3>
            <textarea id="triageMedidasExames" class="prescription-textarea"></textarea>
          </div>

          <div>
            <h3>Pendências a checar antes de liberar ou encaminhar</h3>
            <textarea id="triagePendencias" class="prescription-textarea"></textarea>
          </div>

          <div>
            <h3>Checagem de qualidade (o que está faltando na triagem)</h3>
            <textarea id="triageQualidade" class="prescription-textarea"></textarea>
          </div>

        </div>

        <div id="triageReportStatus" class="mini-status"></div>
      </div>
      <div id="handoffPanel" class="triage-report-panel hidden">
        <div class="section-header-row">
          <div class="soap-title-actions">
            <h2>Passagem de plantão</h2>
            <button id="handoffCopyBtn" class="btn-copy" type="button">Copiar passagem</button>
            <button id="handoffPrintBtn" class="btn-print" type="button">Imprimir passagem</button>
          </div>
        </div>

        <textarea id="handoffOutput" class="prescription-textarea" placeholder="A passagem de plantão gerada aparecerá aqui."></textarea>
        <div id="handoffStatus" class="mini-status"></div>
      </div>


      <div id="soapNursingResultsPanel">

      <div class="section-header-row">
        <div class="soap-title-actions">
          <h2>SOAP</h2>
        </div>
        <button id="recommendationsBtn">Perguntas essenciais</button>
      </div>

      <div class="prescription-actions" style="justify-content: flex-start; gap: 10px; margin-top: 8px;">
        <button id="copyFullSoapBtn" class="btn-copy" type="button">Copiar SOAP</button>
        <button id="printSoapBtn" class="btn-print" type="button">Imprimir SOAP</button>
      </div>

      <div class="soap-block">
        <div class="soap-block-header">
          <span class="soap-label">S</span>
          <button class="copy-soap-btn" data-part="S">Copiar</button>
        </div>
        <textarea id="soapS" class="soap-textarea"></textarea>
      </div>

      <div class="soap-block">
        <div class="soap-block-header">
          <span class="soap-label">O</span>
          <button class="copy-soap-btn" data-part="O">Copiar</button>
        </div>
        <textarea id="soapO" class="soap-textarea"></textarea>
      </div>

      <div class="soap-block">
        <div class="soap-block-header">
          <span class="soap-label">A</span>
          <button class="copy-soap-btn" data-part="A">Copiar</button>
        </div>
        <textarea id="soapA" class="soap-textarea"></textarea>
      </div>

      <div class="soap-block">
        <div class="soap-block-header">
          <span class="soap-label">P</span>
          <button class="copy-soap-btn" data-part="P">Copiar</button>
        </div>
        <textarea id="soapP" class="soap-textarea"></textarea>
      </div>

      <h2>Evolução de Enfermagem</h2>
      <textarea id="nursingEvolutionOutput" class="prescription-textarea"></textarea>

      <div class="prescription-actions">
        <button id="copyNursingEvolutionBtn" class="btn-copy" type="button">Copiar evolução de enfermagem</button>
        <button id="printNursingEvolutionBtn" class="btn-print" type="button">Imprimir evolução de enfermagem</button>
      </div>

      <h2>Plano de Cuidados (Prescrição de Enfermagem)</h2>
      <textarea id="prescriptionOutput" class="prescription-textarea"></textarea>

      <div class="prescription-actions">
        <button id="copyPrescriptionBtn" class="btn-copy">Copiar plano de cuidados</button>
        <button id="printBtn" class="btn-print">Imprimir plano de cuidados</button>
      </div>
<h2>Classificação de risco por cores</h2>
      <div class="risk-triage-box">
        <div class="risk-triage-current">
          <span id="riskTriageBadge" class="risk-badge risk-none">Não informado</span>
          <div id="riskTriageMeaning" class="risk-meaning">Nenhum conteúdo disponível.</div>
        </div>
        <div id="riskTriageLegend" class="risk-legend"></div>
      </div>
      <div class="prescription-actions">
        <button id="copyRiskTriageBtn" class="btn-copy">Copiar classificação de risco</button>
        <button id="printRiskTriageBtn" class="btn-print">Imprimir classificação de risco</button>
      </div>
      <div id="riskTriageStatus" class="mini-status"></div>

      <h2>SAE (Processo de Enfermagem)</h2>
      <div id="pregnancyBox" class="classification-box">Nenhum conteúdo disponível.</div>
      <div class="prescription-actions">
        <button id="copySaeBtn" class="btn-copy">Copiar SAE</button>
        <button id="printPregnancyBtn" class="btn-print">Imprimir SAE</button>
      </div>

      <h2>Orientações ao paciente</h2>
      <div id="lactationBox" class="classification-box">Nenhum conteúdo disponível.</div>
      <div class="prescription-actions">
        <button id="copyOrientationsBtn" class="btn-copy">Copiar orientações</button>
        <button id="printLactationBtn" class="btn-print">Imprimir orientações</button>
      </div>
<div id="classificationsStatus" class="mini-status"></div>
      </div>
    </div>

    
    <div id="aprazamentoCard" class="module-card">
      <div class="section-header-row">
        <h2>Aprazamento de prescrição</h2>
        <button id="aprazamentoGuideBtn" class="btn-print guide-main-btn" type="button">Guia</button>
      </div>

      <p class="mini-status" style="margin-top: 0;">
              Tire uma foto ou selecione um arquivo da folha de prescrição. O sistema irá transcrever somente o que estiver legível e gerar apenas a grade de horários de 24 horas, já preenchida conforme a frequência/horários descritos na prescrição. O resultado é editável e pode ser impresso para uso no prontuário.
      
      </p>

      <div class="prescription-actions">
        <label for="aprazamentoCameraInput" class="photo-btn">Tirar foto</label>
        <label for="aprazamentoFileInput" class="photo-btn">Escolher arquivo</label>
      </div>

      <div id="aprazamentoStatus" class="mini-status"></div>
      <div id="aprazamentoSheetWrapper" class="rx-sheet-wrapper">
        <div class="rx-sheet-placeholder">Nenhum conteúdo disponível.</div>
      </div>


      <div class="prescription-actions" style="justify-content: flex-start; gap: 10px; margin-top: 10px;">
        <button id="printAprazGridBtn" class="btn-print hidden" type="button">Imprimir grade de horários</button>
      </div>

      <details id="aprazOriginalDetails" class="rx-details hidden">
        <summary>Imagem original (para conferência)</summary>
        <div id="aprazOriginalImages" class="rx-original-grid"></div>
      </details>

      <input id="aprazamentoCameraInput" class="hidden-input" type="file" accept="image/*" capture="environment" />
      <input id="aprazamentoFileInput" class="hidden-input" type="file" accept="image/*" multiple />
    </div>

    <div id="woundCard" class="module-card">
      <div class="section-header-row">
      <h2>Curativos e feridas</h2>
      <button id="woundGuideBtn" class="btn-print guide-main-btn" type="button">Guia</button>
    </div>
      <p class="mini-status" style="margin-top: 0;">
        Use o botão para fotografar a lesão. O sistema irá descrever a ferida em linguagem técnica, apenas com base no que estiver visível, e sugerir condutas locais, cuidados não medicamentosos e, quando aplicável, opções de tratamento medicamentoso, além de sinais de alarme e critérios de encaminhamento, sem inventar dados.
      </p>

      <div class="prescription-actions">
        <label for="woundCameraInput" class="photo-btn">Tirar foto</label>
        <label for="woundFileInput" class="photo-btn">Escolher arquivo</label>
        <button id="copyWoundBtn" class="btn-copy hidden">Copiar descrição e conduta</button>
        <button id="printWoundBtn" class="btn-print hidden">Imprimir descrição e conduta</button>
      </div>

      <div id="presentationsMaxDoseStatus" class="mini-status"></div>
      <div id="presentationsMaxDoseBox" class="classification-box">Nenhum conteúdo disponível.</div>

      <input id="woundCameraInput" class="hidden-input" type="file" accept="image/*" capture="environment" />
      <input id="woundFileInput" class="hidden-input" type="file" accept="image/*" multiple />
    </div>


    <div id="examInterpretationCard" class="module-card">
      <div class="section-header-row">
      <h2>Interpretação de resultados de exames</h2>
      <button id="examGuideBtn" class="btn-print guide-main-btn" type="button">Guia</button>
    </div>
      <p class="mini-status" style="margin-top: 0;">
        Use os botões para fotografar o resultado do exame (ex.: laudo, tabela de laboratório, impressão do sistema). O sistema irá transcrever somente o que estiver legível, organizar achados relevantes e oferecer uma interpretação clínica didática, com hipóteses possíveis, limitações, próximos passos e sinais de alarme, sem inventar dados.
      </p>

      <div class="prescription-actions">
        <label for="examCameraInput" class="photo-btn">Tirar foto</label>
        <label for="examFileInput" class="photo-btn">Escolher arquivo</label>
        <button id="copyExamBtn" class="btn-copy hidden">Copiar análise</button>
        <button id="printExamBtn" class="btn-print hidden">Imprimir análise</button>
      </div>

      <div id="examInterpretationStatus" class="mini-status"></div>
      <div id="examInterpretationBox" class="classification-box">Nenhum conteúdo disponível.</div>

      <input id="examCameraInput" class="hidden-input" type="file" accept="image/*" capture="environment" />
      <input id="examFileInput" class="hidden-input" type="file" accept="image/*" multiple />
    
</div>

    <div id="docTranscriptionCard" class="module-card">
      <div class="section-header-row">
        <h2>Transcrição de documentos</h2>
        <button id="transcriptionGuideBtn" class="btn-print guide-main-btn" type="button">Guia</button>
      </div>

      <p class="mini-status" style="margin-top: 0;">
        Use os botões para fotografar ou enviar um arquivo da galeria (documento, prescrição, formulário, etc). O sistema irá transcrever somente o que estiver legível e organizar o conteúdo para facilitar a leitura, sem interpretar e sem inventar dados.
      </p>

      <div class="prescription-actions">
        <label for="transcriptionCameraInput" class="photo-btn">Tirar foto</label>
        <label for="transcriptionFileInput" class="photo-btn">Escolher arquivo</label>
        <button id="copyTranscriptionBtn" class="btn-copy hidden">Copiar transcrição</button>
        <button id="printTranscriptionBtn" class="btn-print hidden">Imprimir transcrição</button>
      </div>

      <div id="transcriptionStatus" class="mini-status"></div>
      <div id="transcriptionBox" class="classification-box">Nenhum conteúdo disponível.</div>

      <input id="transcriptionCameraInput" class="hidden-input" type="file" accept="image/*" capture="environment" />
      <input id="transcriptionFileInput" class="hidden-input" type="file" accept="image/*" multiple />
    </div>

    <div id="transcriptionGuidePanel" class="recommendations-panel">
      <div class="recommendations-header">
        <h3>Guia de Transcrição de documentos</h3>
        <button id="closeTranscriptionGuideBtn" class="close-panel-btn" aria-label="Fechar guia de transcrição de documentos">X</button>
      </div>

      <div class="recommendations-status">
        Este módulo transcreve e organiza documentos e prescrições a partir de foto/arquivo, sem interpretação clínica.
      </div>

      <div class="recommendations-list">
        <div class="recommendation-item"><strong>1) Envio</strong> Tire uma foto nítida ou selecione um arquivo da galeria. Se houver mais de uma página, envie as páginas mais importantes.</div>
        <div class="recommendation-item"><strong>2) Transcrição fiel</strong> O sistema transcreve somente o que estiver legível. Trechos duvidosos ou ilegíveis serão marcados como "não informado".</div>
        <div class="recommendation-item"><strong>3) Organização</strong> O conteúdo é organizado por seções (tipo de documento, identificação, corpo do texto e assinaturas/carimbo quando existirem). Em prescrições, os itens são listados em linhas separadas para facilitar conferência.</div>
        <div class="recommendation-item"><strong>4) Sem invenção</strong> Nenhum dado é criado. Se um campo não aparecer no documento, ele será mantido como "não informado" ou ficará em branco quando apropriado.</div>
        <div class="recommendation-item"><strong>5) Conferência</strong> Sempre confirme a transcrição com a imagem original antes de registrar ou executar qualquer conduta.</div>
      </div>
    </div>


    <div id="rxEvalCard" class="module-card">
      <div class="section-header-row">
        <h2>Avaliar receita</h2>
        <button id="rxEvalGuideBtn" class="btn-print guide-main-btn" type="button">Guia</button>
      </div>

      <p class="mini-status" style="margin-top: 0;">
        Tire uma foto da receita ou selecione um arquivo. O sistema transcreve somente o que estiver legível e identifica os medicamentos citados para gerar bulas e informações clínicas organizadas.
      </p>

      <div class="prescription-actions">
        <label for="rxEvalCameraInput" class="photo-btn">Tirar foto</label>
        <label for="rxEvalFileInput" class="photo-btn">Escolher arquivo</label>
        <button id="rxEvalCopyTranscriptionBtn" class="btn-copy hidden" type="button">Copiar transcrição</button>
        <button id="rxEvalPrintTranscriptionBtn" class="btn-print hidden" type="button">Imprimir transcrição</button>
      </div>

      <div id="rxEvalStatus" class="mini-status"></div>

      <div id="rxEvalResults" class="hidden">
<div class="rx-topic">Transcrição da receita (editável)</div>
      <textarea id="rxEvalTranscription" class="rx-editable" placeholder="A transcrição aparecerá aqui. Você pode editar antes de copiar ou imprimir."></textarea>

      <div class="prescription-actions" style="margin-top: 10px;">
        <button id="rxEvalCopyDetailsBtn" class="btn-copy hidden" type="button">Copiar informações do medicamento</button>
        <button id="rxEvalPrintDetailsBtn" class="btn-print hidden" type="button">Imprimir informações do medicamento</button>
      </div>

      <div class="rx-topic" style="margin-top: 18px;">Bula dos medicamentos</div>
      <p id="rxEvalMedsCount" class="mini-status" style="margin-top: 0;">Nenhum medicamento identificado.</p>
      <div id="rxEvalMedsButtons" class="rx-pill-wrap"></div>

      <div id="rxEvalDetails" class="classification-box rx-details">Selecione um medicamento acima para ver as informações.</div>

      </div>
<input id="rxEvalCameraInput" class="hidden-input" type="file" accept="image/*" capture="environment" />
      <input id="rxEvalFileInput" class="hidden-input" type="file" accept="image/*" multiple />
    </div>

    <div id="rxEvalGuidePanel" class="recommendations-panel">
      <div class="recommendations-header">
        <h3>Guia de Avaliar receita</h3>
        <button id="closeRxEvalGuideBtn" class="close-panel-btn" aria-label="Fechar guia de avaliar receita">X</button>
      </div>

      <div class="recommendations-status">
        Este módulo ajuda a transcrever receitas e a organizar informações de bula. Não substitui a revisão e assinatura do médico responsável.
      </div>

      <div class="recommendations-list">
        <div class="recommendation-item"><strong>1) Qualidade da imagem</strong> Use boa iluminação, foco e enquadre toda a prescrição. Evite sombras e reflexos.</div>
        <div class="recommendation-item"><strong>2) Receita legível</strong> Pela Lei nº 5.991/1973 (art. 35), a dispensação em farmácias depende de receita escrita por extenso e de modo legível. Sempre que possível, forneça prescrição legível e preferencialmente impressa.</div>
        <div class="recommendation-item"><strong>3) Limitações e responsabilidade</strong> Em receitas manuscritas ou ilegíveis, pode haver erro na identificação do nome do medicamento. Este recurso não se responsabiliza por identificações incorretas; confirme sempre com a prescrição original e com fontes oficiais.</div>
        <div class="recommendation-item"><strong>4) Fontes recomendadas</strong> Para conferência, utilize o Bulário Eletrônico da Anvisa e, quando necessário, bulas públicas de referência. O conteúdo gerado deve ser validado pelo profissional.</div>
      </div>
    </div>

<div id="medicalDoubtsCard" class="module-card">
      <div class="section-header-row">
      <h2>Dúvidas em Saúde</h2>
      <button id="medicalDoubtsGuideBtn" class="btn-print guide-main-btn" type="button">Guia</button>
    </div>
      <p class="mini-status" style="margin-top: 0;">Faça qualquer pergunta sobre saúde. Pressione Enter ou clique em Enviar.</p><div class="inline-input-row" style="gap: 10px; align-items: stretch;">
  <input id="medicalDoubtInput" class="text-input" type="text" placeholder="Digite sua dúvida sobre saúde e pressione Enter" autocomplete="off" style="flex: 1 1 auto; margin: 0;" />
  <button id="medicalDoubtSendBtn" class="btn-print" type="button" style="white-space: nowrap;">Enviar</button>
</div>
      <div id="medicalDoubtStatus" class="mini-status"></div>
      <div id="medicalDoubtAnswer" class="answer-box"></div>
    </div>


                


<div id="healthEducationCard" class="module-card">
      <div class="section-header-row">
        <h2>Educação em Saúde</h2>
      </div>

      <p class="mini-status" style="margin-top: 0;">
        Informe o tema e a duração. O sistema irá gerar uma apresentação PPTX completa com imagens e GIFs (quando disponíveis), pronta para educação em saúde.
      </p>

      <div class="inline-input-row" style="gap: 10px; align-items: stretch;">
        <input id="healthEduTheme" class="text-input" type="text" placeholder="Tema (ex.: Hipertensão arterial na APS)" autocomplete="off" style="flex: 1 1 auto; margin: 0;" />
        <select id="healthEduDuration" class="text-input" style="max-width: 140px;">
          <option value="10">10 min</option>
          <option value="15">15 min</option>
          <option value="20">20 min</option>
          <option value="25">25 min</option>
          <option value="30">30 min</option>
          <option value="35">35 min</option>
          <option value="40">40 min</option>
          <option value="45">45 min</option>
          <option value="50">50 min</option>
          <option value="55">55 min</option>
          <option value="60">60 min</option>
        </select>
        <button id="healthEduDownloadBtn" class="btn-print" type="button" style="white-space: nowrap;">Baixar apresentação (PPTX)</button>
      </div>

      <div id="healthEduStatus" class="mini-status"></div>
    </div>


<div id="calculatorsCard" class="module-card">
      <div class="section-header-row">
      <h2>Calculadoras Clínicas</h2>
      <button id="calculatorsGuideBtn" class="btn-print guide-main-btn" type="button">Guia</button>
    </div>
      <p class="mini-status" style="margin-top: 0;">
        Selecione a calculadora, preencha os campos e veja o resultado.
      </p>

      <div class="inline-input-row">
        <select id="calcSelect" class="text-input" style="min-width: 280px;">
          <option value="imc">IMC</option>
          <option value="cv_risk">Estratificação de Risco Cardiovascular</option>
          <option value="bsa">SC (Mosteller)</option>
          <option value="gest_age">Idade gestacional</option>
          <option value="drip_pump">Gotejamento e bomba de infusão</option>
          <option value="fluid_balance">Balanço hídrico</option>
          <option value="weight_dose">Dose por peso</option>
          <option value="glasgow">Glasgow (ECG)</option>
          <option value="sedation">Ramsay / RASS</option>
          <option value="pain">Escala de dor (0 a 10)</option>
          <option value="morse">Risco de quedas (Morse)</option>
          <option value="braden">Braden (LPP)</option>
          <option value="pews">PEWS (pediatria)</option>
        </select>
      </div>

      <div id="calcPanel_imc" class="calc-panel">
        <div class="calc-title">IMC</div>
        <p class="calc-help">Como funciona: IMC = peso (kg) / altura² (m²). Informe peso (kg) e altura (cm).</p>
        <div class="calc-row">
          <input id="imcWeightKg" class="text-input" type="number" step="0.1" min="0" placeholder="Peso (kg)" />
          <input id="imcHeightCm" class="text-input" type="number" step="0.1" min="0" placeholder="Altura (cm)" />
        </div>
        <div id="imcResult" class="answer-box"></div>
      </div>

      
      <div id="calcPanel_cv_risk" class="calc-panel hidden">
        <div class="calc-title">Estratificação de Risco Cardiovascular (PREVENT)</div>
        <p class="calc-help">
          Como funciona: estima risco de eventos cardiovasculares em 10 anos (e, quando aplicável, em 30 anos) a partir de fatores clínicos e laboratoriais.
          Informe idade, sexo, pressão arterial sistólica, colesterol total e HDL, peso e altura, creatinina, tabagismo, diabetes e se usa anti-hipertensivo ou estatina.
        </p>

        <div class="calc-row" style="margin-top: 10px;">
          <input id="cvAge" class="text-input" type="number" step="1" min="0" placeholder="Idade (anos)" />
          <select id="cvSex" class="text-input">
            <option value="female">Sexo: feminino</option>
            <option value="male">Sexo: masculino</option>
          </select>
        </div>

        <div class="calc-row">
          <input id="cvWeightKg" class="text-input" type="number" step="0.1" min="0" placeholder="Peso (kg)" />
          <input id="cvHeightCm" class="text-input" type="number" step="0.1" min="0" placeholder="Altura (cm)" />
        </div>

        <div class="calc-row">
          <input id="cvSbp" class="text-input" type="number" step="1" min="0" placeholder="PAS (mmHg)" />
          <input id="cvCreatinine" class="text-input" type="number" step="0.01" min="0" placeholder="Creatinina (mg/dL)" />
        </div>

        <div class="calc-row">
          <input id="cvTotalChol" class="text-input" type="number" step="1" min="0" placeholder="Colesterol total (mg/dL)" />
          <input id="cvHdl" class="text-input" type="number" step="1" min="0" placeholder="HDL (mg/dL)" />
        </div>

        <div class="calc-row">
          <select id="cvSmoker" class="text-input">
            <option value="0">Tabagismo: não</option>
            <option value="1">Tabagismo: sim</option>
          </select>
          <select id="cvDiabetes" class="text-input">
            <option value="0">Diabetes: não</option>
            <option value="1">Diabetes: sim</option>
          </select>
        </div>

        <div class="calc-row">
          <select id="cvOnHtnMeds" class="text-input">
            <option value="0">Em uso de anti-hipertensivo: não</option>
            <option value="1">Em uso de anti-hipertensivo: sim</option>
          </select>
          <select id="cvOnStatin" class="text-input">
            <option value="0">Em uso de estatina/hipolipemiante: não</option>
            <option value="1">Em uso de estatina/hipolipemiante: sim</option>
          </select>
        </div>

        <div id="cvRiskResult" class="answer-box"></div>
      </div>

      <div id="calcPanel_bsa"
 class="calc-panel hidden">
        <div class="calc-title">SC (Mosteller)</div>
        <p class="calc-help">Como funciona: SC (Mosteller) = raiz quadrada de (altura(cm) x peso(kg) / 3600). Informe peso (kg) e altura (cm).</p>
        <div class="calc-row">
          <input id="bsaWeightKg" class="text-input" type="number" step="0.1" min="0" placeholder="Peso (kg)" />
          <input id="bsaHeightCm" class="text-input" type="number" step="0.1" min="0" placeholder="Altura (cm)" />
        </div>
        <div id="bsaResult" class="answer-box"></div>
      </div>

      <div id="calcPanel_gest_age" class="calc-panel hidden">
        <div class="calc-title">Idade gestacional</div>
        <p class="calc-help">Como funciona: calcula idade gestacional a partir da DUM e estima a DPP (DUM + 280 dias). Informe a data da DUM.</p>
        <div class="calc-row">
          <label style="font-size: 13px; color: #333; font-weight: 700;">DUM</label>
          <input id="gestDum" class="text-input" type="date" />
        </div>
        <div id="gestResult" class="answer-box"></div>
      </div>

      <div id="calcPanel_drip_pump" class="calc-panel hidden">
        <div class="calc-title">Gotejamento e bomba de infusão</div>
        <p class="calc-help">Informe volume e tempo. O sistema calcula mL/h (bomba) e gotas/min (gotejamento) conforme o fator de gotejamento.</p>
        <div class="calc-row">
          <input id="dripVolumeMl" class="text-input" type="number" step="0.1" min="0" placeholder="Volume (mL)" />
          <input id="dripTimeH" class="text-input" type="number" step="1" min="0" placeholder="Tempo (h)" />
          <input id="dripTimeMin" class="text-input" type="number" step="1" min="0" placeholder="Tempo (min)" />
          <select id="dripFactor" class="text-input">
            <option value="20">Macro 20 gotas/mL</option>
            <option value="60">Micro 60 gotas/mL</option>
            <option value="10">10 gotas/mL</option>
            <option value="15">15 gotas/mL</option>
          </select>
        </div>
        <div id="dripResult" class="answer-box"></div>
      </div>

      <div id="calcPanel_fluid_balance" class="calc-panel hidden">
        <div class="calc-title">Balanço hídrico</div>
        <p class="calc-help">Preencha entradas e saídas (mL). Opcionalmente, informe peso e tempo para estimar diurese (mL/kg/h).</p>
        <div class="calc-row">
          <input id="fbInputMl" class="text-input" type="number" step="1" min="0" placeholder="Entradas (mL)" />
          <input id="fbOutputMl" class="text-input" type="number" step="1" min="0" placeholder="Saídas (mL)" />
          <input id="fbWeightKg" class="text-input" type="number" step="0.1" min="0" placeholder="Peso (kg, opcional)" />
          <input id="fbHours" class="text-input" type="number" step="0.1" min="0" placeholder="Tempo (h, opcional)" />
        </div>
        <div id="fbResult" class="answer-box"></div>
      </div>

      <div id="calcPanel_weight_dose" class="calc-panel hidden">
        <div class="calc-title">Dose por peso</div>
        <p class="calc-help">Calcula a dose por tomada (mg) a partir de mg/kg. Se houver concentração (mg/mL), calcula volume (mL).</p>
        <div class="calc-row">
          <input id="wdWeightKg" class="text-input" type="number" step="0.1" min="0" placeholder="Peso (kg)" />
          <input id="wdDoseMgKg" class="text-input" type="number" step="0.01" min="0" placeholder="Dose (mg/kg)" />
          <input id="wdMaxDoseMg" class="text-input" type="number" step="0.1" min="0" placeholder="Dose máx (mg, opcional)" />
          <input id="wdConcMgMl" class="text-input" type="number" step="0.01" min="0" placeholder="Concentração (mg/mL, opcional)" />
        </div>
        <div id="wdResult" class="answer-box"></div>
      </div>

      <div id="calcPanel_glasgow" class="calc-panel hidden">
        <div class="calc-title">Escala de Coma de Glasgow (ECG)</div>
        <p class="calc-help">Selecione os componentes. Total varia de 3 a 15.</p>

        <div class="calc-row">
          <select id="gcsEye" class="text-input">
            <option value="4">Abertura ocular: espontânea (4)</option>
            <option value="3">Abertura ocular: ao som (3)</option>
            <option value="2">Abertura ocular: à dor (2)</option>
            <option value="1">Abertura ocular: nenhuma (1)</option>
          </select>

          <select id="gcsVerbal" class="text-input">
            <option value="5">Resposta verbal: orientado (5)</option>
            <option value="4">Resposta verbal: confuso (4)</option>
            <option value="3">Resposta verbal: palavras inapropriadas (3)</option>
            <option value="2">Resposta verbal: sons incompreensíveis (2)</option>
            <option value="1">Resposta verbal: nenhuma (1)</option>
          </select>

          <select id="gcsMotor" class="text-input">
            <option value="6">Resposta motora: obedece comandos (6)</option>
            <option value="5">Resposta motora: localiza dor (5)</option>
            <option value="4">Resposta motora: retira à dor (4)</option>
            <option value="3">Resposta motora: flexão anormal (3)</option>
            <option value="2">Resposta motora: extensão (2)</option>
            <option value="1">Resposta motora: nenhuma (1)</option>
          </select>
        </div>

        <div id="gcsResult" class="answer-box"></div>
      </div>

      <div id="calcPanel_sedation" class="calc-panel hidden">
        <div class="calc-title">Ramsay / RASS</div>
        <p class="calc-help">Selecione a pontuação e veja a interpretação resumida.</p>

        <div class="calc-row">
          <select id="ramsay" class="text-input">
            <option value="1">Ramsay 1: ansioso/agitado</option>
            <option value="2">Ramsay 2: cooperativo/orientado/tranquilo</option>
            <option value="3">Ramsay 3: responde a comandos</option>
            <option value="4">Ramsay 4: resposta rápida a estímulo (tátil/sonoro)</option>
            <option value="5">Ramsay 5: resposta lenta a estímulo</option>
            <option value="6">Ramsay 6: sem resposta</option>
          </select>

          <select id="rass" class="text-input">
            <option value="4">RASS +4: combativo</option>
            <option value="3">RASS +3: muito agitado</option>
            <option value="2">RASS +2: agitado</option>
            <option value="1">RASS +1: inquieto</option>
            <option value="0">RASS 0: alerta e calmo</option>
            <option value="-1">RASS -1: sonolento</option>
            <option value="-2">RASS -2: sedação leve</option>
            <option value="-3">RASS -3: sedação moderada</option>
            <option value="-4">RASS -4: sedação profunda</option>
            <option value="-5">RASS -5: não desperta</option>
          </select>
        </div>

        <div id="sedationResult" class="answer-box"></div>
      </div>

      <div id="calcPanel_pain" class="calc-panel hidden">
        <div class="calc-title">Escala de dor (0 a 10)</div>
        <p class="calc-help">Informe a pontuação referida. Interpretação usual: 1-3 leve, 4-6 moderada, 7-10 intensa.</p>
        <div class="calc-row">
          <input id="painScore" class="text-input" type="number" step="1" min="0" max="10" placeholder="Dor (0-10)" />
        </div>
        <div id="painResult" class="answer-box"></div>
      </div>

      <div id="calcPanel_morse" class="calc-panel hidden">
        <div class="calc-title">Risco de quedas (Morse)</div>
        <p class="calc-help">Selecione cada item e o sistema soma a pontuação.</p>

        <div class="calc-row">
          <select id="morseFallHx" class="text-input">
            <option value="0">Histórico de quedas: não (0)</option>
            <option value="25">Histórico de quedas: sim (25)</option>
          </select>

          <select id="morseSecondaryDx" class="text-input">
            <option value="0">Diagnóstico secundário: não (0)</option>
            <option value="15">Diagnóstico secundário: sim (15)</option>
          </select>

          <select id="morseAid" class="text-input">
            <option value="0">Auxílio à deambulação: nenhum/repouso/leito/ajuda profissional (0)</option>
            <option value="15">Auxílio à deambulação: muletas/bengala/andador (15)</option>
            <option value="30">Auxílio à deambulação: apoia-se em móveis (30)</option>
          </select>

          <select id="morseIv" class="text-input">
            <option value="0">Terapia endovenosa (soro/heparina lock): não (0)</option>
            <option value="20">Terapia endovenosa (soro/heparina lock): sim (20)</option>
          </select>

          <select id="morseGait" class="text-input">
            <option value="0">Marcha/transferência: normal/repouso/uso de cadeira (0)</option>
            <option value="10">Marcha/transferência: fraca (10)</option>
            <option value="20">Marcha/transferência: prejudicada (20)</option>
          </select>

          <select id="morseMental" class="text-input">
            <option value="0">Estado mental: reconhece limitações (0)</option>
            <option value="15">Estado mental: esquece limitações (15)</option>
          </select>
        </div>

        <div id="morseResult" class="answer-box"></div>
      </div>

      <div id="calcPanel_braden" class="calc-panel hidden">
        <div class="calc-title">Braden (risco de LPP)</div>
        <p class="calc-help">Selecione cada subescala (valores usuais). Total varia de 6 a 23.</p>

        <div class="calc-row">
          <select id="brSensory" class="text-input">
            <option value="4">Percepção sensorial: sem limitação (4)</option>
            <option value="3">Percepção sensorial: levemente limitada (3)</option>
            <option value="2">Percepção sensorial: muito limitada (2)</option>
            <option value="1">Percepção sensorial: completamente limitada (1)</option>
          </select>

          <select id="brMoisture" class="text-input">
            <option value="4">Umidade: raramente úmido (4)</option>
            <option value="3">Umidade: ocasionalmente úmido (3)</option>
            <option value="2">Umidade: frequentemente úmido (2)</option>
            <option value="1">Umidade: constantemente úmido (1)</option>
          </select>

          <select id="brActivity" class="text-input">
            <option value="4">Atividade: anda frequentemente (4)</option>
            <option value="3">Atividade: anda ocasionalmente (3)</option>
            <option value="2">Atividade: restrito à cadeira (2)</option>
            <option value="1">Atividade: acamado (1)</option>
          </select>

          <select id="brMobility" class="text-input">
            <option value="4">Mobilidade: sem limitação (4)</option>
            <option value="3">Mobilidade: levemente limitada (3)</option>
            <option value="2">Mobilidade: muito limitada (2)</option>
            <option value="1">Mobilidade: completamente imóvel (1)</option>
          </select>

          <select id="brNutrition" class="text-input">
            <option value="4">Nutrição: excelente (4)</option>
            <option value="3">Nutrição: adequada (3)</option>
            <option value="2">Nutrição: provavelmente inadequada (2)</option>
            <option value="1">Nutrição: muito pobre (1)</option>
          </select>

          <select id="brFriction" class="text-input">
            <option value="3">Fricção/cisalhamento: nenhum problema aparente (3)</option>
            <option value="2">Fricção/cisalhamento: problema potencial (2)</option>
            <option value="1">Fricção/cisalhamento: problema (1)</option>
          </select>
        </div>

        <div id="bradenResult" class="answer-box"></div>
      </div>

      <div id="calcPanel_pews" class="calc-panel hidden">
        <div class="calc-title">PEWS (pediatria)</div>
        <p class="calc-help">Modelo baseado no Brighton PEWS: comportamento, cardiovascular e respiratório (0 a 3 cada). Use junto ao protocolo institucional de escalonamento.</p>

        <div class="calc-row">
          <select id="pewsBehavior" class="text-input">
            <option value="0">Comportamento: responsivo/apropriado (0)</option>
            <option value="1">Comportamento: sonolento/agitado, consolável (1)</option>
            <option value="2">Comportamento: irritado/agitado, não consolável (2)</option>
            <option value="3">Comportamento: letárgico/confuso ou pouca resposta à dor (3)</option>
          </select>

          <select id="pewsCardio" class="text-input">
            <option value="0">Cardiovascular: cor normal ou TPC 1-2s (0)</option>
            <option value="1">Cardiovascular: pálido ou TPC 3s (1)</option>
            <option value="2">Cardiovascular: acinzentado/cianótico ou TPC 4s, ou FC &gt; 20 acima do normal (2)</option>
            <option value="3">Cardiovascular: moteado/TPC ≥ 5s, ou FC &gt; 30 acima do normal, ou bradicardia (3)</option>
          </select>

          <select id="pewsResp" class="text-input">
            <option value="0">Respiratório: sem desconforto (0)</option>
            <option value="1">Respiratório: FR &gt; 10 acima do normal ou uso leve de musculatura acessória (1)</option>
            <option value="2">Respiratório: FR &gt; 20 acima do normal ou retrações marcadas (2)</option>
            <option value="3">Respiratório: FR &gt; 30 acima do normal ou desconforto grave (3)</option>
          </select>
        </div>

        <div id="pewsResult" class="answer-box"></div>
      </div>

    </div>

    <div id="sbarCard" class="module-card hidden">
      <div class="module-title-row">
        <h2>Passagem de Plantão (SBAR)</h2>
        <button id="openSbarGuideBtn" class="btn-print guide-main-btn" type="button">Guia</button>
      </div>
      <p class="module-subtitle">Use este módulo para gravar rapidamente (no momento do plantão) e gerar uma passagem de plantão no padrão SBAR (Situação, Background, Avaliação, Recomendação).</p>

      <div id="sbarGuidePanel" class="guide-inline hidden">
        <h3>Guia rápido para Passagem de Plantão (SBAR)</h3>
        <p>Este guia explica como usar o módulo e traz um roteiro completo para coletar informações e gerar uma passagem de plantão de alta qualidade. Use a estrutura SBAR como base e adapte ao caso.</p>

        <h4>Situação (S)</h4>
        <ul>
          <li>Quem é o paciente (nome/idade/leito) e por que está internado/atendido agora?</li>
          <li>Qual é o problema principal neste momento? O que mudou nas últimas horas?</li>
          <li>Há alguma urgência imediata (via aérea, respiração, circulação, sangramento, dor intensa, rebaixamento)?</li>
        </ul>

        <h4>Background (B)</h4>
        <ul>
          <li>Diagnóstico(s) principal(is) e tempo de evolução/internação.</li>
          <li>Comorbidades relevantes (HAS, DM, DPOC/asma, IRC, cardiopatia, anticoagulação, etc.).</li>
          <li>Alergias, medicamentos em uso e antibióticos (dose/horário da próxima dose).</li>
          <li>Procedimentos/dispositivos: acesso venoso, sonda vesical, SNG, drenos, oxigênio, ventilação, curativos.</li>
          <li>Isolamento/precauções, histórico recente de febre, quedas, delirium, convulsões.</li>
        </ul>

        <h4>Avaliação (A)</h4>
        <ul>
          <li>Sinais vitais atuais e tendência (PA, FC, FR, SpO2, temperatura), diurese e balanço hídrico quando aplicável.</li>
          <li>Estado geral e exame dirigido (consciência, perfusão, dispneia, dor, sangramentos, feridas, edema).</li>
          <li>Resultados relevantes: glicemias, hemograma, eletrólitos, função renal, gasometria, culturas, imagem recente.</li>
          <li>Risco e segurança: risco de queda/lesão por pressão, risco de broncoaspiração, escala de dor, sedação.</li>
        </ul>

        <h4>Recomendação (R)</h4>
        <ul>
          <li>O que precisa ser feito no próximo turno? Liste tarefas e prioridades.</li>
          <li>Metas e monitorização: parâmetros-alvo, frequência de checagens, quando reavaliar.</li>
          <li>Exames pendentes e o que fazer com o resultado (conduta se alterar).</li>
          <li>Sinais de alarme e quando acionar o médico/plantonista.</li>
          <li>Plano de alta/transferência se aplicável.</li>
        </ul>

        <p><strong>Dica prática:</strong> se faltar alguma informação, pergunte e registre durante a própria gravação do SBAR. Quanto mais completo o relato, melhor a passagem de plantão.</p>
      </div>

      <button id="sbarRecordBtn" class="start" type="button">Iniciar passagem de plantão (SBAR)</button>
      <div id="sbarTimer" class="mini-timer hidden">00:00</div>
      <div id="sbarStatus" class="mini-status">Clique em "Iniciar passagem de plantão (SBAR)" para começar.</div>

      <textarea id="sbarOutput" class="output-textarea" placeholder="O SBAR gerado aparecerá aqui..." spellcheck="false"></textarea>

      <div class="prescription-actions">
        <button id="copySbarBtn" class="btn-copy" type="button">Copiar</button>
        <button id="printSbarBtn" class="btn-print" type="button">Imprimir</button>
      </div>
    </div>




                <div id="patientReportCard" class="module-card hidden">
      <h2>Relatórios de Enfermagem / Encaminhamentos / Declarações / Solicitações / Comunicados / Atestado de comparecimento ou permanência / ATA reunião / Registros de procedimentos</h2>
      <p class="mini-status" style="margin-top: 0;">
        Grave em voz alta o conteúdo do documento. Diga claramente qual documento deseja produzir (por exemplo: declaração de comparecimento, relatório de curativo seriado, encaminhamento para CAPS, solicitação de insumos, comunicado para escola, ata de reunião). Ao encerrar
    

, a gravação será usada para identificar o tipo de documento e gerar um texto padronizado pronto para colar no S.U.I.S.
      </p>

      <div class="inline-input-row">
        <label for="reportDocTypeSelect" style="font-size: 13px; color: #111827; font-weight: 600;">Tipo de documento:</label>
        <select id="reportDocTypeSelect" class="text-input" style="min-width: 260px; max-width: 100%;">          <option value="auto" selected>Auto (identificar pela gravação)</option>
          <option value="Declaração de comparecimento">Declaração de comparecimento</option>
          <option value="Declaração de permanência">Declaração de permanência</option>
          <option value="Declaração para acompanhante">Declaração para acompanhante</option>
          <option value="Declaração de recebimento de orientações">Declaração de recebimento de orientações</option>
          <option value="Declaração de recusa de procedimento/conduta">Declaração de recusa de procedimento/conduta</option>
          <option value="Termo de consentimento informado (procedimento de enfermagem)">Termo de consentimento informado (procedimento de enfermagem)</option>
          <option value="Termo de ciência e responsabilidade (orientações e riscos)">Termo de ciência e responsabilidade (orientações e riscos)</option>
          <option value="Comunicado para escola">Comunicado para escola</option>
          <option value="Relatório para escola (necessidades específicas)">Relatório para escola (necessidades específicas)</option>
          <option value="Comunicado ao Conselho Tutelar">Comunicado ao Conselho Tutelar</option>
          <option value="Relatório para Conselho Tutelar (proteção à criança/adolescente)">Relatório para Conselho Tutelar (proteção à criança/adolescente)</option>
          <option value="Relatório de curativo seriado">Relatório de curativo seriado</option>
          <option value="Registro de procedimento de curativo">Registro de procedimento de curativo</option>
          <option value="Registro de retirada de pontos/suturas">Registro de retirada de pontos/suturas</option>
          <option value="Registro de procedimento de vacinação">Registro de procedimento de vacinação</option>
          <option value="Registro de evento adverso pós-vacinação (EAPV)">Registro de evento adverso pós-vacinação (EAPV)</option>
          <option value="Registro de procedimento de administração de medicamentos">Registro de procedimento de administração de medicamentos</option>
          <option value="Registro de administração de medicamento controlado (registro interno)">Registro de administração de medicamento controlado (registro interno)</option>
          <option value="Registro de coleta de exames">Registro de coleta de exames</option>
          <option value="Registro de nebulização/oxigenoterapia">Registro de nebulização/oxigenoterapia</option>
          <option value="Registro de sondagem vesical">Registro de sondagem vesical</option>
          <option value="Registro de troca de sonda/traqueostomia/gastrostomia">Registro de troca de sonda/traqueostomia/gastrostomia</option>
          <option value="Registro de visita domiciliar">Registro de visita domiciliar</option>
          <option value="Relatório de visita domiciliar">Relatório de visita domiciliar</option>
          <option value="Relatório de adesão e educação em saúde (HAS/DM)">Relatório de adesão e educação em saúde (HAS/DM)</option>
          <option value="Relatório de acompanhamento de hipertensão (HAS)">Relatório de acompanhamento de hipertensão (HAS)</option>
          <option value="Relatório de acompanhamento de diabetes (DM)">Relatório de acompanhamento de diabetes (DM)</option>
          <option value="Relatório de acompanhamento de asma/DPOC">Relatório de acompanhamento de asma/DPOC</option>
          <option value="Relatório de acompanhamento de saúde da criança (puericultura)">Relatório de acompanhamento de saúde da criança (puericultura)</option>
          <option value="Relatório de acompanhamento de pré-natal (enfermagem)">Relatório de acompanhamento de pré-natal (enfermagem)</option>
          <option value="Relatório de puerpério (enfermagem)">Relatório de puerpério (enfermagem)</option>
          <option value="Relatório para assistência social (vulnerabilidade e insumos)">Relatório para assistência social (vulnerabilidade e insumos)</option>
          <option value="Solicitação de insumos (fraldas, curativos, suplementos)">Solicitação de insumos (fraldas, curativos, suplementos)</option>
          <option value="Solicitação de fraldas (infantil/geriátrica)">Solicitação de fraldas (infantil/geriátrica)</option>
          <option value="Solicitação de materiais para ostomia">Solicitação de materiais para ostomia</option>
          <option value="Solicitação de dieta enteral/suplementação">Solicitação de dieta enteral/suplementação</option>
          <option value="Solicitação de oxigenoterapia domiciliar">Solicitação de oxigenoterapia domiciliar</option>
          <option value="Solicitação de equipamentos de apoio (cadeira de rodas, colchão pneumático)">Solicitação de equipamentos de apoio (cadeira de rodas, colchão pneumático)</option>
          <option value="Solicitação de transporte sanitário">Solicitação de transporte sanitário</option>
          <option value="Solicitação de avaliação médica">Solicitação de avaliação médica</option>
          <option value="Encaminhamento para Médico (demanda espontânea)">Encaminhamento para Médico (demanda espontânea)</option>
          <option value="Encaminhamento para sala de vacina">Encaminhamento para sala de vacina</option>
          <option value="Encaminhamento para curativos/ambulatório de feridas">Encaminhamento para curativos/ambulatório de feridas</option>
          <option value="Encaminhamento para CAPS / saúde mental">Encaminhamento para CAPS / saúde mental</option>
          <option value="Relatório para CAPS / saúde mental (enfermagem)">Relatório para CAPS / saúde mental (enfermagem)</option>
          <option value="Encaminhamento para Serviço Social">Encaminhamento para Serviço Social</option>
          <option value="Encaminhamento para Psicologia">Encaminhamento para Psicologia</option>
          <option value="Encaminhamento para Nutrição">Encaminhamento para Nutrição</option>
          <option value="Encaminhamento para Fisioterapia">Encaminhamento para Fisioterapia</option>
          <option value="Encaminhamento para Fonoaudiologia">Encaminhamento para Fonoaudiologia</option>
          <option value="Encaminhamento para Odontologia">Encaminhamento para Odontologia</option>
          <option value="Encaminhamento para especialista / rede">Encaminhamento para especialista / rede</option>
          <option value="Encaminhamento para urgência/emergência">Encaminhamento para urgência/emergência</option>
          <option value="Relatório de evolução de enfermagem">Relatório de evolução de enfermagem</option>
          <option value="Relatório de intercorrência/ocorrência">Relatório de intercorrência/ocorrência</option>
          <option value="Ata de reunião">Ata de reunião</option>
          <option value="Registro de reunião de equipe (ATA breve)">Registro de reunião de equipe (ATA breve)</option>
          <option value="Comunicado interno da equipe">Comunicado interno da equipe</option>
          <option value="Outros">Outros</option>
</select>
      </div>

      <div class="inline-input-row">
        <button id="reportRecordBtn" class="small-record-btn start" type="button">Gravar documento</button>
        <button id="copyReportBtn" class="btn-copy hidden" type="button">Copiar documento</button>
        <button id="printReportBtn" class="btn-print hidden" type="button">Imprimir documento</button>
      </div>

      <div id="reportStatus" class="mini-status"></div>

      <div class="inline-input-row" style="margin-top: 6px;">
        <div style="flex: 1; min-width: 240px;">
          <div style="font-size: 12px; font-weight: 700; color: #111827; margin-bottom: 4px;">Tipo identificado</div>
          <div id="reportDocTypeDetected" class="answer-box" style="min-height: 44px;"></div>
        </div>
        <div style="flex: 1; min-width: 240px;">
          <div style="font-size: 12px; font-weight: 700; color: #111827; margin-bottom: 4px;">Campos pendentes</div>
          <div id="reportMissingFields" class="answer-box" style="min-height: 44px;"></div>
        </div>
      </div>

      <textarea id="reportOutput" class="prescription-textarea" placeholder="O documento gerado aparecerá aqui." style="margin-top: 12px;"></textarea>
      <div id="reportPreview" class="classification-box formatted-output" style="margin-top: 12px; display: none;">Nenhum conteúdo disponível.</div>

    </div>

  </div>

  <div id="recommendationsPanel" class="recommendations-panel">
    <div class="recommendations-header">
      <h3>Perguntas essenciais para anamnese</h3>
      <button id="closeRecommendationsBtn" class="close-panel-btn" aria-label="Fechar painel de recomendações">X</button>
    </div>
    <div id="recommendationsStatus" class="recommendations-status">
      Clique em "Perguntas essenciais" para gerar perguntas complementares essenciais.
    </div>
    <div id="recommendationsList" class="recommendations-list"></div>
    <button id="askQuestionsBtn" class="ask-questions-btn" disabled>Complementar avaliação</button>
    <div id="questionsTimer" class="questions-timer hidden">00:00</div>
    <p class="recommendations-footer">
      Ao clicar em "Complementar avaliação", uma nova gravação será iniciada para você aplicar essas perguntas diretamente ao paciente.
      As respostas serão usadas para atualizar automaticamente o SOAP e a conduta.
    </p>

  

  </div>

  <div id="handoffGuidePanel" class="recommendations-panel">
    <div class="recommendations-header">
      <h3>Guia de Passagem de Plantão</h3>
      <button id="closeHandoffGuideBtn" class="close-panel-btn" aria-label="Fechar guia de passagem de plantão">X</button>
    </div>

    <div class="recommendations-status">
      Este guia explica como usar o módulo e traz um roteiro completo para coletar informações e gerar uma passagem de plantão de alta qualidade. Use a estrutura SBAR como base e adapte ao caso.
    </div>

    <div id="handoffGuideContent" class="recommendations-list">
      <div class="recommendation-item"><strong>Como funciona o módulo</strong>
        <ul>
          <li>Clique em "Iniciar passagem de plantão", fale de forma objetiva seguindo o roteiro abaixo e finalize clicando novamente no botão grande vermelho.</li>
          <li>O sistema transforma sua fala em um texto estruturado para repassar ao colega e registrar no prontuário.</li>
          <li>Se perceber que algo importante ficou faltando, regrave imediatamente e inclua a informação durante a própria passagem.</li>
        </ul>
      </div>

      <div class="recommendation-item"><strong>Antes de gravar (preparo rápido em 30 a 60 segundos)</strong>
        <ul>
          <li>Confirme identificação: nome completo, idade, leito/box, número de prontuário se houver.</li>
          <li>Releia rapidamente: evolução mais recente, últimos sinais vitais, diurese/balanço quando aplicável, exames novos e prescrições.</li>
          <li>Cheque segurança: alergias, precauções/isolamento, risco de queda, lesão por pressão, broncoaspiração, restrição de dieta/jejum.</li>
          <li>Revise dispositivos e terapias em curso: oxigênio, acesso venoso, sonda vesical, SNG/SNE, drenos, curativos, bombas de infusão.</li>
        </ul>
      </div>

      <div class="recommendation-item"><strong>Situação (S)</strong>
        <div style="margin-top: 6px; font-size: 13px; color: #111827;">
          O que falar:
        </div>
        <ul>
          <li>Quem é o paciente (nome/idade/leito) e motivo atual do atendimento/internação.</li>
          <li>Estado atual em uma frase: estável, instável, piora recente, necessidade de monitorização.</li>
          <li>O que mudou nas últimas horas: dor, dispneia, febre, rebaixamento, sangramento, hipotensão, hipoglicemia/hiperglicemia, queda de saturação.</li>
          <li>Se houver, urgência imediata e o que já foi feito.</li>
        </ul>
        <div style="margin-top: 6px; font-size: 13px; color: #111827;">
          O que perguntar ao colega (se estiver recebendo o plantão):
        </div>
        <ul>
          <li>Qual é o principal risco nas próximas horas?</li>
          <li>Qual é o limiar para acionar o médico/plantonista (valores de PA, SpO2, glicemia, febre, dor)?</li>
        </ul>
      </div>

      <div class="recommendation-item"><strong>Background (B)</strong>
        <div style="margin-top: 6px; font-size: 13px; color: #111827;">
          O que falar:
        </div>
        <ul>
          <li>Diagnóstico(s) principal(is), hipótese(s) em investigação e tempo de evolução/internação.</li>
          <li>Comorbidades relevantes e fatores de risco.</li>
          <li>Alergias e reações prévias importantes.</li>
          <li>Medicações críticas em uso e próximos horários: antibióticos, anticoagulantes, insulina, vasopressores, sedação, analgesia forte, anticonvulsivantes.</li>
          <li>Procedimentos e dispositivos: tipo/local do acesso, sondas, drenos, oxigenoterapia, ventilação, curativos e cuidados específicos.</li>
          <li>Precauções/isolamento, status de jejum/dieta e restrições.</li>
        </ul>
        <div style="margin-top: 6px; font-size: 13px; color: #111827;">
          O que perguntar ao colega (se estiver recebendo o plantão):
        </div>
        <ul>
          <li>Existe medicação de alto risco ou ajuste programado ainda neste turno?</li>
          <li>Há pendência de autorização, encaminhamento, regulação ou vaga/transferência?</li>
        </ul>
      </div>

      <div class="recommendation-item"><strong>Avaliação (A)</strong>
        <div style="margin-top: 6px; font-size: 13px; color: #111827;">
          O que falar:
        </div>
        <ul>
          <li>Últimos sinais vitais e tendência, incluindo necessidade de O2 e saturação.</li>
          <li>Estado neurológico (nível de consciência), dor, perfusão, respiração, sangramentos, feridas/curativos, edema.</li>
          <li>Diurese e balanço hídrico quando relevante; aceitação de dieta e vômitos/diarreia se presente.</li>
          <li>Resultados relevantes recentes (glicemias, hemograma, eletrólitos, função renal, gasometria, culturas, imagem) e o impacto na conduta.</li>
          <li>Riscos de segurança: queda, lesão por pressão, broncoaspiração, delirium, convulsões, contenção, risco de extravasamento/complicação de acesso.</li>
        </ul>
        <div style="margin-top: 6px; font-size: 13px; color: #111827;">
          O que perguntar ao colega (se estiver recebendo o plantão):
        </div>
        <ul>
          <li>Qual foi a evolução nas últimas 6 a 12 horas e qual a principal tendência (melhora/piora)?</li>
          <li>Há exame que precisa ser rechecado em horário específico ou após intervenção?</li>
        </ul>
      </div>

      <div class="recommendation-item"><strong>Recomendação (R)</strong>
        <div style="margin-top: 6px; font-size: 13px; color: #111827;">
          O que falar:
        </div>
        <ul>
          <li>Pendências objetivas para o próximo turno, em ordem de prioridade, com horário quando houver.</li>
          <li>Exames solicitados e pendentes: qual resultado esperar e qual conduta tomar conforme o resultado.</li>
          <li>Metas de monitorização: frequência de sinais vitais, glicemia capilar, débito urinário, reavaliação de dor, checagem de curativos, balanço hídrico.</li>
          <li>Sinais de alarme e plano de ação: o que fazer e quando acionar o médico/plantonista.</li>
          <li>Plano de alta/transferência se aplicável e pontos que precisam ser resolvidos para isso.</li>
        </ul>
        <div style="margin-top: 6px; font-size: 13px; color: #111827;">
          O que perguntar ao colega (se estiver recebendo o plantão):
        </div>
        <ul>
          <li>Qual é a tarefa mais importante a cumprir primeiro neste paciente?</li>
          <li>Qual é o plano se houver piora (passo a passo)?</li>
        </ul>
      </div>

      <div class="recommendation-item"><strong>Modelo pronto de passagem (falar e adaptar)</strong>
        <div style="white-space: pre-wrap; margin-top: 8px; font-size: 13px; color: #111827;">
Situação: Paciente [nome], [idade], leito [X], em acompanhamento por [motivo/diagnóstico]. No momento está [estável/instável], com [principal problema atual] e [mudança recente].

Background: Diagnóstico principal [X], comorbidades [X]. Alergia [X]. Medicações críticas: [medicação] próxima dose [horário]. Dispositivos: [acesso], [sonda], [O2], [curativo/dreno], com cuidados [detalhes].

Avaliação: SV atuais [PA/FC/FR/SpO2/T], tendência [melhora/piora]. Dor [escala], consciência [nível]. Diurese/balanço [se aplicável]. Exames recentes: [resultados] com impacto [conduta]. Riscos: [queda/LPP/broncoaspiração/outros] e medidas em curso.

Recomendação: Pendências prioritárias: (1) [tarefa] até [horário]; (2) [tarefa]. Exames pendentes: [exame], conferir em [horário] e agir assim: [conduta]. Monitorizar [parâmetros] a cada [intervalo]. Acionar médico se: [sinais de alarme].</div>
      </div>

      <div class="recommendation-item"><strong>Checagem final de qualidade</strong>
        <ul>
          <li>A passagem tem identificação completa, problema atual e tendência?</li>
          <li>Há lista clara de dispositivos/terapias em curso e riscos principais?</li>
          <li>As pendências estão priorizadas, com horários e conduta se o exame vier alterado?</li>
          <li>Ficou explícito quando acionar o médico/plantonista e quais são os sinais de alarme?</li>
        </ul>
      </div>
</div>
    </div>
  </div>

  <div id="aprazamentoGuidePanel" class="recommendations-panel">
    <div class="recommendations-header">
      <h3>Guia: Aprazamento de prescrição</h3>
      <button id="closeAprazamentoGuideBtn" class="close-panel-btn" aria-label="Fechar guia de aprazamento de prescrição">X</button>
    </div>
    <div class="recommendations-status">
      Como usar este módulo para refazer a folha de prescrição e aprazar os medicamentos com segurança.
    </div>
    <div class="recommendations-list">
      <div class="recommendation-item"><strong>1) Foto nítida</strong><br>Garanta iluminação, foco e enquadramento. Inclua cabeçalho e a lista de medicamentos. Se houver mais de uma página, envie as páginas essenciais.</div>
      <div class="recommendation-item"><strong>2) Conferência dos campos</strong><br>Revise hospital, unidade, leito, paciente, data, nome/CRM do médico e demais campos transcritos. O sistema não inventa: campos ilegíveis podem vir como "não informado".</div>
      <div class="recommendation-item"><strong>3) Horários aprazados</strong><br>Quando a prescrição trouxer horários explícitos, eles são mantidos. Quando trouxer apenas frequência/intervalo, o sistema sugere horários padrão para facilitar o aprazamento. Ajuste conforme rotina do serviço e início de administração, se necessário.</div>
      <div class="recommendation-item"><strong>4) Checagem e assinatura</strong><br>Use a grade de horários para checagem/assinatura. Ao final, assine no campo do enfermeiro e imprima a folha, se for substituir a original.</div>
      <div class="recommendation-item"><strong>5) Segurança</strong><br>Antes de administrar, confirme via, dose, diluição/velocidade e restrições no documento oficial e no protocolo institucional. Em caso de divergência, priorize a prescrição oficial.</div>
    </div>
  </div>

  <div id="woundGuidePanel" class="recommendations-panel">
    <div class="recommendations-header">
      <h3>Guia: Curativos e feridas</h3>
      <button id="closeWoundGuideBtn" class="close-panel-btn" aria-label="Fechar guia de curativos e feridas">X</button>
    </div>
    <div class="recommendations-status">
      Como usar este módulo para padronizar a avaliação e orientar o curativo.
    </div>
    <div class="recommendations-list">
      <div class="recommendation-item"><strong>1) Foto adequada</strong><br>Fotografe a lesão em boa luz, com foco. Se possível, inclua um referencial de tamanho (régua) e uma foto geral e outra de perto.</div>
      <div class="recommendation-item"><strong>2) Contexto clínico</strong><br>Antes de agir, verifique sinais de infecção, dor, perfusão, comorbidades (DM, vasculopatia) e risco de lesão por pressão.</div>
      <div class="recommendation-item"><strong>3) Revisão do resultado</strong><br>Leia a descrição, cuidados sugeridos e sinais de alarme. Ajuste à realidade do paciente e ao protocolo local.</div>
      <div class="recommendation-item"><strong>4) Registro</strong><br>Use "Copiar descrição e conduta" para colar no prontuário e "Imprimir" quando necessário.</div>
    </div>
  </div>

  <div id="examGuidePanel" class="recommendations-panel">
    <div class="recommendations-header">
      <h3>Guia: Interpretação de resultados de exames</h3>
      <button id="closeExamGuideBtn" class="close-panel-btn" aria-label="Fechar guia de interpretação de resultados de exames">X</button>
    </div>
    <div class="recommendations-status">
      Como usar este módulo para orientar o paciente e apoiar a tomada de decisão.
    </div>
    <div class="recommendations-list">
      <div class="recommendation-item"><strong>1) Envie o exame</strong><br>Use "Tirar foto" ou "Escolher arquivo". Garanta que valores, unidades, data e identificação do exame estejam visíveis.</div>
      <div class="recommendation-item"><strong>2) Use junto do contexto</strong><br>Interpretação depende de sintomas, história e exame físico. Não use o texto gerado como substituto de avaliação clínica.</div>
      <div class="recommendation-item"><strong>3) Revise antes de registrar</strong><br>Confira com o documento original. Se houver divergência, priorize o laudo/resultado oficial.</div>
      <div class="recommendation-item"><strong>4) Próximos passos</strong><br>Utilize as orientações para explicar ao paciente, planejar monitorização e identificar sinais de alarme para acionar o médico.</div>
    </div>
  </div>

  <div id="medicalDoubtsGuidePanel" class="recommendations-panel">
    <div class="recommendations-header">
      <h3>Guia: Dúvidas em Saúde</h3>
      <button id="closeMedicalDoubtsGuideBtn" class="close-panel-btn" aria-label="Fechar guia de dúvidas em saúde">X</button>
    </div>
    <div class="recommendations-status">
      Como formular perguntas e usar as respostas de forma segura.
    </div>
    <div class="recommendations-list">
      <div class="recommendation-item"><strong>1) Pergunta objetiva</strong><br>Descreva o cenário com idade, queixa, tempo de evolução e sinais de gravidade. Evite termos vagos.</div>
      <div class="recommendation-item"><strong>2) Foque em orientação prática</strong><br>Peça condutas de enfermagem, sinais de alarme, educação do paciente e quando acionar o médico.</div>
      <div class="recommendation-item"><strong>3) Validação</strong><br>Use a resposta como apoio. Confirme com protocolos locais e documentação oficial antes de registrar ou orientar condutas críticas.</div>
    </div>
  </div>

  <div id="calculatorsGuidePanel" class="recommendations-panel">
    <div class="recommendations-header">
      <h3>Guia: Calculadoras Clínicas</h3>
      <button id="closeCalculatorsGuideBtn" class="close-panel-btn" aria-label="Fechar guia de calculadoras clínicas">X</button>
    </div>
    <div class="recommendations-status">
      Como usar as calculadoras e evitar erros de unidade.
    </div>
    <div class="recommendations-list">
      <div class="recommendation-item"><strong>1) Selecione a calculadora</strong><br>Escolha o tipo (IMC, risco cardiovascular, SC, idade gestacional, gotejamento, balanço hídrico, dose por peso, Glasgow, sedação).</div>
      <div class="recommendation-item"><strong>2) Preencha com atenção</strong><br>Confira unidades (kg, cm, mL, gotas/min, bpm), datas e se o campo exige número inteiro ou decimal.</div>
      <div class="recommendation-item"><strong>3) Interprete com contexto</strong><br>O resultado é um apoio. Use junto da avaliação clínica e do protocolo do serviço.</div>
      <div class="recommendation-item"><strong>4) Registro</strong><br>Quando necessário, copie o resultado para o prontuário e registre também os dados usados no cálculo.</div>
    </div>
  </div>


  <div id="medicalDocsGuidePanel" class="recommendations-panel">
    <div class="recommendations-header">
      <h3>Guia: Geração de documentos</h3>
      <button id="closeMedicalDocsGuideBtn" class="close-panel-btn" aria-label="Fechar guia de geração de documentos">X</button>
    </div>
    <div class="recommendations-status">
      Este módulo grava em voz alta a consulta inteira ou o trecho necessário e gera um documento médico formal com campos pendentes quando faltar informação.
    </div>
    <div class="recommendations-list">
      <div class="recommendation-item"><strong>1) Tipos de documentos</strong><br>Relatório/declaração para INSS, atestado, encaminhamento, declaração simples e solicitações (exames, materiais, insumos, transporte, etc.).</div>
      <div class="recommendation-item"><strong>2) Como gravar</strong><br>Antes de iniciar, diga qual documento será gerado e para qual finalidade/destino. Durante a gravação, informe dados essenciais do paciente, datas, evolução e conduta. Fale de forma contínua e clara.</div>
      <div class="recommendation-item"><strong>3) O que o sistema faz ao encerrar</strong><br>Identifica o tipo de documento, resume a queixa/doença, reconhece exames citados e monta um texto formal. Se algum dado estiver ausente, ele será indicado como pendência para você completar.</div>
      <div class="recommendation-item"><strong>4) Revisão obrigatória</strong><br>Revise o texto, complete campos pendentes e ajuste termos. Use Copiar para colar no prontuário/editor e Imprimir quando precisar do documento em papel.</div>
      <div class="recommendation-item"><strong>5) Atenção</strong><br>Este módulo não substitui sua avaliação clínica. Em documentos com implicações legais/benefícios, confira datas, identificação, período e informações críticas antes de finalizar.</div>
    </div>
  </div>

<script>

    const DEFAULT_BACKEND_URL = "https://consulta-enfermagem-1.onrender.com";
    // Backend principal (Render). Pode ser sobrescrito por:
    // 1) Querystring ?backend=https://...  (útil para testes)
    // 2) localStorage BACKEND_URL_OVERRIDE
    // Se estiver rodando localmente, usa http://localhost:3000
    const BACKEND_URL = (() => {
      const qp = new URLSearchParams(window.location.search);
      const fromQuery = (qp.get("backend") || "").trim();
      const fromStorage = (localStorage.getItem("BACKEND_URL_OVERRIDE") || "").trim();
      const raw = (fromQuery || fromStorage || "").trim();
      const norm = (v) => String(v || "").trim().replace(/\/+$/g, "");
      if (raw) return norm(raw);
      const host = String(window.location.hostname || "");
      if (host === "localhost" || host === "127.0.0.1") return "http://localhost:3000";
      return norm(DEFAULT_BACKEND_URL);
    })();

    // =========================
    // IMAGENS (Curativos e Prescrição) - estado por módulo (até 4 fotos)
    // =========================
    let woundImages = [];
    let examImages = [];
    let transcriptionImages = [];
    let rxEvalImages = [];
    let woundAnalyzeTimer = null;
    let examAnalyzeTimer = null;
    let transcriptionAnalyzeTimer = null;
    let rxEvalAnalyzeTimer = null;
    let aprazImages = [];
    let aprazAnalyzeTimer = null;

    // Aprazamento: horário de referência do início da geração (baseado no relógio local)
    let aprazStartTs = null;
    let aprazStartInfo = null;

    function scheduleWoundAnalysis() {
      if (woundAnalyzeTimer) clearTimeout(woundAnalyzeTimer);
      woundAnalyzeTimer = setTimeout(() => {
        if (woundImages && woundImages.length) analyzeWoundWithImages(woundImages.slice());
      }, 180);
    }

    

    function scheduleExamAnalysis() {
      if (examAnalyzeTimer) clearTimeout(examAnalyzeTimer);
      examAnalyzeTimer = setTimeout(() => {
        if (examImages && examImages.length) analyzeExamWithImages(examImages.slice());
      }, 180);
    }

    function scheduleTranscriptionAnalysis() {
      if (transcriptionAnalyzeTimer) clearTimeout(transcriptionAnalyzeTimer);
      transcriptionAnalyzeTimer = setTimeout(() => {
        if (transcriptionImages && transcriptionImages.length) analyzeTranscriptionWithImages(transcriptionImages.slice());
      }, 180);
    }

    function scheduleRxEvalAnalysis() {
      if (rxEvalAnalyzeTimer) clearTimeout(rxEvalAnalyzeTimer);
      rxEvalAnalyzeTimer = setTimeout(() => {
        if (rxEvalImages && rxEvalImages.length) analyzeRxEvalWithImages(rxEvalImages.slice());
      }, 180);
    }


    function scheduleAprazAnalysis() {
      if (aprazAnalyzeTimer) clearTimeout(aprazAnalyzeTimer);
      // Congela o horário de referência no momento em que o enfermeiro solicita a grade
      aprazStartTs = new Date();
      aprazStartInfo = getAprazStartInfo(aprazStartTs);
      aprazAnalyzeTimer = setTimeout(() => {
        if (aprazImages && aprazImages.length) analyzeAprazamentoWithImages(aprazImages.slice());
      }, 180);
    }

// =========================
    // ADMIN (caches globais - sem TDZ)
    // =========================
    var ADMIN_CACHE_USERS = [];
    var ADMIN_CACHE_AUDIT = [];
    var ADMIN_SELECTED_USER_ID = null;
    var ADMIN_SELECTED_USER_LABEL = "";

    // =========================
    // AUTENTICAÇÃO (sem escolha de perfil)
    // =========================
    const TOKEN_KEY = "ae_token_v1";
    const DEVICE_KEY = "ae_device_id_v1";

    function getDeviceId() {
      try {
        let id = localStorage.getItem(DEVICE_KEY) || "";
        id = String(id || "").trim();
        if (!id || id.length < 8) {
          // id simples para amarrar a sessão a um navegador/dispositivo
          const bytes = (window.crypto && window.crypto.getRandomValues)
            ? window.crypto.getRandomValues(new Uint8Array(16))
            : Array.from({ length: 16 }, () => Math.floor(Math.random() * 256));
          const rnd = Array.from(bytes).map(b => b.toString(16).padStart(2, "0")).join("");
          id = "dev-" + rnd;
          localStorage.setItem(DEVICE_KEY, id);
        }
        return id;
      } catch {
        return "";
      }
    }

// Diagnóstico visível: se algum erro de JS impedir o login, ele aparece aqui
    function showFatalError(msg) {
      const el = document.getElementById("loginError");
      if (el && msg) el.textContent = String(msg);
    }
    window.addEventListener("error", (ev) => {
      try {
        const m = (ev && ev.message) ? ev.message : "Erro inesperado";
        showFatalError("Erro no sistema: " + m);
      } catch {}
    });
    window.addEventListener("unhandledrejection", (ev) => {
      try {
        const r = ev && ev.reason;
        const m = (r && r.message) ? r.message : (typeof r === "string" ? r : "Falha inesperada");
        showFatalError("Erro no sistema: " + m);
      } catch {}
    });


    // Mostra erros de script diretamente na tela de login (evita sensação de "não acontece nada")
    window.addEventListener('error', (ev) => {
      try {
        const el = document.getElementById('loginError');
        if (el && ev && ev.message) el.textContent = 'Erro no sistema: ' + ev.message;
      } catch {}
    });
    window.addEventListener('unhandledrejection', (ev) => {
      try {
        const el = document.getElementById('loginError');
        const msg = (ev && ev.reason && (ev.reason.message || String(ev.reason))) ? (ev.reason.message || String(ev.reason)) : 'Erro inesperado.';
        if (el) el.textContent = 'Erro no sistema: ' + msg;
      } catch {}
    });

    const nativeFetch = window.fetch.bind(window);

    // Backup local automático (para não perder clientes em redeploy/atualizações do backend)
    const LOCAL_BACKUP_KEY = "ae_local_backup_v1";
    const LOCAL_BACKUP_AT_KEY = "ae_local_backup_at_v1";
    let RECOVERY_TRIED = false;
    let RECOVERY_RUNNING = false;

    function setLocalBackupText(txt) {
      try {
        localStorage.setItem(LOCAL_BACKUP_KEY, txt || "");
        localStorage.setItem(LOCAL_BACKUP_AT_KEY, new Date().toISOString());
      } catch {}
    }
    function getLocalBackupText() {
      try { return localStorage.getItem(LOCAL_BACKUP_KEY) || ""; } catch { return ""; }
    }
    function getLocalBackupPayload() {
      const txt = getLocalBackupText();
      if (!txt) return null;
      try { return JSON.parse(txt); } catch { return null; }
    }
    function updateAdminLocalBackupBadge() {
      const el = document.getElementById("adminLocalBackupInfo");
      if (!el) return;
      let at = "";
      try { at = localStorage.getItem(LOCAL_BACKUP_AT_KEY) || ""; } catch {}
      if (!at) {
        el.textContent = "Backup local: não disponível";
        return;
      }
      try {
        el.textContent = "Backup local: " + new Date(at).toLocaleString("pt-BR");
      } catch {
        el.textContent = "Backup local: disponível";
      }
    }
    async function refreshLocalBackupFromServer() {
      try {
        const t = getToken();
        if (!t) return;
        const resp = await fetch(BACKEND_URL + "/api/admin/backup/export", { method: "GET" });
        if (!resp.ok) return;
        const txt = await resp.text();
        if (!txt || txt.trim().length < 2) return;
        if (!txt.trim().startsWith("{")) return;
        setLocalBackupText(txt);
        updateAdminLocalBackupBadge();
      } catch {}
    }

    function getToken() {
      try { return localStorage.getItem(TOKEN_KEY) || ""; } catch { return ""; }
    }
    function setToken(t) {
      try {
        if (t) localStorage.setItem(TOKEN_KEY, t);
        else localStorage.removeItem(TOKEN_KEY);
      } catch {}
    }

    function showLogin() {
      document.getElementById("loginView")?.classList.remove("hidden");
      document.getElementById("adminView")?.classList.add("hidden");
      document.getElementById("nurseView")?.classList.add("hidden");
      document.getElementById("nurseSignupView")?.classList.add("hidden");
      document.getElementById("paymentsModal")?.classList.add("hidden");
      document.getElementById("postLoginOnlyModules")?.classList.add("hidden");
    }
    function showSignup() {
      document.getElementById("loginView")?.classList.add("hidden");
      document.getElementById("adminView")?.classList.add("hidden");
      document.getElementById("nurseView")?.classList.add("hidden");
      document.getElementById("nurseSignupView")?.classList.remove("hidden");
      document.getElementById("paymentsModal")?.classList.add("hidden");
      document.getElementById("postLoginOnlyModules")?.classList.add("hidden");
    }
    function showAdmin() {
      document.getElementById("loginView")?.classList.add("hidden");
      document.getElementById("adminView")?.classList.remove("hidden");
      document.getElementById("nurseView")?.classList.add("hidden");
      document.getElementById("nurseSignupView")?.classList.add("hidden");
      document.getElementById("postLoginOnlyModules")?.classList.remove("hidden");
    }
    function showNurse() {
      document.getElementById("loginView")?.classList.add("hidden");
      document.getElementById("adminView")?.classList.add("hidden");
      document.getElementById("nurseView")?.classList.remove("hidden");
      document.getElementById("nurseSignupView")?.classList.add("hidden");
      document.getElementById("postLoginOnlyModules")?.classList.remove("hidden");
    }

    // Intercepta chamadas ao backend e injeta Authorization quando for /api/
    window.fetch = async function(input, init) {
      try {
        const url = (typeof input === "string") ? input : (input && input.url) ? input.url : "";
        const isApi = (() => {
        if (typeof url !== "string") return false;
        const u = url;
        const p1 = BACKEND_URL + "/api/";
        const p2 = "/api/";
        const p3 = window.location.origin + "/api/";
        return u.startsWith(p1) || u.startsWith(p2) || u.startsWith(p3);
      })();
        if (!isApi) return nativeFetch(input, init);

        const headers = Object.assign({}, (init && init.headers) ? init.headers : {});
        const token = getToken();
        if (token) headers["Authorization"] = "Bearer " + token;
         const deviceId = getDeviceId();
         if (deviceId) headers["X-Device-Id"] = deviceId;
        const resp = await nativeFetch(input, Object.assign({}, init || {}, { headers }));

        if (resp && resp.status === 401) {
          let code = "";
          let msg = "";
          try {
            const data = await resp.clone().json();
            code = (data && data.code) ? String(data.code) : "";
            msg = (data && data.error) ? String(data.error) : "";
          } catch {}

          setToken("");
          showLogin();

          if (code === "SESSION_REPLACED") {
            const el = document.getElementById("loginError");
            const text = msg || "Sessão encerrada porque esta conta foi acessada em outro dispositivo.";
            if (el) el.textContent = text;
            else alert(text);
          } else if (code === "SESSION_EXPIRED") {
            const el = document.getElementById("loginError");
            const text = msg || "Sessão expirada. Faça login novamente.";
            if (el) el.textContent = text;
          }
        }
        return resp;
      } catch (e) {
        return nativeFetch(input, init);
      }
    };

    async function authMe() {
      const resp = await fetch(BACKEND_URL + "/api/auth/me", { method: "GET" });
      if (!resp.ok) throw new Error("me failed");
      return await resp.json();
    }

    async function doLogin() {
      const login = (document.getElementById("loginField")?.value || "").trim();
      const senha = (document.getElementById("passwordField")?.value || "").trim();
      const errEl = document.getElementById("loginError");
      const btn = document.getElementById("loginBtn");
      if (!login || !senha) {
        if (errEl) errEl.textContent = "Informe login e senha.";
        return;
      }
      if (errEl) errEl.textContent = "Conectando...";
      if (btn) btn.disabled = true;
      try {
        const resp = await nativeFetch(BACKEND_URL + "/api/auth/login", {
          method: "POST",
          headers: { "Content-Type": "application/json", "X-Device-Id": getDeviceId() },
          body: JSON.stringify({ login, senha })
        });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) {
          if (errEl) errEl.textContent = data.error || "Falha no login.";
          return;
        }
        setToken(data.token || "");
        await restoreSession();
      } catch (e) {
        if (errEl) errEl.textContent = "Falha ao conectar no servidor.";
      } finally {
        if (btn) btn.disabled = false;
      }
    }

    function resetSignupForm() {
      const set = (id, v) => { const el = document.getElementById(id); if (el) el.value = v; };
      set("signupFullName", "");
      set("signupDob", "");
      set("signupPhone", "");
      set("signupLogin", "");
      set("signupPassword", "");
      const err = document.getElementById("signupError");
      if (err) err.textContent = "";
      const btn = document.getElementById("signupBtn");
      if (btn) btn.disabled = false;
    }

    async function doSignup() {
      const fullName = (document.getElementById("signupFullName")?.value || "").trim();
      const dob = (document.getElementById("signupDob")?.value || "").trim();
      const phone = (document.getElementById("signupPhone")?.value || "").trim();
      const login = (document.getElementById("signupLogin")?.value || "").trim();
      const password = (document.getElementById("signupPassword")?.value || "").trim();

      const errEl = document.getElementById("signupError");
      const btn = document.getElementById("signupBtn");

      const missing = [];
      if (!fullName) missing.push("Nome completo");
      if (!phone) missing.push("Telefone");
      if (!login) missing.push("CPF (Login)");
      if (!password) missing.push("Senha");

      if (missing.length) {
        if (errEl) errEl.textContent = "Preencha: " + missing.join(", ") + ".";
        return;
      }

      if (errEl) errEl.textContent = "Cadastrando.";
      if (btn) btn.disabled = true;

      try {
        const resp = await nativeFetch(BACKEND_URL + "/api/auth/signup", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ fullName, dob, phone, login, password })
        });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) {
          if (errEl) errEl.textContent = data.error || "Falha ao cadastrar.";
          return;
        }

        // Volta para o login e orienta o próximo passo
        showLogin();
        const lf = document.getElementById("loginField");
        if (lf) lf.value = login;
        const pf = document.getElementById("passwordField");
        if (pf) pf.value = "";
        const loginErr = document.getElementById("loginError");
        if (loginErr) loginErr.textContent = "Cadastro realizado. Para liberar o acesso, regularize com o administrador e, depois, faça login.";
        resetSignupForm();
      } catch (e) {
        if (errEl) errEl.textContent = "Falha ao conectar no servidor.";
      } finally {
        if (btn) btn.disabled = false;
      }
    }

    async function logoutAll() {
      try {
        await fetch(BACKEND_URL + "/api/auth/logout", { method: "POST" });
      } catch {}
      setToken("");
      showLogin();
    }

// Heartbeat para status online
    let heartbeatTimer = null;
    function startHeartbeat() {
      if (heartbeatTimer) clearInterval(heartbeatTimer);
      const ping = async () => {
        try {
          await fetch(BACKEND_URL + "/api/auth/heartbeat", { method: "POST" });
        } catch {}
      };
      ping();
      heartbeatTimer = setInterval(ping, 30000);
    }

    async function restoreSession() {
      const token = getToken();
      if (!token) { showLogin(); return; }
      try {
        const me = await authMe();
        if (me && me.role === "admin") {
          showAdmin();
          startHeartbeat();
          await adminLoadAll();
          updateAdminLocalBackupBadge();
          await refreshLocalBackupFromServer();
        } else if (me && me.role === "nurse") {
          showNurse();
          startHeartbeat();
          updateNurseBar(me);
        } else {
          showLogin();
        }
      } catch (e) {
        showLogin();
      }
    }

    function updateNurseBar(me) {
      // Aceita tanto o formato {role, user:{...}} quanto formato "achatado"
      const u = (me && me.user && typeof me.user === "object") ? me.user : (me || {});
      const name = (u.fullName || u.login || "-");
      const login = (u.login || "-");
      const paidFlag = (u.isPaidThisMonth !== undefined) ? !!u.isPaidThisMonth
        : (u.paidCurrentMonth !== undefined) ? !!u.paidCurrentMonth
        : (me && me.isPaidThisMonth !== undefined) ? !!me.isPaidThisMonth
        : (me && me.paidCurrentMonth !== undefined) ? !!me.paidCurrentMonth
        : false;

      const paidCurrentMonth = (u.paidCurrentMonth !== undefined) ? !!u.paidCurrentMonth
        : (me && me.paidCurrentMonth !== undefined) ? !!me.paidCurrentMonth
        : false;

      const isTrialActive = (u.isTrialActive !== undefined) ? !!u.isTrialActive
        : (me && me.isTrialActive !== undefined) ? !!me.isTrialActive
        : false;

      const trialEndsAt = (u.trialEndsAt || (me && me.trialEndsAt) || "");
      const trialDaysLeft = Number((u.trialDaysLeft !== undefined) ? u.trialDaysLeft : (me && me.trialDaysLeft !== undefined) ? me.trialDaysLeft : 0) || 0;

      const month = (me && me.currentMonth) ? me.currentMonth : (u.currentMonth || "");
      const lbl = document.getElementById("nurseUserLabel");
      const lblLogin = document.getElementById("nurseLoginLabel");
      const pay = document.getElementById("nursePaymentLabel");

      if (lbl) lbl.textContent = name;
      if (lblLogin) lblLogin.textContent = login;

      if (pay) {
        if (paidFlag && isTrialActive && !paidCurrentMonth) {
          let endStr = "";
          try {
            if (trialEndsAt) endStr = formatDatePt(new Date(trialEndsAt));
          } catch {}
          const extra = (endStr ? (" até " + endStr) : "") + (trialDaysLeft ? (" (" + trialDaysLeft + " dias)") : "");
          pay.textContent = "Teste gratuito" + extra;
        } else {
          pay.textContent = paidFlag ? ("Em dia" + (month ? " (" + month + ")" : "")) : ("Em atraso" + (month ? " (" + month + ")" : ""));
        }
        pay.classList.remove("green","red");
        pay.classList.add(paidFlag ? "green" : "red");
      }
    }

    // Eventos de login/logout
    document.getElementById("loginBtn")?.addEventListener("click", doLogin);
    document.getElementById("loginField")?.addEventListener("keydown", (e) => { if (e.key === "Enter") doLogin(); });
    document.getElementById("passwordField")?.addEventListener("keydown", (e) => { if (e.key === "Enter") doLogin(); });
    document.getElementById("openSignupBtn")?.addEventListener("click", () => {
      resetSignupForm();
      showSignup();
    });
    document.getElementById("signupBackBtn")?.addEventListener("click", () => {
      showLogin();
    });
    document.getElementById("signupBtn")?.addEventListener("click", doSignup);
    document.getElementById("signupPassword")?.addEventListener("keydown", (e) => { if (e.key === "Enter") doSignup(); });
    document.getElementById("nurseLogoutBtn")?.addEventListener("click", logoutAll);
    document.getElementById("adminLogoutBtn")?.addEventListener("click", logoutAll);

    // ============================
    // Subusuários (Adicionar amigo) + Pagamento (cliente)
    // ============================

    function openAddFriendModal() {
      document.getElementById("addFriendModal")?.classList.remove("hidden");
      const err = document.getElementById("addFriendError");
      if (err) err.textContent = "";
      const fields = ["friendFullName","friendDob","friendPhone","friendLogin","friendPassword"];
      for (const id of fields) {
        const el = document.getElementById(id);
        if (el) el.value = "";
      }
    }

    function closeAddFriendModal() {
      document.getElementById("addFriendModal")?.classList.add("hidden");
    }

    function openClientBillingModal() {
      document.getElementById("clientBillingModal")?.classList.remove("hidden");
      loadClientBilling();
    }

    function closeClientBillingModal() {
      document.getElementById("clientBillingModal")?.classList.add("hidden");
    }

    function moneyBRL(v) {
      const n = Number(v);
      if (!Number.isFinite(n)) return "R$ 0,00";
      return n.toLocaleString("pt-BR", { style: "currency", currency: "BRL" });
    }

    async function saveFriend() {
      const fullName = (document.getElementById("friendFullName")?.value || "").trim();
      const dob = (document.getElementById("friendDob")?.value || "").trim();
      const phone = (document.getElementById("friendPhone")?.value || "").trim();
      const login = (document.getElementById("friendLogin")?.value || "").trim();
      const password = (document.getElementById("friendPassword")?.value || "").trim();
      const err = document.getElementById("addFriendError");
      const btn = document.getElementById("saveFriendBtn");

      if (err) err.textContent = "";
      const missing = [];
      if (!fullName) missing.push("Nome completo");
      if (!phone) missing.push("Telefone");
      if (!login) missing.push("CPF (Login)");
      if (!password) missing.push("Senha");
      if (missing.length) {
        if (err) err.textContent = "Preencha: " + missing.join(", ") + ".";
        return;
      }

      if (btn) btn.disabled = true;

      try {
        const resp = await fetch(BACKEND_URL + "/api/client/friends", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ fullName, dob, phone, login, password })
        });

        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) {
          if (err) err.textContent = data?.error || "Não foi possível cadastrar o subusuário.";
          return;
        }

        closeAddFriendModal();
        // Atualiza modal de pagamento se estiver aberto
        if (!document.getElementById("clientBillingModal")?.classList.contains("hidden")) {
          loadClientBilling();
        }
      } catch (e) {
        if (err) err.textContent = "Erro ao cadastrar. Tente novamente.";
      } finally {
        if (btn) btn.disabled = false;
      }
    }

    async function loadClientBilling() {
      const statusEl = document.getElementById("clientBillingStatus");
      const listEl = document.getElementById("clientFriendsList");
      const amountsEl = document.getElementById("clientBillingAmounts");
      const hintEl = document.getElementById("clientBillingHint");

      if (statusEl) statusEl.textContent = "Carregando...";
      if (listEl) listEl.innerHTML = "";
      if (amountsEl) amountsEl.textContent = "";
      if (hintEl) hintEl.textContent = "";

      try {
        const resp = await fetch(BACKEND_URL + "/api/client/billing", { method: "GET" });
        const data = await resp.json().catch(() => ({}));

        if (!resp.ok) {
          if (statusEl) statusEl.textContent = data?.error || "Não foi possível carregar os dados de pagamento.";
          return;
        }

        const friends = Array.isArray(data?.friends) ? data.friends : [];
        const eligible = !!data?.eligibleDiscount;
        const discountPercent = Number(data?.discountPercent || 0);

        const isTrialActive = !!data?.isTrialActive;
        const trialEndsAt = String(data?.trialEndsAt || "");
        const trialDaysLeft = Number(data?.trialDaysLeft || 0) || 0;

        if (statusEl) {
          if (isTrialActive) {
            let endStr = "";
            try {
              if (trialEndsAt) endStr = formatDatePt(new Date(trialEndsAt));
            } catch {}
            statusEl.textContent = "Teste gratuito ativo" + (endStr ? (" até " + endStr) : "") + (trialDaysLeft ? (" (" + trialDaysLeft + " dias restantes)") : ".");
          } else {
            statusEl.textContent = eligible
              ? ("Desconto aplicado: " + discountPercent + "%")
              : "Sem desconto: mensalidade em débito (pagamento do mês atual não identificado).";
          }
        }

        if (listEl) {
          if (!friends.length) {
            listEl.innerHTML = '<div class="simple-list-item">Nenhum subusuário cadastrado.</div>';
          } else {
            listEl.innerHTML = friends.map(f => {
              const name = (f.fullName || f.login || "-");
              const login = (f.login || "-");
              const createdAt = (f.createdAt || "");
              const line2 = createdAt ? ("Cadastrado em: " + createdAt) : "";
              const status = eligible ? "Desconto ativo" : "Desconto inativo";
              return '<div class="simple-list-item"><div><strong>' + escapeHtml(name) + '</strong> <span class="muted">(' + escapeHtml(login) + ')</span></div><div class="muted">' + escapeHtml(status) + (line2 ? " | " + escapeHtml(line2) : "") + '</div></div>';
            }).join("");
          }
        }

        const base = data?.base || {};
        const final = data?.final || {};
        if (amountsEl) {
          const txt = [
            "Mensal: " + moneyBRL(final.monthly),
            "Anual: " + moneyBRL(final.annual),
            "",
            "Valor base mensal: " + moneyBRL(base.monthly) + " | Valor base anual: " + moneyBRL(base.annual)
          ].join("\n");
          amountsEl.textContent = txt;
        }

        const setPayBtn = (id, label, amount, plan) => {
          const b = document.getElementById(id);
          if (!b) return;

          b.onclick = async () => {
            // Evita múltiplos cliques
            const btns = ["payMonthlyBtn","payAnnualBtn"].map(x => document.getElementById(x)).filter(Boolean);
            for (const x of btns) x.disabled = true;

            if (hintEl) hintEl.textContent = "Abrindo checkout de pagamento...";

            try {
              const resp2 = await fetch(BACKEND_URL + "/api/client/infinitepay/checkout-link", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ plan })
              });
              const out2 = await resp2.json().catch(() => ({}));

              if (!resp2.ok || !out2?.checkout_url) {
                const msg = out2?.error || "Não foi possível gerar o link de pagamento.";
                alert(msg);
                return;
              }

              if (hintEl) hintEl.textContent = label + " - Valor: " + moneyBRL(amount) + ". Você será direcionado para o checkout.";

              window.location.href = out2.checkout_url;
            } catch (e) {
              alert("Falha ao iniciar pagamento. Tente novamente.");
            } finally {
              for (const x of btns) x.disabled = false;
            }
          };
        };

        // Botões (sem distinção PIX/Cartão)
        setPayBtn("payMonthlyBtn", "Pagamento mensal", final.monthly, "monthly");
        setPayBtn("payAnnualBtn", "Pagamento anual", final.annual, "annual");

        if (hintEl) {
          hintEl.textContent = "Regras: cada subusuário cadastrado gera 25% de desconto, limitado a 100%, desde que a mensalidade do mês atual esteja em dia.";
        }
      } catch (e) {
        if (statusEl) statusEl.textContent = "Erro ao carregar os dados.";
      }
    }

    document.getElementById("addFriendBtn")?.addEventListener("click", openAddFriendModal);
    document.getElementById("closeAddFriendModalBtn")?.addEventListener("click", closeAddFriendModal);
    document.getElementById("saveFriendBtn")?.addEventListener("click", saveFriend);

    document.getElementById("openClientBillingBtn")?.addEventListener("click", openClientBillingModal);
    document.getElementById("closeClientBillingModalBtn")?.addEventListener("click", closeClientBillingModal);



    let recognition;
    let isRecording = false;
    let isPaused = false;
    let finalTranscript = "";
    let baseTranscript = "";
    let baseTranscriptRaw = "";
    let timerInterval = null;
    let startTime = null;
    let accumulatedSeconds = 0;
    let currentSoapRaw = "";

    // ============================
    // ============================
    // MÓDULO: Perguntas e procedimentos essenciais em tempo real (FLUXO CONTROLADO)
    // ============================
    let interimTranscript = "";

    // Fluxo: aguarda motivo -> gera até 3 perguntas -> enfermeiro marca pergunta feita -> aguarda resposta -> atualiza
    let guidanceEnabled = false;
    let guidanceStage = "aguardando_motivo"; // "aguardando_motivo" | "perguntas"
    let guidancePending = []; // array de strings
    let guidanceContextLabel = "";
    let guidanceHypothesis = "";
    let guidanceConfidence = 0; // 0..95

    let guidanceInFlight = false;
    let guidanceAskedQuestion = "";
    let guidanceAskedAtLen = 0;
    let guidanceAskedAtTs = 0;
    let guidanceAnswerDebounce = null;
    let guidanceLastPayloadHash = "";
    let guidanceTurnState = "aguardando_pergunta"; // "aguardando_pergunta" | "aguardando_resposta"
    let guidanceChunkStartLen = 0;
    let guidanceSilenceTimer = null;
    let guidanceLastChunkTs = 0;

    // ============================
    // MÓDULO: Triagem hospitalar (gravação + guia em tempo real)
    // ============================
    let triageRecognition = null;
    let triageIsRecording = false;
    let triageIsPaused = false;
    let triageFinalTranscript = "";
    let triageInterimTranscript = "";

    let triageStartTime = null;
    let triageAccumulatedSeconds = 0;
    let triageTimerInterval = null;

    // Guia em tempo real da triagem (até 3 itens por vez)
    let triageGuidanceEnabled = false;
    let triageGuidanceStage = "aguardando_motivo";
    let triageGuidancePending = [];
    let triageGuidanceContextLabel = "";
    let triageGuidanceHypothesis = "";
    let triageGuidanceConfidence = 0;

    let triageGuidanceInFlight = false;
    let triageGuidanceAskedQuestion = "";
    let triageGuidanceAskedAtLen = 0;
    let triageGuidanceAskedAtTs = 0;
    let triageGuidanceLastPayloadHash = "";
    let triageGuidanceTurnState = "aguardando_pergunta";
    let triageGuidanceChunkStartLen = 0;
    let triageGuidanceSilenceTimer = null;
    let triageGuidanceLastChunkTs = 0;


    // ============================
    // MÓDULO: Passagem de plantão (gravação + geração de texto)
    // ============================
    let handoffRecognition = null;
    let handoffIsRecording = false;
    let handoffIsPaused = false;
    let handoffFinalTranscript = "";
    let handoffInterimTranscript = "";

    let handoffStartTime = null;
    let handoffAccumulatedSeconds = 0;
    let handoffTimerInterval = null;

    // Guia em tempo real da passagem de plantão (SBAR - até 3 sugestões por vez)
    let handoffGuidanceEnabled = false;
    let handoffGuidanceStage = "sbar"; // "sbar"
    let handoffGuidancePending = [];
    let handoffGuidanceContextLabel = "";
    let handoffGuidanceHypothesis = "";
    let handoffGuidanceConfidence = 0;

    let handoffGuidanceInFlight = false;
    let handoffGuidanceLastPayloadHash = "";
    let handoffGuidanceChunkStartLen = 0;
    let handoffGuidanceSilenceTimer = null;
    let handoffGuidanceLastChunkTs = 0;


    // ============================
    // MÓDULO: Documentos (gravação + geração de documento)
    // ============================
    let docsRecognition = null;
    let docsIsRecording = false;
    let docsIsPaused = false;
    let docsFinalTranscript = "";
    let docsInterimTranscript = "";

    let docsStartTime = null;
    let docsAccumulatedSeconds = 0;
    let docsTimerInterval = null;

    // Guia em tempo real do módulo de documentos (tipo + até 3 perguntas)
    let docsGuidanceInterval = null;
    let docsGuidanceInFlight = false;
    let docsGuidanceLastHash = "";
    let docsLastGeneratedDocument = "";

const recordBtn = document.getElementById("recordBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const timerEl = document.getElementById("timer");
    const micStatus = document.getElementById("micStatus");
    const resultsCard = document.getElementById("resultsCard");
    const soapResultsMount = document.getElementById("soapResultsMount");
    const triageResultsMount = document.getElementById("triageResultsMount");
    const docsResultsMount = document.getElementById("docsResultsMount");
    const handoffResultsMount = document.getElementById("handoffResultsMount");

    function mountResultsCard(mountEl) {
      if (!resultsCard || !mountEl) return;
      if (resultsCard.parentElement !== mountEl) {
        mountEl.appendChild(resultsCard);
      }
    }

    mountResultsCard(soapResultsMount);

    const soapError = document.getElementById("soapError");
    const soapNursingResultsPanel = document.getElementById("soapNursingResultsPanel");

    function setResultsView(view) {
      const v = String(view || "").toLowerCase();

      const triageMode = (v === "triage" || v === "triagem" || v === "triagem_hospitalar");
      const handoffMode = (v === "handoff" || v === "passagem" || v === "sbar");
      const docsMode = (v === "docs" || v === "documentos");
      const consultMode = (!triageMode && !handoffMode && !docsMode);

      const patientInfoPanelEl = document.getElementById("patientInfoPanel");
      const triageReportPanelEl = document.getElementById("triageReportPanel");
      const handoffPanelEl = document.getElementById("handoffPanel");
      const soapNursingPanelEl = document.getElementById("soapNursingResultsPanel");

      if (patientInfoPanelEl) patientInfoPanelEl.classList.toggle("hidden", triageMode || handoffMode || docsMode);

      if (triageReportPanelEl) triageReportPanelEl.classList.toggle("hidden", !triageMode);
      if (handoffPanelEl) handoffPanelEl.classList.toggle("hidden", !handoffMode);

      if (soapNursingPanelEl) soapNursingPanelEl.classList.toggle("hidden", !consultMode);

      const moduleCards = document.querySelectorAll(".module-card");
      if (moduleCards && moduleCards.length) {
        moduleCards.forEach((el) => {
          if (!el) return;
          el.classList.toggle("hidden", triageMode);
        });
      }
    }

    function isTriageOnlyUrlMode() {
      try {
        const u = new URL(window.location.href);
        const p = u.searchParams;
        const modo = String(p.get("modo") || p.get("mode") || "").toLowerCase();
        const triagem = String(p.get("triagem") || p.get("triage") || "").toLowerCase();
        const hash = String(u.hash || "").toLowerCase();

        if (modo === "triagem" || modo === "triagem_hospitalar" || modo === "triage") return true;
        if (triagem === "1" || triagem === "true" || triagem === "on") return true;
        if (hash.includes("triagem") || hash.includes("triage")) return true;
      } catch (e) {}
      return false;
    }

    function applyTriageOnlyLayout(enable) {
      const on = Boolean(enable);

      // Esconde módulos que não pertencem à triagem
      const hideIds = [
        "consultTypePanel",
        "liveGuidance",
        "recordBtn",
        "startNotice",
        "timer",
        "micStatus",
        "pauseBtn",
        "pauseLabel",
        "finishHint",
        "soapError",
        "soapResultsMount",

        "docsGuideBtn",
        "docsRecordBtn",
        "docsTimer",
        "docsMicStatus",
        "docsPauseBtn",
        "docsPauseLabel",
        "docsFinishHint",
        "docsError",
        "docsResultsMount"
      ];

      hideIds.forEach((id) => {
        const el = document.getElementById(id);
        if (!el) return;
        el.classList.toggle("hidden", on);
      });

      // Alguns controles estão em wrappers sem id
      const controlsRows = document.querySelectorAll(".controls-row");
      if (controlsRows && controlsRows.length) {
        controlsRows.forEach((row) => {
          // Mantém os controles da triagem visíveis
          const triagePauseEl = document.getElementById("triagePauseBtn");
          if (row && triagePauseEl && row.contains(triagePauseEl)) return;
          row.classList.toggle("hidden", on);
        });
      }

      // Em triagem-only, garante que os resultados exibam apenas triagem
      if (on) {
        setResultsView("triage");
      }
    }

    // Ativa triagem-only automaticamente quando a URL indicar
    if (isTriageOnlyUrlMode()) {
      applyTriageOnlyLayout(true);
    }

    const printBtn = document.getElementById("printBtn");

    const triageRecordBtn = document.getElementById("triageRecordBtn");
    const triagePauseBtn = document.getElementById("triagePauseBtn");
    const triageTimerEl = document.getElementById("triageTimer");
    const triageMicStatus = document.getElementById("triageMicStatus");
    const triageError = document.getElementById("triageError");


    const handoffRecordBtn = document.getElementById("handoffRecordBtn");
    const handoffPauseBtn = document.getElementById("handoffPauseBtn");
    const handoffTimerEl = document.getElementById("handoffTimer");
    const handoffMicStatus = document.getElementById("handoffMicStatus");
    const handoffError = document.getElementById("handoffError");

    const docsRecordBtn = document.getElementById("docsRecordBtn");
    const docsPauseBtn = document.getElementById("docsPauseBtn");
    const docsTimerEl = document.getElementById("docsTimer");
    const docsMicStatus = document.getElementById("docsMicStatus");
    const docsError = document.getElementById("docsError");

    const docsGuideBtn = document.getElementById("docsGuideBtn");
    const docsGuidePanel = document.getElementById("docsGuidePanel");
    const closeDocsGuideBtn = document.getElementById("closeDocsGuideBtn");

    const patientReportCard = document.getElementById("patientReportCard");

    const handoffPanel = document.getElementById("handoffPanel");
    const handoffOutput = document.getElementById("handoffOutput");
    const handoffStatus = document.getElementById("handoffStatus");
    const handoffCopyBtn = document.getElementById("handoffCopyBtn");
    const handoffPrintBtn = document.getElementById("handoffPrintBtn");

    const handoffGuideBtn = document.getElementById("handoffGuideBtn");
    const handoffGuidePanel = document.getElementById("handoffGuidePanel");
    const closeHandoffGuideBtn = document.getElementById("closeHandoffGuideBtn");
    const aprazamentoGuideBtn = document.getElementById("aprazamentoGuideBtn");
    const aprazamentoGuidePanel = document.getElementById("aprazamentoGuidePanel");
    const closeAprazamentoGuideBtn = document.getElementById("closeAprazamentoGuideBtn");

    const aprazamentoStatus = document.getElementById("aprazamentoStatus");
    const aprazamentoSheetWrapper = document.getElementById("aprazamentoSheetWrapper");
    const copyAprazamentoBtn = document.getElementById("copyAprazamentoBtn");
    const printAprazamentoBtn = document.getElementById("printAprazamentoBtn");
    const printAprazGridBtn = document.getElementById("printAprazGridBtn");
    const aprazamentoCameraInput = document.getElementById("aprazamentoCameraInput");
    const aprazamentoFileInput = document.getElementById("aprazamentoFileInput");
    const aprazOriginalDetails = document.getElementById("aprazOriginalDetails");
    const aprazOriginalImages = document.getElementById("aprazOriginalImages");


    const woundGuideBtn = document.getElementById("woundGuideBtn");
    const woundGuidePanel = document.getElementById("woundGuidePanel");
    const closeWoundGuideBtn = document.getElementById("closeWoundGuideBtn");

    const examGuideBtn = document.getElementById("examGuideBtn");
    const examGuidePanel = document.getElementById("examGuidePanel");
    const closeExamGuideBtn = document.getElementById("closeExamGuideBtn");

    const medicalDoubtsGuideBtn = document.getElementById("medicalDoubtsGuideBtn");
    const medicalDoubtsGuidePanel = document.getElementById("medicalDoubtsGuidePanel");
    const closeMedicalDoubtsGuideBtn = document.getElementById("closeMedicalDoubtsGuideBtn");

    const calculatorsGuideBtn = document.getElementById("calculatorsGuideBtn");
    const calculatorsGuidePanel = document.getElementById("calculatorsGuidePanel");
    const closeCalculatorsGuideBtn = document.getElementById("closeCalculatorsGuideBtn");



    const triageLiveGuidance = document.getElementById("triageLiveGuidance");
    const triageLiveGuidanceContext = document.getElementById("triageLiveGuidanceContext");
    const triageLiveGuidanceStatus = document.getElementById("triageLiveGuidanceStatus");
    const triageLiveGuidanceList = document.getElementById("triageLiveGuidanceList");


    const handoffLiveGuidance = document.getElementById("handoffLiveGuidance");
    const handoffLiveGuidanceContext = document.getElementById("handoffLiveGuidanceContext");
    const handoffLiveGuidanceStatus = document.getElementById("handoffLiveGuidanceStatus");
    const handoffLiveGuidanceList = document.getElementById("handoffLiveGuidanceList");

    const docsLiveGuidance = document.getElementById("docsLiveGuidance");
    const docsLiveGuidanceContext = document.getElementById("docsLiveGuidanceContext");
    const docsLiveGuidanceStatus = document.getElementById("docsLiveGuidanceStatus");
    const docsLiveGuidanceList = document.getElementById("docsLiveGuidanceList");

    const triageReportPanel = document.getElementById("triageReportPanel");
    const triageRiskBadge = document.getElementById("triageRiskBadge");
    const triageRiskMeaning = document.getElementById("triageRiskMeaning");
    const triageRiskLegend = document.getElementById("triageRiskLegend");

    const triageProntuario = document.getElementById("triageProntuario");
    const triagePassagemMedico = document.getElementById("triagePassagemMedico");
    const triageAlertas = document.getElementById("triageAlertas");
    const triageCondutasNaoMed = document.getElementById("triageCondutasNaoMed");
    const triageCondutasMed = document.getElementById("triageCondutasMed");
    const triageMedidasExames = document.getElementById("triageMedidasExames");
    const triagePendencias = document.getElementById("triagePendencias");
    const triageQualidade = document.getElementById("triageQualidade");
    const triageFullReport = document.getElementById("triageFullReport");
    const triageReportStatus = document.getElementById("triageReportStatus");

    const triageCopyFullBtn = document.getElementById("triageCopyFullBtn");
    const triagePrintFullBtn = document.getElementById("triagePrintFullBtn");
    const triageCopyProntuarioBtn = document.getElementById("triageCopyProntuarioBtn");
    const triagePrintProntuarioBtn = document.getElementById("triagePrintProntuarioBtn");
    const triageCopyPassagemBtn = document.getElementById("triageCopyPassagemBtn");
    const triagePrintPassagemBtn = document.getElementById("triagePrintPassagemBtn");

    const liveGuidance = document.getElementById("liveGuidance");
    const liveGuidanceContext = document.getElementById("liveGuidanceContext");
    const liveGuidanceStatus = document.getElementById("liveGuidanceStatus");
    const liveGuidanceList = document.getElementById("liveGuidanceList");

    const soapS = document.getElementById("soapS");
    const soapO = document.getElementById("soapO");
    const soapA = document.getElementById("soapA");
    const soapP = document.getElementById("soapP");

    const nursingEvolutionOutput = document.getElementById("nursingEvolutionOutput");

    const copyNursingEvolutionBtn = document.getElementById("copyNursingEvolutionBtn");
    const printNursingEvolutionBtn = document.getElementById("printNursingEvolutionBtn");

    const prescriptionOutput = document.getElementById("prescriptionOutput");

    const sbarOutput = document.getElementById("sbarOutput");
    const sbarRecordBtn = document.getElementById("sbarRecordBtn");
    const copySbarBtn = document.getElementById("copySbarBtn");
    const printSbarBtn = document.getElementById("printSbarBtn");
    const sbarStatus = document.getElementById("sbarStatus");
    const sbarTimer = document.getElementById("sbarTimer");
    const openSbarGuideBtn = document.getElementById("openSbarGuideBtn");
    const sbarGuidePanel = document.getElementById("sbarGuidePanel");


    const pregnancyBox = document.getElementById("pregnancyBox");
    const lactationBox = document.getElementById("lactationBox");

    const riskTriageBadge = document.getElementById("riskTriageBadge");
    const riskTriageMeaning = document.getElementById("riskTriageMeaning");
    const riskTriageLegend = document.getElementById("riskTriageLegend");
    const copyRiskTriageBtn = document.getElementById("copyRiskTriageBtn");
    const printRiskTriageBtn = document.getElementById("printRiskTriageBtn");
    const riskTriageStatus = document.getElementById("riskTriageStatus");

    const copySaeBtn = document.getElementById("copySaeBtn");
    const classificationsStatus = document.getElementById("classificationsStatus");
    const printPregnancyBtn = document.getElementById("printPregnancyBtn");
    const printLactationBtn = document.getElementById("printLactationBtn");

    const recommendationsBtn = document.getElementById("recommendationsBtn");
    const recommendationsPanel = document.getElementById("recommendationsPanel");
    const closeRecommendationsBtn = document.getElementById("closeRecommendationsBtn");
    const recommendationsStatus = document.getElementById("recommendationsStatus");
    const recommendationsList = document.getElementById("recommendationsList");
    const askQuestionsBtn = document.getElementById("askQuestionsBtn");
    const questionsTimerEl = document.getElementById("questionsTimer");

    const soapCopyButtons = document.querySelectorAll(".copy-soap-btn");
    const copyPrescriptionBtn = document.getElementById("copyPrescriptionBtn");

    const copyFullSoapBtn = document.getElementById("copyFullSoapBtn");
    const printSoapBtn = document.getElementById("printSoapBtn");

    // Monografia/Informações do medicamento (overlay)
    // Algumas telas podem não ter esses elementos; por isso tudo é opcional e sempre checado antes do uso.
    const medMonographOverlay = document.getElementById("medMonographOverlay");
    const medMonographContent = document.getElementById("medMonographContent");
    const copyMedMonographBtn = document.getElementById("copyMedMonographBtn");
    const closeMedMonographBtn = document.getElementById("closeMedMonographBtn");

    const medicalDoubtInput = document.getElementById("medicalDoubtInput");
    const medicalDoubtStatus = document.getElementById("medicalDoubtStatus");
    const medicalDoubtAnswer = document.getElementById("medicalDoubtAnswer");
    const medicalDoubtSendBtn = document.getElementById("medicalDoubtSendBtn");
    const healthEduTheme = document.getElementById("healthEduTheme");
    const healthEduDuration = document.getElementById("healthEduDuration");
    const healthEduDownloadBtn = document.getElementById("healthEduDownloadBtn");
    const healthEduStatus = document.getElementById("healthEduStatus");



    const woundPhotoBtn = document.getElementById("woundPhotoBtn");
    const woundFileBtn = document.getElementById("woundFileBtn");
const presentationsMaxDoseBox = document.getElementById("presentationsMaxDoseBox");
    const presentationsMaxDoseStatus = document.getElementById("presentationsMaxDoseStatus");
    const copyWoundBtn = document.getElementById("copyWoundBtn");
    const printWoundBtn = document.getElementById("printWoundBtn");
    const woundCameraInput = document.getElementById("woundCameraInput");
    const woundFileInput = document.getElementById("woundFileInput");

        const examInterpretationBox = document.getElementById("examInterpretationBox");
    const examInterpretationStatus = document.getElementById("examInterpretationStatus");
    const copyExamBtn = document.getElementById("copyExamBtn");
    const printExamBtn = document.getElementById("printExamBtn");
    const examCameraInput = document.getElementById("examCameraInput");
    const examFileInput = document.getElementById("examFileInput");

    const transcriptionBox = document.getElementById("transcriptionBox");
    const transcriptionStatus = document.getElementById("transcriptionStatus");
    const copyTranscriptionBtn = document.getElementById("copyTranscriptionBtn");
    const printTranscriptionBtn = document.getElementById("printTranscriptionBtn");
    const transcriptionCameraInput = document.getElementById("transcriptionCameraInput");
    const transcriptionFileInput = document.getElementById("transcriptionFileInput");

    const rxEvalStatus = document.getElementById("rxEvalStatus");
    const rxEvalTranscription = document.getElementById("rxEvalTranscription");
    const rxEvalDetails = document.getElementById("rxEvalDetails");
    const rxEvalMedsCount = document.getElementById("rxEvalMedsCount");
    const rxEvalMedsButtons = document.getElementById("rxEvalMedsButtons");
    const rxEvalCopyTranscriptionBtn = document.getElementById("rxEvalCopyTranscriptionBtn");
    const rxEvalPrintTranscriptionBtn = document.getElementById("rxEvalPrintTranscriptionBtn");
    const rxEvalCopyDetailsBtn = document.getElementById("rxEvalCopyDetailsBtn");
    const rxEvalPrintDetailsBtn = document.getElementById("rxEvalPrintDetailsBtn");
    const rxEvalCameraInput = document.getElementById("rxEvalCameraInput");
    const rxEvalFileInput = document.getElementById("rxEvalFileInput");

    
    const rxEvalResults = document.getElementById("rxEvalResults");
const rxEvalGuideBtn = document.getElementById("rxEvalGuideBtn");
    const rxEvalGuidePanel = document.getElementById("rxEvalGuidePanel");
    const closeRxEvalGuideBtn = document.getElementById("closeRxEvalGuideBtn");


    const transcriptionGuideBtn = document.getElementById("transcriptionGuideBtn");
    const transcriptionGuidePanel = document.getElementById("transcriptionGuidePanel");
    const closeTranscriptionGuideBtn = document.getElementById("closeTranscriptionGuideBtn");

const imageChoiceOverlay = document.getElementById("imageChoiceOverlay");
    const chooseCameraBtn = document.getElementById("chooseCameraBtn");
    const chooseFileBtn = document.getElementById("chooseFileBtn");
    const cancelImageChoiceBtn = document.getElementById("cancelImageChoiceBtn");

    const runImageAnalysisBtn = document.getElementById("runImageAnalysisBtn");
    const clearChosenImagesBtn = document.getElementById("clearChosenImagesBtn");
    const imageChoicePreview = document.getElementById("imageChoicePreview");
    const imageChoiceCount = document.getElementById("imageChoiceCount");
    const imageChoiceTitle = document.getElementById("imageChoiceTitle");
    const imageChoiceHint = document.getElementById("imageChoiceHint");

    let pendingCameraInput = null;
    let pendingFileInput = null;

    let pendingImages = [];
    let pendingAnalysisFn = null;
    let pendingOverlayTitle = "";
    let pendingOverlayHint = "";

    // ============================
    // VISIBILIDADE – botões de copiar/imprimir (foto/áudio)
    // ============================
    function setVisible(el, visible) {
      if (!el) return;
      if (visible) el.classList.remove("hidden");
      else el.classList.add("hidden");
    }
    

    function isMeaningfulText(t) {
      const s = String(t || "").trim();
      if (!s) return false;
      const low = s.toLowerCase();
      if (low === "nenhum conteúdo disponível." || low === "nenhum conteudo disponivel.") return false;
      if (low === "processando." || low === "processando") return false;
      return true;
    }

    

    function updateWoundActions() {
      const has = isMeaningfulText(presentationsMaxDoseBox ? presentationsMaxDoseBox.textContent : "");
      setVisible(copyWoundBtn, has);
      setVisible(printWoundBtn, has);
    }

    function updateExamActions() {
      const has = isMeaningfulText(examInterpretationBox ? examInterpretationBox.textContent : "");
      setVisible(copyExamBtn, has);
      setVisible(printExamBtn, has);
    }

    function updateTranscriptionActions() {
      const has = isMeaningfulText(transcriptionBox ? transcriptionBox.textContent : "");
      setVisible(copyTranscriptionBtn, has);
      setVisible(printTranscriptionBtn, has);
    }

    function updateAprazamentoActions() {
      const hasGrid = !!(aprazamentoSheetWrapper && aprazamentoSheetWrapper.querySelector && aprazamentoSheetWrapper.querySelector("#aprazHoursGrid"));
      setVisible(printAprazGridBtn, hasGrid);
    }


    function updateReportActions() {
      const has = isMeaningfulText(reportOutput ? reportOutput.value : "");
      setVisible(copyReportBtn, has);
      setVisible(printReportBtn, has);
    }




    // ============================
    // MÓDULO: Coletar dados essenciais (NOVO)
    // ============================
    const patientInfoBtn = document.getElementById("patientInfoBtn");
    const patientInfoTimerEl = document.getElementById("patientInfoTimer");
    const patientInfoStatus = document.getElementById("patientInfoStatus");
    const patientInfoSummary = document.getElementById("patientInfoSummary");

    let patientContext = { nome: null, idade: null, peso_kg: null };

    let patientInfoRecognition = null;
    let patientInfoIsRecording = false;
    let patientInfoFinalTranscript = "";
    let patientInfoTimerInterval = null;
    let patientInfoStartTime = null;
    let patientInfoAccumulatedSeconds = 0;

    function resetPatientInfoTimer() {
      patientInfoAccumulatedSeconds = 0;
      patientInfoStartTime = null;
      if (patientInfoTimerInterval) clearInterval(patientInfoTimerInterval);
      patientInfoTimerInterval = null;
      if (patientInfoTimerEl) patientInfoTimerEl.textContent = "00:00";
    }

    function updatePatientInfoTimer() {
      const now = Date.now();
      const seconds = patientInfoAccumulatedSeconds + Math.floor((now - patientInfoStartTime) / 1000);
      const m = ("0" + Math.floor(seconds / 60)).slice(-2);
      const s = ("0" + (seconds % 60)).slice(-2);
      if (patientInfoTimerEl) patientInfoTimerEl.textContent = `${m}:${s}`;
    }

    function startPatientInfoTimer() {
      patientInfoStartTime = Date.now();
      if (patientInfoTimerInterval) clearInterval(patientInfoTimerInterval);
      patientInfoTimerInterval = setInterval(updatePatientInfoTimer, 200);
    }

    function stopPatientInfoTimer() {
      if (!patientInfoStartTime) return;
      const now = Date.now();
      patientInfoAccumulatedSeconds += Math.floor((now - patientInfoStartTime) / 1000);
      patientInfoStartTime = null;
      if (patientInfoTimerInterval) clearInterval(patientInfoTimerInterval);
      patientInfoTimerInterval = null;
    }

    function formatPatientSummary(ctx) {
      const parts = [];
      if (ctx?.nome) parts.push(`Nome: ${ctx.nome}`);
      if (ctx?.idade) parts.push(`Idade: ${ctx.idade}`);
      if (ctx?.peso_kg !== null && ctx?.peso_kg !== undefined) parts.push(`Peso: ${ctx.peso_kg} kg`);
      return parts.length ? parts.join(" | ") : "";
    }

    function buildTranscriptWithPatientContext(rawTranscript) {
      let t = String(rawTranscript || "").trim();
      if (!t) return "";

      t = t.replace(/^Dados do paciente:[\s\S]*?\n{2,}/i, "").trim();

      const hasAny = !!(patientContext?.nome || patientContext?.idade || (patientContext?.peso_kg !== null && patientContext?.peso_kg !== undefined));
      if (!hasAny) return t;

      const headerParts = [];
      if (patientContext.nome) headerParts.push(`Nome completo: ${patientContext.nome}.`);
      if (patientContext.idade) headerParts.push(`Idade: ${patientContext.idade}.`);
      if (patientContext.peso_kg !== null && patientContext.peso_kg !== undefined) headerParts.push(`Peso: ${patientContext.peso_kg} kg.`);

      const header = `Dados do paciente: ${headerParts.join(" ")}\n\n`;
      return header + t;
    }

    function initPatientInfoSpeech() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) return false;

      patientInfoRecognition = new SR();
      patientInfoRecognition.lang = "pt-BR";
      patientInfoRecognition.continuous = true;
      patientInfoRecognition.interimResults = true;

      patientInfoRecognition.onresult = (event) => {
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const txt = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            patientInfoFinalTranscript += txt + " ";
          }
        }
      };

      patientInfoRecognition.onerror = (e) => {
        console.warn("Erro no reconhecimento (dados do paciente):", e);
      };

      return true;
    }

    
    function getNursingContext() {
      const t = (baseTranscriptRaw || baseTranscript || finalTranscript || "").trim();
      const s = (soapS?.value || "").trim();
      const o = (soapO?.value || "").trim();
      const a = (soapA?.value || "").trim();
      const p = (soapP?.value || "").trim();
      const plano = (prescriptionOutput?.value || "").trim();
      const sbar = (sbarOutput?.value || "").trim();
      const parts = [];
      if (t) parts.push("TRANSCRIÇÃO:\n" + t);
      if (s || o || a || p) parts.push("EVOLUÇÃO (SOAP):\nS: " + s + "\nO: " + o + "\nA: " + a + "\nP: " + p);
      if (plano) parts.push("PLANO DE CUIDADOS:\n" + plano);
      if (sbar) parts.push("SBAR:\n" + sbar);
      return parts.join("\n\n").trim();
    }

    // ============================
    // MÓDULO: Classificação de risco por cores (NOVO)
    // ============================
    const RISK_LEGEND_DEFAULT = [
      { cor: "Vermelho", significado: "Emergência. Atendimento imediato." },
      { cor: "Laranja", significado: "Muito urgente. Prioridade alta de atendimento." },
      { cor: "Amarelo", significado: "Urgente. Necessita avaliação em curto prazo." },
      { cor: "Verde", significado: "Pouco urgente. Pode aguardar com segurança, mantendo reavaliação se piora." },
      { cor: "Azul", significado: "Não urgente. Caso de baixa gravidade, orientar e agendar conforme necessidade." }
    ];

    function normalizeRiskColorLabel(label) {
      const t = String(label || "").trim().toLowerCase();
      if (!t) return "Não informado";
      if (t.includes("vermelh")) return "Vermelho";
      if (t.includes("laranj")) return "Laranja";
      if (t.includes("amarel")) return "Amarelo";
      if (t.includes("verd")) return "Verde";
      if (t.includes("azul")) return "Azul";
      if (t.includes("nao informado") || t.includes("não informado") || t.includes("indefin")) return "Não informado";
      return label.trim();
    }

    function applyRiskBadgeColor(cor) {
      if (!riskTriageBadge) return;
      riskTriageBadge.classList.remove("risk-none", "risk-vermelho", "risk-laranja", "risk-amarelo", "risk-verde", "risk-azul");
      const c = normalizeRiskColorLabel(cor);
      if (c === "Vermelho") riskTriageBadge.classList.add("risk-vermelho");
      else if (c === "Laranja") riskTriageBadge.classList.add("risk-laranja");
      else if (c === "Amarelo") riskTriageBadge.classList.add("risk-amarelo");
      else if (c === "Verde") riskTriageBadge.classList.add("risk-verde");
      else if (c === "Azul") riskTriageBadge.classList.add("risk-azul");
      else riskTriageBadge.classList.add("risk-none");
    }

    function renderRiskLegend(legendArr) {
      if (!riskTriageLegend) return;
      const legend = Array.isArray(legendArr) && legendArr.length ? legendArr : RISK_LEGEND_DEFAULT;

      riskTriageLegend.innerHTML = "";
      legend.forEach((item) => {
        const cor = normalizeRiskColorLabel(item?.cor || "");
        const significado = String(item?.significado || "").trim();

        const row = document.createElement("div");
        row.className = "risk-legend-row";

        const swatch = document.createElement("div");
        swatch.className = "risk-legend-swatch " + (
          cor === "Vermelho" ? "swatch-vermelho" :
          cor === "Laranja" ? "swatch-laranja" :
          cor === "Amarelo" ? "swatch-amarelo" :
          cor === "Verde" ? "swatch-verde" :
          cor === "Azul" ? "swatch-azul" : ""
        );

        const txt = document.createElement("div");
        txt.style.flex = "1";
        txt.textContent = cor + (significado ? (": " + significado) : "");

        row.appendChild(swatch);
        row.appendChild(txt);
        riskTriageLegend.appendChild(row);
      });
    }

    function buildRiskPrintText(cor, significado, legendArr) {
      const c = normalizeRiskColorLabel(cor);
      const s = String(significado || "").trim();
      const legend = Array.isArray(legendArr) && legendArr.length ? legendArr : RISK_LEGEND_DEFAULT;

      const lines = [];
      lines.push("Classificação de risco: " + c);
      if (s) lines.push("Significado: " + s);
      lines.push("");
      lines.push("Legenda:");
      legend.forEach((it) => {
        const lc = normalizeRiskColorLabel(it?.cor || "");
        const ls = String(it?.significado || "").trim();
        lines.push(lc + ": " + ls);
      });
      return lines.join("\n");
    }

    async function updateRiskTriage() {
      if (!riskTriageStatus) return;

      const contexto = getNursingContext();
      if (!contexto) {
        if (riskTriageBadge) {
          riskTriageBadge.textContent = "Não informado";
          applyRiskBadgeColor("Não informado");
        }
        if (riskTriageMeaning) riskTriageMeaning.textContent = "Nenhum conteúdo disponível.";
        renderRiskLegend(RISK_LEGEND_DEFAULT);
        riskTriageStatus.textContent = "Sem conteúdo suficiente para classificar.";
        return;
      }

      riskTriageStatus.textContent = "Gerando classificação de risco...";
      riskTriageStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/classificacao-risco", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ contexto })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (classificação de risco):", resp.status, txt);
          riskTriageStatus.classList.remove("loading-dot");
          riskTriageStatus.textContent = "Não foi possível gerar a classificação de risco.";
          return;
        }

        const data = await resp.json();

        const cor = normalizeRiskColorLabel(data?.cor || "Não informado");
        const significado = String(data?.significado || "").trim();
        const legenda = Array.isArray(data?.legenda) ? data.legenda : RISK_LEGEND_DEFAULT;

        if (riskTriageBadge) {
          riskTriageBadge.textContent = cor;
          applyRiskBadgeColor(cor);
        }
        if (riskTriageMeaning) {
          riskTriageMeaning.textContent = significado ? significado : "Sem significado disponível.";
        }
        renderRiskLegend(legenda);

        // Guarda texto para impressão
        riskTriageMeaning.dataset.printText = buildRiskPrintText(cor, significado, legenda);

        riskTriageStatus.classList.remove("loading-dot");
        riskTriageStatus.textContent = "Classificação atualizada.";
      } catch (e) {
        console.error(e);
        riskTriageStatus.classList.remove("loading-dot");
        riskTriageStatus.textContent = "Falha de rede ou backend ao gerar a classificação de risco.";
      }
    }


async function generateSoapAndPrescriptionFromTranscript(transcricao, statusText) {
      const t = String(transcricao || "").trim();
      if (!t) return;

      soapError.textContent = "";
      micStatus.innerText = statusText || "Atualizando SOAP e prescrição...";
      micStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/gerar-soap", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao: t })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend:", resp.status, txt);
          soapError.textContent = "Erro ao gerar evolução/plano de cuidados. Verifique o backend e tente novamente.";
          micStatus.innerText = "Falha ao gerar o resumo.";
          micStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const soap = data.soap || "";
        const evolucao_enfermagem = data.evolucao_enfermagem || "";
        const prescricao = data.prescricao || "";

        updateSoapFromString(soap);
        if (nursingEvolutionOutput) nursingEvolutionOutput.value = evolucao_enfermagem;
        prescriptionOutput.value = normalizeNumberedParagraphs(prescricao);
        printBtn.style.display = prescricao ? "inline-block" : "none";

        micStatus.innerText = "Atualização concluída.";
        micStatus.classList.remove("loading-dot");

        await updateClassifications();
        await updateRiskTriage();
        } catch (e) {
        console.error(e);
        soapError.textContent = "Erro ao gerar evolução e plano de cuidados (falha de rede ou backend).";
        micStatus.innerText = "Falha ao gerar o resumo.";
        micStatus.classList.remove("loading-dot");
      }
    }

    async function applyPatientContextAndRefreshAll() {
      const rawCandidate = (baseTranscriptRaw || "").trim() || (finalTranscript || "").trim() || (baseTranscript || "").trim();
      if (!rawCandidate) {
        patientInfoStatus.textContent = "Não há transcrição da consulta para atualizar.";
        return;
      }

      const cleanedRaw = rawCandidate.replace(/^Dados do paciente:[\s\S]*?\n{2,}/i, "").trim();
      baseTranscriptRaw = cleanedRaw;

      const transcricaoAtualizada = buildTranscriptWithPatientContext(cleanedRaw);
      baseTranscript = transcricaoAtualizada;

      await generateSoapAndPrescriptionFromTranscript(transcricaoAtualizada, "Atualizando SOAP e prescrição com nome/idade/peso...");
}

    async function startPatientInfoRecording() {
      if (!patientInfoBtn) return;

      patientInfoStatus.textContent = "Gravando... Dite nome completo, idade e peso.";
      patientInfoStatus.classList.add("loading-dot");
      patientInfoBtn.textContent = "Finalizar nome/idade/peso";

      patientInfoFinalTranscript = "";
      resetPatientInfoTimer();
      startPatientInfoTimer();

      try { if (recognition) recognition.stop(); } catch (e) {}
      try { if (questionsRecognition) questionsRecognition.stop(); } catch (e) {}
      try { if (reportRecognition) reportRecognition.stop(); } catch (e) {}

      if (!patientInfoRecognition) {
        const ok = initPatientInfoSpeech();
        if (!ok) {
          patientInfoStatus.classList.remove("loading-dot");
          patientInfoStatus.textContent = "Navegador sem suporte a reconhecimento de voz.";
          patientInfoBtn.textContent = "Coletar dados essenciais";
          stopPatientInfoTimer();
          return;
        }
      }

      patientInfoIsRecording = true;
      try {
        patientInfoRecognition.start();
      } catch (e) {
        console.warn("Erro ao iniciar reconhecimento (dados do paciente):", e);
      }
    }

    async function stopPatientInfoRecordingAndApply() {
      patientInfoIsRecording = false;
      stopPatientInfoTimer();

      patientInfoBtn.textContent = "Coletar dados essenciais";

      if (patientInfoRecognition) {
        try { patientInfoRecognition.stop(); } catch (e) {}
      }

      const transcricaoCurta = patientInfoFinalTranscript.trim();
      if (!transcricaoCurta) {
        patientInfoStatus.classList.remove("loading-dot");
        patientInfoStatus.textContent = "Nenhuma fala foi capturada.";
        return;
      }

      patientInfoStatus.textContent = "Processando nome/idade/peso...";
      patientInfoStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/extrair-dados-paciente", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao: transcricaoCurta })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (dados do paciente):", resp.status, txt);
          patientInfoStatus.classList.remove("loading-dot");
          patientInfoStatus.textContent = "Não foi possível extrair os dados do paciente.";
          return;
        }

        const data = await resp.json();
        patientContext = {
          nome: (data?.nome || null),
          idade: (data?.idade || null),
          peso_kg: (typeof data?.peso_kg === "number" && Number.isFinite(data.peso_kg)) ? data.peso_kg : null
        };

        const resumo = formatPatientSummary(patientContext);
        patientInfoSummary.textContent = resumo ? resumo : "Dados do paciente não identificados com segurança.";
        patientInfoStatus.classList.remove("loading-dot");
        patientInfoStatus.textContent = resumo ? "Dados do paciente atualizados." : "Sem dados suficientes para atualizar.";

        await applyPatientContextAndRefreshAll();
      } catch (e) {
        console.error(e);
        patientInfoStatus.classList.remove("loading-dot");
        patientInfoStatus.textContent = "Falha de rede ou backend ao extrair dados do paciente.";
      }
    }

    if (patientInfoBtn) {
      patientInfoBtn.addEventListener("click", async () => {
        if (patientInfoIsRecording) {
          await stopPatientInfoRecordingAndApply();
        } else {
          await startPatientInfoRecording();
        }
      });
    }

    const reportRecordBtn = document.getElementById("reportRecordBtn");
    const reportStatus = document.getElementById("reportStatus");
    const reportOutput = document.getElementById("reportOutput");
    
    const reportPreview = document.getElementById("reportPreview");
const reportDocTypeSelect = document.getElementById("reportDocTypeSelect");
    const reportDocTypeDetected = document.getElementById("reportDocTypeDetected");
    const reportMissingFields = document.getElementById("reportMissingFields");
    const copyReportBtn = document.getElementById("copyReportBtn");
    const printReportBtn = document.getElementById("printReportBtn");

    let reportRecognition = null;
    let reportIsRecording = false;
    let reportIsPaused = false;
    let reportFinalTranscript = "";

    // Rodada adicional de perguntas (aba lateral)
    let questionsRecognition = null;
    let questionsIsRecording = false;
    let questionsFinalTranscript = "";
    let questionsTimerInterval = null;
    let questionsStartTime = null;
    let questionsAccumulatedSeconds = 0;

    function escapeHtml(text) {
      return String(text || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }

    function normalizeNumberedParagraphs(text) {
      let t = String(text || "");
      t = t.replace(/\r/g, "");
      // Garante que cada item numerado comece em uma nova linha (melhora leitura no S.U.I.S.)
      t = t.replace(/([^\n])\s+(\d+)\s*([\.)])\s+/g, "$1\n$2$3 ");
      t = t.replace(/([^\n])\s+(\d+)\s*[-–—]\s+/g, "$1\n$2 - ");
      t = t.replace(/\n{3,}/g, "\n\n");
      return t.trim();
    }


    // ============================
    // ============================
    // Perguntas e procedimentos essenciais em tempo real (FLUXO CONTROLADO)
    // ============================
    function renderLiveGuidance() {
      if (!liveGuidance || !liveGuidanceList || !liveGuidanceStatus || !liveGuidanceContext) return;

      if (!isRecording) {
        liveGuidanceContext.textContent = "";
        liveGuidanceStatus.textContent = "Inicie o atendimento para receber perguntas e procedimentos necessários em tempo real.";
        liveGuidanceList.innerHTML = "<div class=\"live-guidance-empty\">Nenhuma sugestão por enquanto.</div>";
        return;
      }

      const ctx = (guidanceContextLabel || "").trim();
      liveGuidanceContext.textContent = ctx ? ("Atendimento: " + ctx) : "";

      if (guidanceStage === "aguardando_motivo") {
        liveGuidanceStatus.textContent = "Aguardando o motivo da consulta. Após o paciente informar o motivo, as perguntas essenciais serão sugeridas.";
        liveGuidanceList.innerHTML = `
          <div class="live-guidance-empty">
            Oriente: acolha e pergunte o motivo da consulta. Após a resposta do paciente, as perguntas essenciais serão sugeridas automaticamente.
            <div style="margin-top:10px;">
              <button id="forceStartGuidanceBtn" class="mini-red-btn" style="background:#b00020;">Motivo já foi informado</button>
            </div>
          </div>
        `;
        const btn = document.getElementById("forceStartGuidanceBtn");
        if (btn) {
          btn.onclick = () => {
            if (guidanceStage !== "aguardando_motivo") return;
            guidanceStage = "perguntas";
            // reinicia detecção de turnos a partir do ponto atual
            guidanceTurnState = "aguardando_pergunta";
            guidanceAskedQuestion = "";
            guidanceAskedAtLen = getCombinedTranscript().length;
            guidanceAskedAtTs = Date.now();
            guidanceChunkStartLen = getCombinedTranscript().length;
            requestGuidanceFromBackend({ evento: "inicial" });
          };
        }
        return;
      }

      // estágio perguntas (controle por turnos: pergunta -> resposta -> atualizar)
      const confTxt = (typeof guidanceConfidence === "number" && guidanceConfidence > 0)
        ? ("Nível de confiança da hipótese principal: " + Math.round(guidanceConfidence) + "% (não chega a 100%).")
        : "";

      const hypo = (guidanceHypothesis || "").trim();
      const hypoTxt = hypo ? ("Hipótese principal: " + hypo + ". " + confTxt) : confTxt;

      if (guidanceTurnState === "aguardando_resposta") {
        liveGuidanceStatus.textContent = "Pergunta em andamento. Aguardando resposta do paciente para atualizar as próximas perguntas...";
      } else if (guidanceInFlight) {
        liveGuidanceStatus.textContent = "Atualizando perguntas essenciais...";
      } else {
        liveGuidanceStatus.textContent = hypoTxt || "Perguntas essenciais sugeridas. Faça uma das perguntas e aguarde a resposta do paciente.";
      }

      if (!guidancePending || !guidancePending.length) {
        liveGuidanceList.innerHTML = "<div class=\"live-guidance-empty\">Nenhuma pergunta essencial no momento.</div>";
        return;
      }

      liveGuidanceList.innerHTML = "";
      guidancePending.slice(0, 3).forEach((q, idx) => {
        const safeQ = escapeHtml(String(q || ""));
        const askedMark = (guidanceAskedQuestion && guidanceAskedQuestion.toLowerCase() === String(q || "").toLowerCase())
          ? " (pergunta feita)"
          : "";
        const el = document.createElement("div");
        el.className = "live-guidance-item";
        el.innerHTML = `<div class="live-guidance-item-text">${idx + 1}. ${safeQ}${askedMark}</div>`;
        liveGuidanceList.appendChild(el);
      });
    }

    function getCombinedTranscript() {
      const combined = ((finalTranscript || "") + " " + (interimTranscript || "")).trim();
      if (!combined) return "";
      const MAX = 8000;
      return combined.length > MAX ? combined.slice(combined.length - MAX) : combined;
    }

    function hashForGuidancePayload(obj) {
      try {
        const raw = JSON.stringify(obj || {});
        let h = 0;
        for (let i = 0; i < raw.length; i++) {
          h = ((h << 5) - h) + raw.charCodeAt(i);
          h |= 0;
        }
        return String(h);
      } catch {
        return String(Date.now());
      }
    }

    function resetLiveGuidanceState() {
      guidanceEnabled = false;
      guidanceStage = "aguardando_motivo";
      guidancePending = [];
      guidanceContextLabel = "";
      guidanceHypothesis = "";
      guidanceConfidence = 0;

      guidanceInFlight = false;

      guidanceTurnState = "aguardando_pergunta";
      guidanceAskedQuestion = "";
      guidanceAskedAtLen = 0;
      guidanceAskedAtTs = 0;

      guidanceChunkStartLen = 0;
      guidanceSilenceTimer && clearTimeout(guidanceSilenceTimer);
      guidanceSilenceTimer = null;

      guidanceLastPayloadHash = "";
      guidanceLastChunkTs = 0;

      renderLiveGuidance();
    }

        function startGuidanceLoop() {
          guidanceEnabled = true;
          renderLiveGuidance();
          maybeStartInitialGuidance(false);
        }

    function stopGuidanceLoop() {
      guidanceEnabled = false;
      guidanceInFlight = false;
      guidanceTurnState = "aguardando_pergunta";
      guidanceAskedQuestion = "";
      guidanceSilenceTimer && clearTimeout(guidanceSilenceTimer);
      guidanceSilenceTimer = null;
      renderLiveGuidance();
    }

    function triageRenderLiveGuidance() {
      if (!triageLiveGuidance || !triageLiveGuidanceStatus || !triageLiveGuidanceList || !triageLiveGuidanceContext) return;

      if (!triageGuidanceEnabled || !triageIsRecording) {
        triageLiveGuidanceContext.textContent = "";
        triageLiveGuidanceStatus.textContent = "Inicie a triagem para receber perguntas e procedimentos necessários em tempo real.";
        triageLiveGuidanceList.innerHTML = "<div class=\"live-guidance-empty\">Nenhuma sugestão por enquanto.</div>";
        return;
      }

      const ctx = (triageGuidanceContextLabel || "").trim();
      triageLiveGuidanceContext.textContent = ctx ? ("Triagem: " + ctx) : "";

      if (triageGuidanceStage === "aguardando_motivo") {
        triageLiveGuidanceStatus.textContent = "Aguardando a queixa principal. Após o paciente informar o motivo, serão sugeridas perguntas e procedimentos essenciais para classificar risco e iniciar condutas.";
        triageLiveGuidanceList.innerHTML = `
          <div class="live-guidance-empty">
            Oriente: acolha e registre a queixa principal. Em seguida, descreva sinais vitais e achados do ABCDE.
            <div style="margin-top:10px;">
              <button id="triageForceStartGuidanceBtn" class="mini-red-btn" style="background:#b00020;">Queixa já foi informada</button>
            </div>
          </div>
        `;
        const btn = document.getElementById("triageForceStartGuidanceBtn");
        if (btn) {
          btn.onclick = () => {
            if (triageGuidanceStage !== "aguardando_motivo") return;
            triageGuidanceStage = "perguntas";
            triageGuidanceTurnState = "aguardando_pergunta";
            triageGuidanceAskedQuestion = "";
            triageGuidanceAskedAtLen = triageGetCombinedTranscript().length;
            triageGuidanceAskedAtTs = Date.now();
            triageGuidanceChunkStartLen = triageGetCombinedTranscript().length;
            triageRequestGuidanceFromBackend({ evento: "inicial" });
          };
        }
        return;
      }

      const confTxt = (typeof triageGuidanceConfidence === "number" && triageGuidanceConfidence > 0)
        ? ("Nível de confiança do cenário principal: " + Math.round(triageGuidanceConfidence) + "% (não chega a 100%).")
        : "";

      const hypo = (triageGuidanceHypothesis || "").trim();
      const hypoTxt = hypo ? ("Cenário principal: " + hypo + ". " + confTxt) : confTxt;

      if (triageGuidanceTurnState === "aguardando_resposta") {
        triageLiveGuidanceStatus.textContent = "Item em andamento. Aguardando informação do paciente para atualizar os próximos itens...";
      } else if (triageGuidanceInFlight) {
        triageLiveGuidanceStatus.textContent = "Atualizando itens essenciais da triagem...";
      } else {
        triageLiveGuidanceStatus.textContent = hypoTxt || "Itens essenciais sugeridos. Execute um item e aguarde a resposta para atualizar.";
      }

      if (!triageGuidancePending || !triageGuidancePending.length) {
        triageLiveGuidanceList.innerHTML = "<div class=\"live-guidance-empty\">Nenhum item essencial no momento.</div>";
        return;
      }

      triageLiveGuidanceList.innerHTML = "";
      triageGuidancePending.slice(0, 3).forEach((q, idx) => {
        const safeQ = escapeHtml(String(q || ""));
        const askedMark = (triageGuidanceAskedQuestion && triageGuidanceAskedQuestion.toLowerCase() === String(q || "").toLowerCase())
          ? " (item executado)"
          : "";
        const el = document.createElement("div");
        el.className = "live-guidance-item";
        el.innerHTML = `<div class="live-guidance-item-text">${idx + 1}. ${safeQ}${askedMark}</div>`;
        triageLiveGuidanceList.appendChild(el);
      });
    }

    function triageGetCombinedTranscript() {
      const combined = ((triageFinalTranscript || "") + " " + (triageInterimTranscript || "")).trim();
      if (!combined) return "";
      const MAX = 8000;
      return combined.length > MAX ? combined.slice(combined.length - MAX) : combined;
    }

    function triageResetLiveGuidanceState() {
      triageGuidanceEnabled = false;
      triageGuidanceStage = "aguardando_motivo";
      triageGuidancePending = [];
      triageGuidanceContextLabel = "";
      triageGuidanceHypothesis = "";
      triageGuidanceConfidence = 0;

      triageGuidanceInFlight = false;

      triageGuidanceTurnState = "aguardando_pergunta";
      triageGuidanceAskedQuestion = "";
      triageGuidanceAskedAtLen = 0;
      triageGuidanceAskedAtTs = 0;

      triageGuidanceChunkStartLen = 0;
      triageGuidanceSilenceTimer && clearTimeout(triageGuidanceSilenceTimer);
      triageGuidanceSilenceTimer = null;

      triageGuidanceLastPayloadHash = "";
      triageGuidanceLastChunkTs = 0;

      triageRenderLiveGuidance();
    }

        function triageStartGuidanceLoop() {
          triageGuidanceEnabled = true;
          triageRenderLiveGuidance();
          triageMaybeStartInitialGuidance(false);
        }

    function triageStopGuidanceLoop() {
      triageGuidanceEnabled = false;
      triageGuidanceInFlight = false;
      triageGuidanceTurnState = "aguardando_pergunta";
      triageGuidanceAskedQuestion = "";
      triageGuidanceSilenceTimer && clearTimeout(triageGuidanceSilenceTimer);
      triageGuidanceSilenceTimer = null;
      triageRenderLiveGuidance();
    }

    function triageMaybeStartInitialGuidance(force) {
      if (!triageGuidanceEnabled || !triageIsRecording || triageIsPaused) return;
      if (triageGuidanceStage !== "aguardando_motivo") return;

      const combined = triageGetCombinedTranscript();
      if (!combined || combined.length < 120) return;

      if (!force && !hasLikelyChiefComplaint(combined)) return;

      triageGuidanceStage = "perguntas";
      triageGuidanceTurnState = "aguardando_pergunta";
      triageGuidanceAskedQuestion = "";
      triageGuidanceAskedAtLen = combined.length;
      triageGuidanceAskedAtTs = Date.now();
      triageGuidanceChunkStartLen = combined.length;

      triageRequestGuidanceFromBackend({ evento: "inicial" });
    }

    function triageOnTranscriptUpdateForGuidance() {
      if (!triageGuidanceEnabled || !triageIsRecording || triageIsPaused) return;

      if (triageGuidanceStage === "aguardando_motivo") {
        triageMaybeStartInitialGuidance(false);
        return;
      }

      triageScheduleGuidanceSilenceFinalize();
    }

    function triageScheduleGuidanceSilenceFinalize() {
      if (!triageGuidanceEnabled || !triageIsRecording || triageIsPaused) return;

      if (triageGuidanceSilenceTimer) clearTimeout(triageGuidanceSilenceTimer);
      triageGuidanceSilenceTimer = setTimeout(() => {
        triageFinalizeGuidanceChunk();
      }, 1400);
    }

    function triageFinalizeGuidanceChunk() {
      if (!triageGuidanceEnabled || !triageIsRecording || triageIsPaused) return;

      const combined = triageGetCombinedTranscript();
      if (!combined) return;

      if (triageGuidanceChunkStartLen <= 0) {
        triageGuidanceChunkStartLen = combined.length;
        return;
      }

      const chunk = combined.slice(triageGuidanceChunkStartLen).trim();
      triageGuidanceChunkStartLen = combined.length;

      if (!chunk || chunk.length < 10) return;

      const now = Date.now();
      if (triageGuidanceLastChunkTs && (now - triageGuidanceLastChunkTs) < 900) return;
      triageGuidanceLastChunkTs = now;

      triageHandleGuidanceUtteranceChunk(chunk);
    }

    function triageHandleGuidanceUtteranceChunk(chunkText) {
      if (!chunkText) return;
      if (!triageGuidancePending || !triageGuidancePending.length) return;
      if (triageGuidanceInFlight) return;

      if (triageGuidanceTurnState === "aguardando_pergunta") {
        const matched = matchQuestionFromUtterance(chunkText, triageGuidancePending);

        triageGuidanceAskedQuestion = matched ? matched : "";
        triageGuidanceAskedAtTs = Date.now();
        triageGuidanceAskedAtLen = triageGetCombinedTranscript().length;

        triageGuidanceTurnState = "aguardando_resposta";
        triageRenderLiveGuidance();
        return;
      }

      if (triageGuidanceTurnState === "aguardando_resposta") {
        const dt = Date.now() - (triageGuidanceAskedAtTs || 0);
        if (dt < 900) return;

        triageRequestGuidanceFromBackend({ evento: "resposta", ultima_fala: chunkText });
        return;
      }
    }

    async function triageRequestGuidanceFromBackend({ evento, ultima_fala }) {
      if (triageGuidanceInFlight) return;
      if (!triageGuidanceEnabled || !triageIsRecording || triageIsPaused) return;

      const combined = triageGetCombinedTranscript();
      if (!combined || combined.length < 50) {
        triageRenderLiveGuidance();
        return;
      }

      const payload = {
        modo: "triagem_hospitalar",
        transcricao: combined,
        estado: triageGuidanceStage,
        evento: evento || "stream",
        pergunta_feita: triageGuidanceAskedQuestion || "",
        perguntas_pendentes: Array.isArray(triageGuidancePending) ? triageGuidancePending.slice(0, 3) : [],
        confianca_atual: typeof triageGuidanceConfidence === "number" ? triageGuidanceConfidence : 0,
        hipotese_atual: triageGuidanceHypothesis || "",
        ultima_fala: typeof ultima_fala === "string" ? ultima_fala.slice(0, 800) : ""
      };

      const h = hashForGuidancePayload(payload);
      if (h === triageGuidanceLastPayloadHash && evento !== "inicial" && evento !== "resposta") return;
      triageGuidanceLastPayloadHash = h;

      triageGuidanceInFlight = true;
      triageRenderLiveGuidance();

      try {
        const resp = await fetch(BACKEND_URL + "/api/guia-tempo-real", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        if (!resp.ok) {
          const txt = await resp.text();
          console.error("Erro HTTP do backend (guia triagem):", resp.status, txt);
          return;
        }

        const data = await resp.json();
        triageGuidanceContextLabel = data.contexto || triageGuidanceContextLabel || "";
        triageGuidanceHypothesis = data.hipotese_principal || triageGuidanceHypothesis || "";
        if (typeof data.confianca === "number") triageGuidanceConfidence = data.confianca;

        const itens = Array.isArray(data.perguntas) ? data.perguntas : (Array.isArray(data.itens) ? data.itens : []);
        const normalized = itens.map(x => String(x || "").trim()).filter(Boolean);

        triageGuidancePending = normalized.slice(0, 3);

        if (evento === "resposta" || evento === "inicial") {
          triageGuidanceTurnState = "aguardando_pergunta";
          triageGuidanceAskedQuestion = "";
          triageGuidanceAskedAtLen = combined.length;
          triageGuidanceAskedAtTs = Date.now();
          triageGuidanceChunkStartLen = combined.length;
        }
      } catch (err) {
        console.error("Falha ao buscar guia triagem:", err);
      } finally {
        triageGuidanceInFlight = false;
        triageRenderLiveGuidance();
      }
    }

    function initTriageSpeech() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        if (triageMicStatus) triageMicStatus.innerText = "Seu navegador não suporta reconhecimento de voz. Use Google Chrome em um computador.";
        return;
      }
      triageRecognition = new SR();
      triageRecognition.lang = "pt-BR";
      triageRecognition.continuous = true;
      triageRecognition.interimResults = true;

      triageRecognition.onresult = (event) => {
        let interim = "";
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            triageFinalTranscript += transcript + " ";
          } else {
            interim += transcript;
          }
        }
        triageInterimTranscript = interim.trim();
        triageOnTranscriptUpdateForGuidance();
      };

      triageRecognition.onerror = (event) => {
        console.error("Erro no reconhecimento de voz (triagem):", event.error);
        if (triageMicStatus) {
          if (event.error === "not-allowed" || event.error === "service-not-allowed") {
            triageMicStatus.innerText = "Permita o acesso ao microfone nas configurações do navegador e tente novamente.";
          } else {
            triageMicStatus.innerText = "Ocorreu um erro no reconhecimento de voz. Tente novamente.";
          }
        }
      };

      triageRecognition.onend = () => {
        if (triageIsRecording && !triageIsPaused) {
          try { triageRecognition.start(); } catch (err) {}
        }
      };
    }

    function triageUpdateTimer() {
      const now = Date.now();
      const seconds = triageAccumulatedSeconds + Math.floor((now - triageStartTime) / 1000);
      const m = ("0" + Math.floor(seconds / 60)).slice(-2);
      const s = ("0" + (seconds % 60)).slice(-2);
      if (triageTimerEl) triageTimerEl.innerText = `${m}:${s}`;
    }

    function triageStartTimer() {
      triageStartTime = Date.now();
      if (triageTimerInterval) clearInterval(triageTimerInterval);
      triageTimerInterval = setInterval(triageUpdateTimer, 500);
    }

    function triagePauseTimer() {
      if (!triageStartTime) return;
      const now = Date.now();
      triageAccumulatedSeconds += Math.floor((now - triageStartTime) / 1000);
      if (triageTimerInterval) clearInterval(triageTimerInterval);
      triageTimerInterval = null;
    }

    function triageResetTimer() {
      if (triageTimerInterval) clearInterval(triageTimerInterval);
      triageTimerInterval = null;
      triageStartTime = null;
      triageAccumulatedSeconds = 0;
      if (triageTimerEl) triageTimerEl.innerText = "00:00";
    }

    function applyRiskBadgeColorTo(el, cor) {
      if (!el) return;
      el.classList.remove("risk-none", "risk-vermelho", "risk-laranja", "risk-amarelo", "risk-verde", "risk-azul");
      const c = normalizeRiskColorLabel(cor);
      if (c === "Vermelho") el.classList.add("risk-vermelho");
      else if (c === "Laranja") el.classList.add("risk-laranja");
      else if (c === "Amarelo") el.classList.add("risk-amarelo");
      else if (c === "Verde") el.classList.add("risk-verde");
      else if (c === "Azul") el.classList.add("risk-azul");
      else el.classList.add("risk-none");
    }

    function renderRiskLegendInto(container, legendArr) {
      if (!container) return;
      const legend = Array.isArray(legendArr) && legendArr.length ? legendArr : RISK_LEGEND_DEFAULT;
      container.innerHTML = "";
      legend.slice(0, 5).forEach((item) => {
        const cor = normalizeRiskColorLabel(item?.cor || "");
        const tempo = String(item?.tempo || "").trim();
        const label = String(item?.descricao || "").trim();
        const row = document.createElement("div");
        row.className = "risk-legend-row";
        const badge = document.createElement("span");
        badge.className = "risk-badge";
        applyRiskBadgeColorTo(badge, cor);
        badge.textContent = cor || "Não informado";
        const txt = document.createElement("div");
        txt.className = "risk-legend-text";
        txt.textContent = (tempo ? (tempo + " - ") : "") + (label || "");
        row.appendChild(badge);
        row.appendChild(txt);
        container.appendChild(row);
      });
    }

    function triageClearReportUI() {
      if (triageReportStatus) triageReportStatus.textContent = "";
      if (triageRiskBadge) { triageRiskBadge.textContent = "Não informado"; applyRiskBadgeColorTo(triageRiskBadge, "Não informado"); }
      if (triageRiskMeaning) { triageRiskMeaning.textContent = "Nenhum conteúdo disponível."; triageRiskMeaning.dataset.printText = ""; }
      if (triageRiskLegend) renderRiskLegendInto(triageRiskLegend, RISK_LEGEND_DEFAULT);

      if (triageProntuario) triageProntuario.value = "";
      if (triagePassagemMedico) triagePassagemMedico.value = "";
      if (triageAlertas) triageAlertas.value = "";
      if (triageCondutasNaoMed) triageCondutasNaoMed.value = "";
      if (triageCondutasMed) triageCondutasMed.value = "";
      if (triageMedidasExames) triageMedidasExames.value = "";
      if (triagePendencias) triagePendencias.value = "";
      if (triageQualidade) triageQualidade.value = "";
      if (triageFullReport) triageFullReport.value = "";
    }

    function startTriageRecording() {
      if (isRecording) {
        alert("Finalize a consulta antes de iniciar a triagem hospitalar.");
        return;
      }
      if (!triageRecognition) {
        initTriageSpeech();
        if (!triageRecognition) return;
      }

      triageIsRecording = true;
      triageIsPaused = false;
      triageFinalTranscript = "";
      triageInterimTranscript = "";

      if (triageError) triageError.textContent = "";
      triageClearReportUI();

      if (triagePauseBtn) {
        triagePauseBtn.style.display = "inline-block";
        triagePauseBtn.innerText = "Pausar";
      }

      if (triageRecordBtn) {
        triageRecordBtn.className = "recording";
        triageRecordBtn.innerText = "Encerrar triagem";
      }

      if (triageMicStatus) triageMicStatus.innerText = "Gravando triagem...";
      if (recordBtn) recordBtn.disabled = true;
      applyTriageOnlyLayout(true);

      triageResetLiveGuidanceState();
      triageRenderLiveGuidance();
      triageStartGuidanceLoop();

      triageResetTimer();
      triageStartTimer();

      try { triageRecognition.start(); } catch (e) {}
    }

    function stopTriageRecording() {
      triageIsRecording = false;
      triageIsPaused = false;

      triageStopGuidanceLoop();
      triageInterimTranscript = "";
      triageRenderLiveGuidance();

      if (triageRecognition) {
        try { triageRecognition.stop(); } catch (e) {}
      }
      triagePauseTimer();

      if (triageRecordBtn) {
        triageRecordBtn.className = "start";
        triageRecordBtn.innerText = "Iniciar triagem hospitalar";
      }

      if (triagePauseBtn) triagePauseBtn.style.display = "none";
      if (recordBtn) recordBtn.disabled = false;
    }

    function pauseTriageRecording() {
      if (!triageIsRecording || triageIsPaused) return;
      triageIsPaused = true;

      triageStopGuidanceLoop();
      if (triageLiveGuidanceStatus) triageLiveGuidanceStatus.textContent = "Triagem pausada. As sugestões em tempo real serão retomadas ao retomar a gravação.";

      if (triageRecognition) {
        try { triageRecognition.stop(); } catch (e) {}
      }
      triagePauseTimer();

      if (triagePauseBtn) triagePauseBtn.innerText = "Retomar";
      if (triageMicStatus) triageMicStatus.innerText = "Triagem pausada.";
    }

    function resumeTriageRecording() {
      if (!triageIsRecording || !triageIsPaused) return;
      triageIsPaused = false;

      triageStartGuidanceLoop();

      if (triageRecognition) {
        try { triageRecognition.start(); } catch (e) {}
      }
      triageStartTimer();

      if (triagePauseBtn) triagePauseBtn.innerText = "Pausar";
      if (triageMicStatus) triageMicStatus.innerText = "Gravando triagem...";
    }

    async function finalizarTriagemHospitalar() {
      const combined = triageGetCombinedTranscript();
      const txt = (combined || "").trim();

      if (!txt || txt.length < 40) {
        if (triageError) triageError.textContent = "A transcrição da triagem ficou muito curta. Tente novamente, falando mais próximo ao microfone.";
        return;
      }

      mountResultsCard(triageResultsMount);
      if (resultsCard) resultsCard.classList.remove("hidden");
      setResultsView("triage");
      if (triageReportPanel) triageReportPanel.classList.remove("hidden");
      if (triageReportStatus) {
        triageReportStatus.textContent = "Gerando relatório de triagem...";
        triageReportStatus.classList.add("loading-dot");
      }

      triageClearReportUI();
      if (triageReportPanel) triageReportPanel.classList.remove("hidden");

      try {
        const resp = await fetch(BACKEND_URL + "/api/gerar-triagem-hospitalar", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao: txt })
        });

        if (!resp.ok) {
          const t = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (triagem):", resp.status, t);
          if (triageReportStatus) {
            triageReportStatus.textContent = "Não foi possível gerar a triagem.";
            triageReportStatus.classList.remove("loading-dot");
          }
          return;
        }

        const data = await resp.json();

        const nivel = (data?.nivel_risco || "").trim() || "Não informado";
        const tempo = (data?.tempo_maximo || "").trim();
        const just = (data?.justificativa_risco || "").trim();
        const meaning = (tempo ? ("Tempo máximo: " + tempo + ". ") : "") + (just || "");

        if (triageRiskBadge) {
          triageRiskBadge.textContent = normalizeRiskColorLabel(nivel) || nivel || "Não informado";
          applyRiskBadgeColorTo(triageRiskBadge, nivel);
        }
        if (triageRiskMeaning) {
          triageRiskMeaning.textContent = meaning || "Nenhum conteúdo disponível.";
          triageRiskMeaning.dataset.printText = [
            "Classificação de risco: " + (normalizeRiskColorLabel(nivel) || nivel || "Não informado"),
            tempo ? ("Tempo máximo: " + tempo) : "",
            just ? ("Justificativa: " + just) : ""
          ].filter(Boolean).join("\n");
        }
        renderRiskLegendInto(triageRiskLegend, RISK_LEGEND_DEFAULT);

        if (triageProntuario) triageProntuario.value = (data?.texto_prontuario || "").trim();
        if (triagePassagemMedico) triagePassagemMedico.value = (data?.passagem_medico || "").trim();
        if (triageAlertas) triageAlertas.value = (data?.alertas_red_flags || "").trim();
        if (triageCondutasNaoMed) triageCondutasNaoMed.value = (data?.condutas_nao_medicamentosas || "").trim();
        if (triageCondutasMed) triageCondutasMed.value = (data?.condutas_medicamentosas || "").trim();
        if (triageMedidasExames) triageMedidasExames.value = (data?.medidas_exames_imediatos || "").trim();
        if (triagePendencias) triagePendencias.value = (data?.pendencias_checar || "").trim();
        if (triageQualidade) triageQualidade.value = (data?.checagem_qualidade || "").trim();
        if (triageFullReport) triageFullReport.value = (data?.relatorio_completo || "").trim();

        if (triageReportStatus) {
          triageReportStatus.textContent = "Triagem gerada.";
          triageReportStatus.classList.remove("loading-dot");
        }
      } catch (e) {
        console.error("Erro ao gerar triagem:", e);
        if (triageReportStatus) {
          triageReportStatus.textContent = "Erro ao gerar triagem.";
          triageReportStatus.classList.remove("loading-dot");
        }
      }
    }



    // ============================
    // Passagem de plantão (gravação + geração)
    // ============================

    function handoffResetTimer() {
      handoffStartTime = null;
      handoffAccumulatedSeconds = 0;
      if (handoffTimerInterval) clearInterval(handoffTimerInterval);
      handoffTimerInterval = null;
      if (handoffTimerEl) handoffTimerEl.textContent = "00:00";
    }

    function handoffStartTimer() {
      if (handoffTimerInterval) clearInterval(handoffTimerInterval);
      handoffStartTime = new Date();
      handoffTimerInterval = setInterval(() => {
        const now = new Date();
        const delta = Math.floor((now - handoffStartTime) / 1000);
        const total = handoffAccumulatedSeconds + delta;
        const mm = String(Math.floor(total / 60)).padStart(2, "0");
        const ss = String(total % 60).padStart(2, "0");
        if (handoffTimerEl) handoffTimerEl.textContent = `${mm}:${ss}`;
      }, 1000);
    }

    function handoffPauseTimer() {
      if (!handoffStartTime) return;
      const now = new Date();
      const delta = Math.floor((now - handoffStartTime) / 1000);
      handoffAccumulatedSeconds += delta;
      handoffStartTime = null;
      if (handoffTimerInterval) clearInterval(handoffTimerInterval);
      handoffTimerInterval = null;
    }

    function handoffGetCombinedTranscript() {
      const full = (handoffFinalTranscript || "").trim();
      const inter = (handoffInterimTranscript || "").trim();
      return [full, inter].filter(Boolean).join(" ").trim();
    }

    function handoffResetLiveGuidanceState() {
      handoffGuidanceEnabled = false;
      handoffGuidanceStage = "sbar";
      handoffGuidancePending = [];
      handoffGuidanceContextLabel = "";
      handoffGuidanceHypothesis = "";
      handoffGuidanceConfidence = 0;

      handoffGuidanceInFlight = false;
      handoffGuidanceLastPayloadHash = "";
      handoffGuidanceChunkStartLen = 0;

      if (handoffGuidanceSilenceTimer) clearTimeout(handoffGuidanceSilenceTimer);
      handoffGuidanceSilenceTimer = null;
      handoffGuidanceLastChunkTs = 0;

      handoffRenderLiveGuidance();
    }

    function handoffRenderLiveGuidance() {
      if (!handoffLiveGuidance || !handoffLiveGuidanceStatus || !handoffLiveGuidanceList || !handoffLiveGuidanceContext) return;

      if (!handoffIsRecording) {
        handoffLiveGuidanceStatus.textContent = "Inicie a passagem de plantão para receber sugestões essenciais SBAR em tempo real.";
        handoffLiveGuidanceContext.textContent = "";
        handoffLiveGuidanceList.innerHTML = '<div class="live-guidance-empty">Nenhuma sugestão por enquanto.</div>';
        return;
      }

      const ctx = String(handoffGuidanceContextLabel || "").trim();
      handoffLiveGuidanceContext.textContent = ctx ? ("Passagem: " + ctx) : "";

      if (handoffGuidanceInFlight) {
        handoffLiveGuidanceStatus.textContent = "Atualizando sugestões SBAR...";
      } else if (handoffGuidanceHypothesis) {
        handoffLiveGuidanceStatus.textContent = handoffGuidanceHypothesis;
      } else {
        handoffLiveGuidanceStatus.textContent = "Sugestões SBAR ativas. Siga o roteiro e inclua os itens pendentes.";
      }

      const itens = Array.isArray(handoffGuidancePending) ? handoffGuidancePending : [];
      if (!itens.length) {
        handoffLiveGuidanceList.innerHTML = '<div class="live-guidance-empty">Nenhuma sugestão por enquanto.</div>';
        return;
      }

      handoffLiveGuidanceList.innerHTML = "";
      itens.slice(0, 3).forEach((q, idx) => {
        const el = document.createElement("div");
        el.className = "live-guidance-item";
        el.innerHTML = `<div class="live-guidance-item-text">${idx + 1}. ${escapeHtml(q)}</div>`;
        handoffLiveGuidanceList.appendChild(el);
      });
    }

    function handoffStartGuidanceLoop() {
      handoffGuidanceEnabled = true;
      handoffGuidanceChunkStartLen = handoffGetCombinedTranscript().length;
      handoffRenderLiveGuidance();
      handoffRequestGuidanceFromBackend({ evento: "inicial" });
    }

    function handoffStopGuidanceLoop() {
      handoffGuidanceEnabled = false;
      handoffGuidanceInFlight = false;
      if (handoffGuidanceSilenceTimer) clearTimeout(handoffGuidanceSilenceTimer);
      handoffGuidanceSilenceTimer = null;
      handoffRenderLiveGuidance();
    }

    function handoffOnTranscriptUpdateForGuidance() {
      if (!handoffGuidanceEnabled || !handoffIsRecording || handoffIsPaused) return;
      handoffScheduleGuidanceSilenceFinalize();
    }

    function handoffScheduleGuidanceSilenceFinalize() {
      if (!handoffGuidanceEnabled || !handoffIsRecording || handoffIsPaused) return;

      if (handoffGuidanceSilenceTimer) clearTimeout(handoffGuidanceSilenceTimer);
      handoffGuidanceSilenceTimer = setTimeout(() => {
        handoffFinalizeGuidanceChunk();
      }, 1400);
    }

    function handoffFinalizeGuidanceChunk() {
      if (!handoffGuidanceEnabled || !handoffIsRecording || handoffIsPaused) return;

      const combined = handoffGetCombinedTranscript();
      if (!combined) return;

      if (handoffGuidanceChunkStartLen <= 0) {
        handoffGuidanceChunkStartLen = combined.length;
        return;
      }

      const chunk = combined.slice(handoffGuidanceChunkStartLen).trim();
      handoffGuidanceChunkStartLen = combined.length;

      if (!chunk || chunk.length < 10) return;

      const now = Date.now();
      if (handoffGuidanceLastChunkTs && (now - handoffGuidanceLastChunkTs) < 900) return;
      handoffGuidanceLastChunkTs = now;

      handoffRequestGuidanceFromBackend({ evento: "stream", ultima_fala: chunk });
    }

    async function handoffRequestGuidanceFromBackend({ evento, ultima_fala }) {
      if (handoffGuidanceInFlight) return;
      if (!handoffGuidanceEnabled || !handoffIsRecording || handoffIsPaused) return;

      const combined = handoffGetCombinedTranscript();

      const payload = {
        transcricao: combined,
        estado: "sbar",
        modo: "passagem_plantao",
        evento: evento || "stream",
        pergunta_feita: "",
        perguntas_pendentes: Array.isArray(handoffGuidancePending) ? handoffGuidancePending.slice(0, 3) : [],
        confianca_atual: typeof handoffGuidanceConfidence === "number" ? handoffGuidanceConfidence : 0,
        hipotese_atual: handoffGuidanceHypothesis || "",
        ultima_fala: typeof ultima_fala === "string" ? ultima_fala.slice(0, 800) : ""
      };

      const h = hashForGuidancePayload(payload);
      if (h === handoffGuidanceLastPayloadHash && evento !== "inicial") return;
      handoffGuidanceLastPayloadHash = h;

      handoffGuidanceInFlight = true;
      handoffRenderLiveGuidance();

      try {
        const resp = await fetch(BACKEND_URL + "/api/guia-tempo-real", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (SBAR tempo real):", resp.status, txt);
          return;
        }

        const data = await resp.json().catch(() => ({}));
        handoffGuidanceContextLabel = data.contexto || handoffGuidanceContextLabel || "";
        handoffGuidanceHypothesis = data.hipotese_principal || handoffGuidanceHypothesis || "";
        if (typeof data.confianca === "number") handoffGuidanceConfidence = data.confianca;

        const itens = Array.isArray(data.perguntas) ? data.perguntas : (Array.isArray(data.itens) ? data.itens : []);
        const normalized = itens.map(x => String(x || "").trim()).filter(Boolean);
        handoffGuidancePending = normalized.slice(0, 3);
      } catch (err) {
        console.error("Falha ao buscar SBAR em tempo real:", err);
      } finally {
        handoffGuidanceInFlight = false;
        handoffRenderLiveGuidance();
      }
    }


    function handoffClearUI() {
      if (handoffOutput) handoffOutput.value = "";
      if (handoffStatus) handoffStatus.textContent = "";
    }

    function ensureHandoffRecognition() {
      if (handoffRecognition) return true;
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        if (handoffError) handoffError.textContent = "Seu navegador não suporta reconhecimento de voz. Use Chrome no computador ou Android.";
        return false;
      }
      handoffRecognition = new SR();
      handoffRecognition.continuous = true;
      handoffRecognition.interimResults = true;
      handoffRecognition.lang = "pt-BR";

      handoffRecognition.onresult = (event) => {
        let interim = "";
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const res = event.results[i];
          const transcript = (res[0] && res[0].transcript) ? res[0].transcript : "";
          if (res.isFinal) {
            handoffFinalTranscript += transcript + " ";
          } else {
            interim += transcript + " ";
          }
        }
        handoffInterimTranscript = interim.trim();
        handoffOnTranscriptUpdateForGuidance();
      };

      handoffRecognition.onerror = (e) => {
        console.error("Erro no reconhecimento (passagem):", e);
      };

      return true;
    }

    function startHandoffRecording() {
      if (!ensureHandoffRecognition()) return;

      handoffIsRecording = true;
      handoffIsPaused = false;

      handoffStartGuidanceLoop();
      handoffFinalTranscript = "";
      handoffInterimTranscript = "";

      if (handoffError) handoffError.textContent = "";
      handoffClearUI();

      if (handoffPauseBtn) {
        handoffPauseBtn.style.display = "inline-block";
        handoffPauseBtn.innerText = "Pausar";
      }

      if (handoffRecordBtn) {
        handoffRecordBtn.className = "recording";
        handoffRecordBtn.innerText = "Encerrar passagem";
      }

      if (handoffMicStatus) handoffMicStatus.innerText = "Gravando passagem de plantão...";
      if (recordBtn) recordBtn.disabled = true;
      if (triageRecordBtn) triageRecordBtn.disabled = true;

      handoffResetTimer();
      handoffStartTimer();

      handoffResetLiveGuidanceState();
      handoffRenderLiveGuidance();
      handoffStartGuidanceLoop();

      try { handoffRecognition.start(); } catch (e) {}
    }

    function stopHandoffRecording() {
      handoffIsRecording = false;
      handoffIsPaused = false;

      handoffStopGuidanceLoop();
      handoffInterimTranscript = "";
      handoffRenderLiveGuidance();

      if (handoffRecognition) {
        try { handoffRecognition.stop(); } catch (e) {}
      }
      handoffPauseTimer();

      if (handoffRecordBtn) {
        handoffRecordBtn.className = "start";
        handoffRecordBtn.innerText = "Iniciar passagem de plantão";
      }

      if (handoffPauseBtn) handoffPauseBtn.style.display = "none";
      if (recordBtn) recordBtn.disabled = false;
      if (triageRecordBtn) triageRecordBtn.disabled = false;
    }

    function pauseHandoffRecording() {
      if (!handoffIsRecording || handoffIsPaused) return;
      handoffIsPaused = true;

      handoffStopGuidanceLoop();
      if (handoffLiveGuidanceStatus) handoffLiveGuidanceStatus.textContent = "Passagem de plantão pausada. As sugestões SBAR em tempo real serão retomadas ao retomar a gravação.";

      if (handoffRecognition) {
        try { handoffRecognition.stop(); } catch (e) {}
      }
      handoffPauseTimer();

      if (handoffPauseBtn) handoffPauseBtn.innerText = "Retomar";
      if (handoffMicStatus) handoffMicStatus.innerText = "Passagem de plantão pausada.";
    }

    function resumeHandoffRecording() {
      if (!handoffIsRecording || !handoffIsPaused) return;
      handoffIsPaused = false;

      if (handoffRecognition) {
        try { handoffRecognition.start(); } catch (e) {}
      }
      handoffStartTimer();

      if (handoffPauseBtn) handoffPauseBtn.innerText = "Pausar";
      if (handoffMicStatus) handoffMicStatus.innerText = "Gravando passagem de plantão...";
    }

    async function finalizarPassagemPlantao() {
      const combined = handoffGetCombinedTranscript();
      const txt = (combined || "").trim();

      if (!txt || txt.length < 40) {
        if (handoffError) handoffError.textContent = "A transcrição ficou muito curta. Tente novamente, falando mais próximo ao microfone.";
        return;
      }

      mountResultsCard(handoffResultsMount);
      if (resultsCard) resultsCard.classList.remove("hidden");
      if (handoffPanel) handoffPanel.classList.remove("hidden");

      handoffClearUI();

      if (handoffStatus) {
        handoffStatus.textContent = "Gerando passagem de plantão...";
        handoffStatus.classList.add("loading-dot");
      }

      try {
        const resp = await fetch(BACKEND_URL + "/api/gerar-passagem-plantao", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao: txt })
        });

        if (!resp.ok) {
          const t = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (passagem):", resp.status, t);
          if (handoffStatus) {
            handoffStatus.textContent = "Não foi possível gerar a passagem de plantão.";
            handoffStatus.classList.remove("loading-dot");
          }
          return;
        }

        const data = await resp.json();
        const passagem = (data?.passagem_plantao || "").trim();

        if (handoffOutput) handoffOutput.value = passagem || "";
        if (handoffStatus) {
          handoffStatus.textContent = passagem ? "Passagem de plantão gerada." : "Sem conteúdo disponível.";
          handoffStatus.classList.remove("loading-dot");
        }
      } catch (e) {
        console.error("Erro ao gerar passagem:", e);
        if (handoffStatus) {
          handoffStatus.textContent = "Erro ao gerar passagem de plantão.";
          handoffStatus.classList.remove("loading-dot");
        }
      }
    }


    function hasLikelyChiefComplaint(text) {
      const t = String(text || "").toLowerCase();
      if (!t) return false;
      const kw = [
        "motivo", "queixa", "dor", "febre", "tosse", "falta de ar", "dispne", "diarre", "vômit",
        "náuse", "enjoo", "garganta", "cefale", "tont", "desmai", "urina", "ardor",
        "corrimento", "sangr", "pressão", "hipertens", "glic", "diabetes", "infec",
        "ferida", "queda", "trauma", "alerg", "coceira", "mancha"
      ];
      return kw.some(k => t.includes(k));
    }

    function maybeStartInitialGuidance(force) {
      if (!guidanceEnabled || !isRecording || isPaused) return;
      if (guidanceStage !== "aguardando_motivo") return;

      const combined = getCombinedTranscript();
      if (!combined || combined.length < 120) return;

      // Evita iniciar antes do paciente realmente falar algo clínico
      if (!force && !hasLikelyChiefComplaint(combined)) return;

      guidanceStage = "perguntas";
      guidanceTurnState = "aguardando_pergunta";
      guidanceAskedQuestion = "";
      guidanceAskedAtLen = combined.length;
      guidanceAskedAtTs = Date.now();
      guidanceChunkStartLen = combined.length;

      requestGuidanceFromBackend({ evento: "inicial" });
    }

    function onTranscriptUpdateForGuidance() {
      if (!guidanceEnabled || !isRecording || isPaused) return;

      // 1) Detecta automaticamente o momento de iniciar (após motivo)
      if (guidanceStage === "aguardando_motivo") {
        maybeStartInitialGuidance(false);
        return;
      }

      // 2) A partir daqui: está em "perguntas". Controla por turnos usando silêncio.
      scheduleGuidanceSilenceFinalize();
    }

    function scheduleGuidanceSilenceFinalize() {
      if (!guidanceEnabled || !isRecording || isPaused) return;

      if (guidanceSilenceTimer) clearTimeout(guidanceSilenceTimer);
      guidanceSilenceTimer = setTimeout(() => {
        finalizeGuidanceChunk();
      }, 1400);
    }

    function finalizeGuidanceChunk() {
      if (!guidanceEnabled || !isRecording || isPaused) return;

      const combined = getCombinedTranscript();
      if (!combined) return;

      if (guidanceChunkStartLen <= 0) {
        guidanceChunkStartLen = combined.length;
        return;
      }

      // Captura apenas o que foi acrescentado desde o último “silêncio”
      const chunk = combined.slice(guidanceChunkStartLen).trim();
      guidanceChunkStartLen = combined.length;

      if (!chunk || chunk.length < 10) return;

      // Evita processar chunks colados em sequência que são só repetição do reconhecimento
      const now = Date.now();
      if (guidanceLastChunkTs && (now - guidanceLastChunkTs) < 900) return;
      guidanceLastChunkTs = now;

      handleGuidanceUtteranceChunk(chunk);
    }

    function stripAccents(s) {
      return String(s || "")
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "");
    }

    function tokenizePt(s) {
      const t = stripAccents(String(s || "").toLowerCase())
        .replace(/[^a-z0-9\s]/g, " ")
        .replace(/\s+/g, " ")
        .trim();

      if (!t) return [];

      const stop = new Set([
        "a","o","os","as","um","uma","uns","umas","de","do","da","dos","das","no","na","nos","nas",
        "em","para","por","com","sem","e","ou","que","qual","quais","quando","como","onde","porque",
        "ao","aos","à","às","se","já","não","sim","me","te","lhe","eles","elas","você","vocês",
        "eu","tu","ele","ela","nós","vos","isso","isto","aquilo","essa","esse","este","esta",
        "tem","tá","está","foi","era","são","ser","ter","há"
      ]);

      return t.split(" ").filter(w => w && w.length > 2 && !stop.has(w));
    }

    function jaccardSimilarity(aTokens, bTokens) {
      const A = new Set(aTokens || []);
      const B = new Set(bTokens || []);
      if (!A.size || !B.size) return 0;
      let inter = 0;
      for (const w of A) if (B.has(w)) inter++;
      const union = A.size + B.size - inter;
      return union ? (inter / union) : 0;
    }

    function matchQuestionFromUtterance(utterance, questions) {
      const qs = Array.isArray(questions) ? questions : [];
      if (!qs.length) return "";
      const uTok = tokenizePt(utterance);
      if (!uTok.length) return "";

      let bestQ = "";
      let bestScore = 0;

      for (const q of qs.slice(0, 3)) {
        const score = jaccardSimilarity(uTok, tokenizePt(q));
        if (score > bestScore) {
          bestScore = score;
          bestQ = q;
        }
      }

      // Se a similaridade for baixa, não “chuta” qual foi, para não apagar/alterar errado.
      if (bestScore < 0.18) return "";
      return String(bestQ || "").trim();
    }

    function handleGuidanceUtteranceChunk(chunkText) {
      if (!chunkText) return;
      if (!guidancePending || !guidancePending.length) return;
      if (guidanceInFlight) return;

      // Turno 1: o enfermeiro faz uma pergunta (a partir das 3 sugeridas)
      if (guidanceTurnState === "aguardando_pergunta") {
        const matched = matchQuestionFromUtterance(chunkText, guidancePending);

        guidanceAskedQuestion = matched ? matched : "";
        guidanceAskedAtTs = Date.now();
        guidanceAskedAtLen = getCombinedTranscript().length;

        guidanceTurnState = "aguardando_resposta";
        renderLiveGuidance();
        return;
      }

      // Turno 2: o paciente responde -> atualiza as perguntas
      if (guidanceTurnState === "aguardando_resposta") {
        const dt = Date.now() - (guidanceAskedAtTs || 0);
        if (dt < 900) return; // evita disparo imediato

        // Atualiza com base no diálogo novo
        requestGuidanceFromBackend({ evento: "resposta", ultima_fala: chunkText });
        return;
      }
    }

    async function requestGuidanceFromBackend({ evento, ultima_fala }) {
      if (guidanceInFlight) return;
      if (!guidanceEnabled || !isRecording || isPaused) return;

      const combined = getCombinedTranscript();
      if (!combined || combined.length < 50) {
        renderLiveGuidance();
        return;
      }

      const payload = {
        transcricao: combined,
        estado: guidanceStage,
        evento: evento || "stream",
        pergunta_feita: guidanceAskedQuestion || "",
        perguntas_pendentes: Array.isArray(guidancePending) ? guidancePending.slice(0, 3) : [],
        confianca_atual: typeof guidanceConfidence === "number" ? guidanceConfidence : 0,
        hipotese_atual: guidanceHypothesis || "",
        ultima_fala: typeof ultima_fala === "string" ? ultima_fala.slice(0, 800) : ""
      };

      const h = hashForGuidancePayload(payload);
      if (h === guidanceLastPayloadHash && evento !== "inicial" && evento !== "resposta") return;
      guidanceLastPayloadHash = h;

      guidanceInFlight = true;
      renderLiveGuidance();

      try {
        const resp = await fetch(BACKEND_URL + "/api/guia-tempo-real", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        if (!resp.ok) {
          const txt = await resp.text();
          console.error("Erro HTTP do backend (guia em tempo real):", resp.status, txt);
          return;
        }

        const data = await resp.json();
        guidanceContextLabel = data.contexto || guidanceContextLabel || "";
        guidanceHypothesis = data.hipotese_principal || guidanceHypothesis || "";
        if (typeof data.confianca === "number") guidanceConfidence = data.confianca;

        const itens = Array.isArray(data.perguntas) ? data.perguntas : (Array.isArray(data.itens) ? data.itens : []);
        const normalized = itens.map(x => String(x || "").trim()).filter(Boolean);

        guidancePending = normalized.slice(0, 3);

        // Após atualizar, volta a aguardar a próxima pergunta do enfermeiro
        if (evento === "resposta") {
          guidanceTurnState = "aguardando_pergunta";
          guidanceAskedQuestion = "";
          guidanceAskedAtLen = combined.length;
          guidanceAskedAtTs = Date.now();
          guidanceChunkStartLen = combined.length;
        }

        // Após gerar as perguntas iniciais, aguarda a primeira pergunta do enfermeiro
        if (evento === "inicial") {
          guidanceTurnState = "aguardando_pergunta";
          guidanceAskedQuestion = "";
          guidanceAskedAtLen = combined.length;
          guidanceAskedAtTs = Date.now();
          guidanceChunkStartLen = combined.length;
        }
      } catch (err) {
        console.error("Falha ao buscar guia em tempo real:", err);
      } finally {
        guidanceInFlight = false;
        renderLiveGuidance();
      }
    }
function initSpeech() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        micStatus.innerText =
          "Seu navegador não suporta reconhecimento de voz. Use Google Chrome em um computador.";
        return;
      }
      recognition = new SR();
      recognition.lang = "pt-BR";
      recognition.continuous = true;
      recognition.interimResults = true;

      recognition.onresult = (event) => {
        let interim = "";
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            finalTranscript += transcript + " ";
          } else {
            interim += transcript;
          }
        }

        interimTranscript = interim.trim();
        // Atualiza o fluxo de perguntas/procedimentos (somente quando necessário)
        onTranscriptUpdateForGuidance();
      };

      recognition.onerror = (event) => {
        console.error("Erro no reconhecimento de voz:", event.error);
        if (event.error === "not-allowed" || event.error === "service-not-allowed") {
          micStatus.innerText =
            "Permita o acesso ao microfone nas configurações do navegador e tente novamente.";
        } else {
          micStatus.innerText =
            "Ocorreu um erro no reconhecimento de voz. Tente novamente.";
        }
      };

      recognition.onend = () => {
        if (isRecording && !isPaused) {
          try {
            recognition.start();
          } catch (err) {
            console.warn("Não foi possível retomar reconhecimento:", err);
          }
        }
      };
    }

    function updateTimer() {
      const now = Date.now();
      const seconds = accumulatedSeconds + Math.floor((now - startTime) / 1000);
      const m = ("0" + Math.floor(seconds / 60)).slice(-2);
      const s = ("0" + (seconds % 60)).slice(-2);
      timerEl.innerText = `${m}:${s}`;
    }

    function startTimer() {
      startTime = Date.now();
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(updateTimer, 500);
    }

    function pauseTimer() {
      if (!startTime) return;
      const now = Date.now();
      accumulatedSeconds += Math.floor((now - startTime) / 1000);
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
    }

    function resetTimer() {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
      startTime = null;
      accumulatedSeconds = 0;
      timerEl.innerText = "00:00";
    }

    function resetNewModulesUI() {
      sbarOutput.value = "";
      sbarStatus.textContent = "";
      classificationsStatus.textContent = "";
      pregnancyBox.textContent = "Nenhum conteúdo disponível.";
      lactationBox.textContent = "Nenhum conteúdo disponível.";
      if (presentationsMaxDoseBox) setPlainOutput(presentationsMaxDoseBox, "Nenhum conteúdo disponível.");
      if (presentationsMaxDoseStatus) presentationsMaxDoseStatus.textContent = "";
    }

    async function finalizarConsulta() {
      soapError.textContent = "";
      micStatus.innerText = "Gerando SOAP e prescrição com base na gravação...";
      micStatus.classList.add("loading-dot");

      if (recognition) {
        try {
          recognition.stop();
        } catch (e) {
          console.warn("Erro ao parar reconhecimento:", e);
        }
      }

      pauseTimer();

      const transcricao = finalTranscript.trim();
      if (!transcricao) {
        micStatus.classList.remove("loading-dot");
        micStatus.innerText =
          "Nenhuma fala foi capturada. Verifique o microfone e tente novamente.";
        return;
      }

      baseTranscriptRaw = transcricao;

      const transcricaoParaGeracao = buildTranscriptWithPatientContext(transcricao);
      baseTranscript = transcricaoParaGeracao;

      try {
        const resp = await fetch(BACKEND_URL + "/api/gerar-soap", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao: transcricaoParaGeracao })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend:", resp.status, txt);
          soapError.textContent =
            "Erro ao gerar evolução/plano de cuidados. Verifique o backend e tente novamente.";
          micStatus.innerText = "Falha ao gerar o resumo.";
          micStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const soap = data.soap || "";
        const evolucao_enfermagem = data.evolucao_enfermagem || "";
        const prescricao = data.prescricao || "";

        updateSoapFromString(soap);
        if (nursingEvolutionOutput) nursingEvolutionOutput.value = evolucao_enfermagem;

        prescriptionOutput.value = prescricao;
        printBtn.style.display = prescricao ? "inline-block" : "none";

        micStatus.innerText = "Consulta encerrada. SOAP e prescrição gerados.";
        micStatus.classList.remove("loading-dot");

        await updateClassifications();
        await updateRiskTriage();
        } catch (e) {
        console.error(e);
        soapError.textContent =
          "Erro ao gerar evolução e plano de cuidados (falha de rede ou backend).";
        micStatus.innerText = "Falha ao gerar o resumo.";
        micStatus.classList.remove("loading-dot");
      }
    }

    function splitSoap(soapText) {
      const sections = { S: "", O: "", A: "", P: "" };
      if (!soapText) return sections;

      const regex = /\b([SOAP])\s*:\s*([\s\S]*?)(?=\b[SOAP]\s*:|$)/g;
      let match;
      while ((match = regex.exec(soapText)) !== null) {
        const key = match[1].toUpperCase();
        sections[key] = match[2].trim();
      }
      return sections;
    }

    function updateSoapFromString(soapText) {
      currentSoapRaw = soapText || "";
      const parts = splitSoap(currentSoapRaw);

      soapS.value = parts.S || "";
      soapO.value = parts.O || "";
      soapA.value = parts.A || "";
      soapP.value = parts.P || "";

      mountResultsCard(soapResultsMount);
      resultsCard.classList.remove("hidden");
      setResultsView("consulta");
    }

    function getCombinedSoapFromFields() {
      const s = soapS.value.trim();
      const o = soapO.value.trim();
      const a = soapA.value.trim();
      const p = soapP.value.trim();

      let combined = "";
      if (s) combined += "S: " + s + "\n";
      if (o) combined += "O: " + o + "\n";
      if (a) combined += "A: " + a + "\n";
      if (p) combined += "P: " + p;
      currentSoapRaw = combined;
      return combined;
    }


    function formatInteractionsList(interacoes, observacoes) {
      const items = Array.isArray(interacoes) ? interacoes : [];
      if (!items.length) {
        const obs = (observacoes || "").trim();
        return obs
          ? ("Nenhuma interação clinicamente relevante identificada com segurança para os medicamentos prescritos.\n\nObservações:\n" + obs)
          : "Nenhuma interação clinicamente relevante identificada com segurança para os medicamentos prescritos.";
      }

      const parts = [];
      for (const it of items) {
        const meds = Array.isArray(it?.medicamentos) ? it.medicamentos : [];
        const a = meds[0] ? String(meds[0]) : "não informado";
        const b = meds[1] ? String(meds[1]) : "não informado";
        const grav = it?.gravidade ? String(it.gravidade) : "indeterminada";
        const desc = it?.descricao ? String(it.descricao) : "";
        const riscos = it?.riscos ? String(it.riscos) : "";
        const conduta = it?.conduta ? String(it.conduta) : "";

        let block = a + " + " + b + " (gravidade: " + grav + ")";
        if (desc.trim()) block += "\nInteração: " + desc.trim();
        if (riscos.trim()) block += "\nRiscos: " + riscos.trim();
        if (conduta.trim()) block += "\nConduta: " + conduta.trim();
        parts.push(block);
      }

      const obs = (observacoes || "").trim();
      if (obs) {
        parts.push("Observações:\n" + obs);
      }
      return parts.join("\n\n");
    }


    

    function formatPresentationsMaxDoseList(itens) {
      const items = Array.isArray(itens) ? itens : [];
      if (!items.length) {
        return "Nenhuma informação disponível para os medicamentos prescritos.";
      }

      const lines = [];
      for (const it of items) {
        const med = it?.medicamento ? String(it.medicamento).trim() : "não informado";
        const a = it?.apresentacoes || {};
        const doseMax = it?.dosagem_maxima_diaria ? String(it.dosagem_maxima_diaria).trim() : "";

        lines.push("Medicamento: " + med);
        lines.push("Apresentações disponíveis:");

        const map = [
          ["Comprimido simples", a.comprimido_simples],
          ["Comprimido revestido", a.comprimido_revestido],
          ["Cápsula", a.capsula],
          ["Suspensão oral", a.suspensao_oral],
          ["Gotas", a.gotas],
          ["Solução oral", a.solucao_oral],
          ["Solução injetável", a.solucao_injetavel],
          ["Endovenosa", a.endovenosa],
          ["Intramuscular", a.intramuscular]
        ];

        for (const [label, val] of map) {
          const v = String(val || "").trim() || "não informado";
          lines.push("- " + label + ": " + v);
        }

        lines.push("Dosagem máxima diária: " + (doseMax || "não informado"));
        lines.push("");
      }

      return lines.join("\n").trim();
    }


    async function updateWoundCareFromContext(contexto) {
      if (!presentationsMaxDoseBox || !presentationsMaxDoseStatus) return;

      presentationsMaxDoseStatus.textContent = "Gerando registro de curativos e feridas...";
      presentationsMaxDoseStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/apresentacoes-dosagem-maxima", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ contexto })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP:", resp.status, txt);
          presentationsMaxDoseBox.textContent = "Falha ao gerar curativos.";
          return;
        }

        const data = await resp.json().catch(() => ({}));
        presentationsMaxDoseBox.textContent = (data.curativos || "").trim() || "Nenhum conteúdo disponível.";
      } catch (e) {
        console.error(e);
        presentationsMaxDoseBox.textContent = "Falha ao gerar curativos (rede/backend).";
      } finally {
        presentationsMaxDoseStatus.classList.remove("loading-dot");
        presentationsMaxDoseStatus.textContent = "";
      }
    }

    function updateQuestionsTimer() {
      const now = Date.now();
      const seconds = questionsAccumulatedSeconds + Math.floor((now - questionsStartTime) / 1000);
      const m = ("0" + Math.floor(seconds / 60)).slice(-2);
      const s = ("0" + (seconds % 60)).slice(-2);
      questionsTimerEl.innerText = `${m}:${s}`;
    }

    function startQuestionsTimer() {
      questionsStartTime = Date.now();
      if (questionsTimerInterval) clearInterval(questionsTimerInterval);
      questionsTimerInterval = setInterval(updateQuestionsTimer, 500);
    }

    function pauseQuestionsTimer() {
      if (!questionsStartTime) return;
      const now = Date.now();
      questionsAccumulatedSeconds += Math.floor((now - questionsStartTime) / 1000);
      if (questionsTimerInterval) clearInterval(questionsTimerInterval);
      questionsTimerInterval = null;
    }

    function resetQuestionsTimer() {
      if (questionsTimerInterval) clearInterval(questionsTimerInterval);
      questionsTimerInterval = null;
      questionsStartTime = null;
      questionsAccumulatedSeconds = 0;
      questionsTimerEl.innerText = "00:00";
    }

    function initQuestionsSpeech() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        return null;
      }

      const rec = new SR();
      rec.lang = "pt-BR";
      rec.continuous = true;
      rec.interimResults = true;

      rec.onresult = (event) => {
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            questionsFinalTranscript += transcript + " ";
          }
        }
      };

      rec.onerror = (event) => {
        console.error("Erro no reconhecimento das perguntas:", event.error);
        recommendationsStatus.textContent =
          "Ocorreu um erro no reconhecimento de voz das perguntas. Tente novamente.";
        recommendationsStatus.classList.remove("loading-dot");
      };

      rec.onend = () => {
        if (questionsIsRecording) {
          try {
            rec.start();
          } catch (err) {
            console.warn("Não foi possível retomar reconhecimento das perguntas:", err);
          }
        }
      };

      return rec;
    }

    function startQuestionsRecording() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        recommendationsStatus.textContent =
          "Seu navegador não suporta reconhecimento de voz. Use Google Chrome em um computador.";
        return;
      }

      if (!questionsRecognition) {
        questionsRecognition = initQuestionsSpeech();
        if (!questionsRecognition) return;
      }

      questionsIsRecording = true;
      questionsFinalTranscript = "";

      questionsTimerEl.classList.remove("hidden");
      resetQuestionsTimer();
      startQuestionsTimer();

      askQuestionsBtn.textContent = "Encerrar perguntas";
      closeRecommendationsBtn.disabled = true;
      closeRecommendationsBtn.style.opacity = "0.5";

      recommendationsStatus.textContent =
        "Gravando perguntas e respostas. Quando terminar, clique em \"Encerrar perguntas\".";
      recommendationsStatus.classList.remove("loading-dot");

      try {
        questionsRecognition.start();
      } catch (e) {
        console.warn("Erro ao iniciar reconhecimento das perguntas:", e);
      }
    }

    async function stopQuestionsRecordingAndUpdateSoap() {
      questionsIsRecording = false;

      if (questionsRecognition) {
        try {
          questionsRecognition.stop();
        } catch (e) {
          console.warn("Erro ao parar reconhecimento das perguntas:", e);
        }
      }

      pauseQuestionsTimer();

      const qa = (questionsFinalTranscript || "").trim();
      if (!qa) {
        recommendationsStatus.textContent = "Nenhuma fala foi capturada nesta rodada de perguntas.";
        askQuestionsBtn.textContent = "Complementar avaliação";
        closeRecommendationsBtn.disabled = false;
        closeRecommendationsBtn.style.opacity = "1";
        askQuestionsBtn.disabled = false;
        resetQuestionsTimer();
        questionsTimerEl.classList.add("hidden");
        return;
      }

      const soapAtual = getCombinedSoapFromFields();
      if (!soapAtual) {
        recommendationsStatus.textContent = "Não há SOAP disponível para atualizar.";
        askQuestionsBtn.textContent = "Complementar avaliação";
        closeRecommendationsBtn.disabled = false;
        closeRecommendationsBtn.style.opacity = "1";
        askQuestionsBtn.disabled = false;
        return;
      }

      askQuestionsBtn.disabled = true;
      recommendationsStatus.textContent = "Atualizando SOAP e módulos com as novas respostas...";
      recommendationsStatus.classList.add("loading-dot");

      const transcricaoBase = (baseTranscript || finalTranscript || "").trim();

      try {
        const resp = await fetch(BACKEND_URL + "/api/atualizar-soap-perguntas", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            soap_atual: soapAtual,
            perguntas_e_respostas: qa,
            transcricao_base: transcricaoBase
          })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (atualizar perguntas):", resp.status, txt);
          recommendationsStatus.textContent = "Não foi possível atualizar o SOAP com as novas respostas.";
          recommendationsStatus.classList.remove("loading-dot");
          askQuestionsBtn.disabled = false;
          return;
        }

        const data = await resp.json();
        const soap = data.soap || "";
        const evolucao_enfermagem = data.evolucao_enfermagem || "";
        const prescricao = data.prescricao || "";

        if (soap) {
          updateSoapFromString(soap);
        }
        if (nursingEvolutionOutput) nursingEvolutionOutput.value = evolucao_enfermagem;
        if (prescricao) {
          prescriptionOutput.value = prescricao;
          printBtn.style.display = "inline-block";
        }

        const appended =
          (transcricaoBase ? transcricaoBase + "\n\n" : "") +
          "RODADA ADICIONAL DE PERGUNTAS E RESPOSTAS:\n" +
          qa +
          "\n";
        baseTranscript = appended;
        finalTranscript = appended;

        recommendationsStatus.textContent = "SOAP atualizado com as novas respostas.";
        recommendationsStatus.classList.remove("loading-dot");

        await updateClassifications();
        await updateRiskTriage();
      } catch (err) {
        console.error("Erro geral ao atualizar SOAP com perguntas:", err);
        recommendationsStatus.textContent = "Erro ao atualizar o SOAP com as novas respostas.";
        recommendationsStatus.classList.remove("loading-dot");
      } finally {
        askQuestionsBtn.textContent = "Complementar avaliação";
        askQuestionsBtn.disabled = false;
        closeRecommendationsBtn.disabled = false;
        closeRecommendationsBtn.style.opacity = "1";
        resetQuestionsTimer();
        questionsTimerEl.classList.add("hidden");
        recommendationsPanel.classList.remove("visible");
      }
    }

    async function fetchRecommendations() {
      const combinedSoap = getCombinedSoapFromFields();
      if (!combinedSoap) {
        soapError.textContent =
          "Não há SOAP gerado ainda para sugerir perguntas complementares.";
        return;
      }

      // Reseta qualquer rodada anterior de perguntas
      if (questionsIsRecording && questionsRecognition) {
        try {
          questionsIsRecording = false;
          questionsRecognition.stop();
        } catch (e) {}
      }
      askQuestionsBtn.textContent = "Complementar avaliação";
      askQuestionsBtn.disabled = true;
      closeRecommendationsBtn.disabled = false;
      closeRecommendationsBtn.style.opacity = "1";
      resetQuestionsTimer();
      questionsTimerEl.classList.add("hidden");

      recommendationsPanel.classList.add("visible");
      recommendationsStatus.textContent =
        "Gerando perguntas complementares essenciais com base na queixa e no SOAP...";
      recommendationsStatus.classList.add("loading-dot");
      recommendationsList.innerHTML = "";


      try {
        const resp = await fetch(BACKEND_URL + "/api/recomendacoes-anamnese", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            soap: combinedSoap
          })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error(
            "Erro HTTP do backend (recomendações):",
            resp.status,
            txt
          );
          recommendationsStatus.textContent =
            "Não foi possível gerar as recomendações de perguntas.";
          recommendationsStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const perguntas = Array.isArray(data.perguntas) ? data.perguntas : [];

        if (!perguntas.length) {
          recommendationsStatus.textContent =
            "Nenhuma pergunta complementar foi sugerida para este caso.";
          recommendationsStatus.classList.remove("loading-dot");
          return;
        }

        recommendationsList.innerHTML = "";
        perguntas.forEach((q, index) => {
          const item = document.createElement("div");
          item.className = "recommendation-item";
          item.textContent = (index + 1) + ". " + q;
          recommendationsList.appendChild(item);
        });

        recommendationsStatus.textContent =
          "Use estas perguntas para aprofundar a anamnese com o paciente.";
        recommendationsStatus.classList.remove("loading-dot");
        askQuestionsBtn.disabled = false;
      } catch (err) {
        console.error("Erro geral ao buscar recomendações:", err);
        recommendationsStatus.textContent =
          "Erro ao gerar recomendações de perguntas.";
        recommendationsStatus.classList.remove("loading-dot");
      }
    }

    async function handleAskQuestionsFromPanel() {
      if (!questionsIsRecording) {
        startQuestionsRecording();
      } else {
        await stopQuestionsRecordingAndUpdateSoap();
      }
    }

    function startRecording() {
      if (triageIsRecording) {
        alert("Finalize a triagem hospitalar antes de iniciar a consulta.");
        return;
      }
      if (!recognition) {
        initSpeech();
        if (!recognition) {
          return;
        }
      }

      isRecording = true;
      isPaused = false;
      if (triageRecordBtn) triageRecordBtn.disabled = true;
      finalTranscript = "";
      baseTranscript = "";
      resultsCard.classList.add("hidden");
      printBtn.style.display = "none";
      prescriptionOutput.value = "";
      if (nursingEvolutionOutput) nursingEvolutionOutput.value = "";
      soapS.value = "";
      soapO.value = "";
      soapA.value = "";
      soapP.value = "";
      resetNewModulesUI();

      pauseBtn.style.display = "inline-block";
      pauseBtn.innerText = "Pausar";
      recordBtn.className = "recording";
      recordBtn.innerText = "Encerrar consulta";
      micStatus.innerText = "Gravando consulta...";
      soapError.textContent = "";
      resultsCard.classList.add("hidden");

      resetLiveGuidanceState();
      renderLiveGuidance();
      startGuidanceLoop();

      resetTimer();
      startTimer();

      try {
        recognition.start();
      } catch (e) {
        console.warn("Erro ao iniciar reconhecimento:", e);
      }
    }

    function stopRecording() {
      isRecording = false;
      isPaused = false;

      stopGuidanceLoop();
      interimTranscript = "";
      renderLiveGuidance();

      if (recognition) {
        try {
          recognition.stop();
        } catch (e) {
          console.warn("Erro ao parar reconhecimento:", e);
        }
      }
      pauseTimer();
      recordBtn.className = "start";
      recordBtn.innerText = "Iniciar atendimento";
      pauseBtn.style.display = "none";
      if (triageRecordBtn) triageRecordBtn.disabled = false;
    }

    function pauseRecording() {
      if (!isRecording || isPaused) return;
      isPaused = true;

      stopGuidanceLoop();
      if (liveGuidanceStatus) liveGuidanceStatus.textContent = "Consulta pausada. As sugestões em tempo real serão retomadas ao retomar a gravação.";

      if (recognition) {
        try {
          recognition.stop();
        } catch (e) {
          console.warn("Erro ao pausar reconhecimento:", e);
        }
      }
      pauseTimer();
      pauseBtn.innerText = "Retomar";
      micStatus.innerText = "Consulta pausada.";
    }

    function resumeRecording() {
      if (!isRecording || !isPaused) return;
      isPaused = false;

      startGuidanceLoop();

      if (recognition) {
        try {
          recognition.start();
        } catch (e) {
          console.warn("Erro ao retomar reconhecimento:", e);
        }
      }
      startTimer();
      pauseBtn.innerText = "Pausar";
      micStatus.innerText = "Gravando consulta...";
    }

    
    
    
    
    
    
    
    
    
            
    function copyToClipboard(text) {
      if (!text) return;
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).catch(() => {
          alert("Não foi possível copiar o texto.");
        });
      } else {
        const temp = document.createElement("textarea");
        temp.value = text;
        document.body.appendChild(temp);
        temp.select();
        try {
          document.execCommand("copy");
        } catch (e) {
          alert("Não foi possível copiar o texto.");
        }
        document.body.removeChild(temp);
      }
    }

    // =========================
    // Saídas formatadas (parágrafos com espaçamento + tópicos em vermelho/negrito)
    // =========================
    function escapeHtml(s) {
      return String(s || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function looksLikeHeadingLine(line) {
      const s = String(line || "").trim();
      if (!s) return false;
      if (/^\d{1,2}:\d{2}$/.test(s)) return false; // evita horários
      if (s.length > 90) return false;
      if (!/:\s*$/.test(s)) return false;
      return /[A-Za-zÀ-ÿ]/.test(s);
    }

    function wrapTopicInline(line) {
      const s = String(line || "");
      const m = s.match(/^\s*([A-Za-zÀ-ÿ][A-Za-zÀ-ÿ0-9\s\-\(\)\/]{1,80}:)\s*(.*)$/);
      if (!m) return null;
      const label = (m[1] || "").trim();
      const rest = (m[2] || "").trim();
      if (!/[A-Za-zÀ-ÿ]/.test(label) || /^\d{1,2}:\d{2}:$/.test(label)) return null;
      return { label, rest };
    }

    function isBulletLine(line) {
      return /^\s*(?:[-•*]|\d+\.)\s+/.test(String(line || ""));
    }

    function formatTextToHtml(rawText) {
      const original = String(rawText || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
      const trimmed = original.trim();
      if (!trimmed) return "<p>Nenhum conteúdo disponível.</p>";

      // Cria "respiros" antes de linhas que parecem títulos (ex.: "Descrição:", "Conduta:", etc.)
      const withBreaks = trimmed.replace(
        /([^\n])\n(?=[A-Za-zÀ-ÿ][A-Za-zÀ-ÿ0-9\s\-\(\)\/]{1,80}:\s*(?:\n|$))/g,
        "$1\n\n"
      );

      const blocks = withBreaks.split(/\n\s*\n+/);

      const out = [];
      for (const block of blocks) {
        const b = String(block || "").trim();
        if (!b) continue;

        const lines = b.split("\n");
        const allBullet = lines.length > 1 && lines.every(isBulletLine);

        if (allBullet) {
          const isOrdered = lines.every(x => /^\s*\d+\./.test(x));
          const tag = isOrdered ? "ol" : "ul";
          const items = lines
            .map(x => x.replace(/^\s*(?:[-•*]|\d+\.)\s+/, "").trim())
            .filter(Boolean);
          const li = items.map(x => `<li>${escapeHtml(x)}</li>`).join("");
          out.push(`<${tag}>${li}</${tag}>`);
          continue;
        }

        // Título isolado (termina com ":")
        if (lines.length === 1 && looksLikeHeadingLine(lines[0])) {
          out.push(`<p><span class="topic">${escapeHtml(lines[0].trim())}</span></p>`);
          continue;
        }

        // Bloco com primeira linha como título + conteúdo abaixo
        if (lines.length >= 2 && looksLikeHeadingLine(lines[0])) {
          const head = lines[0].trim();
          const rest = lines.slice(1).join("\n").trim();
          const restHtml = escapeHtml(rest).replace(/\n/g, "<br>");
          out.push(`<p><span class="topic">${escapeHtml(head)}</span><br>${restHtml}</p>`);
          continue;
        }

        // Linha única no formato "Tópico: conteúdo"
        if (lines.length === 1) {
          const t = wrapTopicInline(lines[0]);
          if (t) {
            if (t.rest) out.push(`<p><span class="topic">${escapeHtml(t.label)}</span> ${escapeHtml(t.rest)}</p>`);
            else out.push(`<p><span class="topic">${escapeHtml(t.label)}</span></p>`);
            continue;
          }
        }

        // Texto livre (preserva quebras de linha internas)
        out.push(`<p>${escapeHtml(b).replace(/\n/g, "<br>")}</p>`);
      }

      return out.length ? out.join("") : "<p>Nenhum conteúdo disponível.</p>";
    }

    function setFormattedOutput(el, text) {
      if (!el) return;
      el.classList.add("formatted-output");
      el.innerHTML = formatTextToHtml(text);
    }

    function setPlainOutput(el, text) {
      if (!el) return;
      el.classList.remove("formatted-output");
      el.textContent = String(text || "");
    }

// =========================
    // IMAGENS - compressão + análise automática (até 4 fotos por módulo)
    // =========================
    async function fileToCompressedDataUrl(file, maxDim = 1280, quality = 0.82) {
  // Tenta converter para JPEG via canvas (reduz tamanho e evita estouro de limite).
  // Se falhar (ex.: formatos não suportados), retorna string vazia para permitir fallback.
  const f = file;
  if (!f) return "";

  const objectUrl = URL.createObjectURL(f);
  try {
    const img = await new Promise((resolve, reject) => {
      const i = new Image();
      i.onload = () => resolve(i);
      i.onerror = () => reject(new Error("Falha ao carregar a imagem."));
      i.src = objectUrl;
    });

    const w = img.naturalWidth || img.width || 0;
    const h = img.naturalHeight || img.height || 0;
    if (!w || !h) throw new Error("Dimensões inválidas.");

    const scale = Math.min(1, maxDim / Math.max(w, h));
    const outW = Math.max(1, Math.round(w * scale));
    const outH = Math.max(1, Math.round(h * scale));

    const canvas = document.createElement("canvas");
    canvas.width = outW;
    canvas.height = outH;

    const ctx = canvas.getContext("2d");
    if (!ctx) throw new Error("Falha ao preparar canvas.");
    ctx.drawImage(img, 0, 0, outW, outH);

    return canvas.toDataURL("image/jpeg", quality);
  } catch (e) {
    return "";
  } finally {
    URL.revokeObjectURL(objectUrl);
  }
}

function fileToDataUrl(file) {
  return new Promise((resolve, reject) => {
    try {
      const reader = new FileReader();
      reader.onload = () => resolve(String(reader.result || ""));
      reader.onerror = () => reject(new Error("Falha ao ler arquivo."));
      reader.readAsDataURL(file);
    } catch (e) {
      reject(e);
    }
  });
}

async function addFilesToTarget(files, targetKey, mode) {
  const list = Array.from(files || []);
  if (!list.length) return;

  const key = (targetKey === "wound" || targetKey === "med" || targetKey === "exam" || targetKey === "transcription" || targetKey === "apraz" || targetKey === "rxEval") ? targetKey : "med";

  const cfg = key === "wound"
    ? { arr: woundImages, statusEl: presentationsMaxDoseStatus, boxEl: presentationsMaxDoseBox, update: updateWoundActions, schedule: scheduleWoundAnalysis }
    : key === "exam"
      ? { arr: examImages, statusEl: examInterpretationStatus, boxEl: examInterpretationBox, update: updateExamActions, schedule: scheduleExamAnalysis }
      : key === "transcription"
        ? { arr: transcriptionImages, statusEl: transcriptionStatus, boxEl: transcriptionBox, update: updateTranscriptionActions, schedule: scheduleTranscriptionAnalysis }
        : key === "rxEval"
          ? { arr: rxEvalImages, statusEl: rxEvalStatus, boxEl: rxEvalTranscription, update: updateRxEvalActions, schedule: scheduleRxEvalAnalysis }
        : key === "apraz"
          ? { arr: aprazImages, statusEl: aprazamentoStatus, boxEl: aprazamentoSheetWrapper, update: updateAprazamentoActions, schedule: scheduleAprazAnalysis }
          : { arr: [], statusEl: null, boxEl: null, update: null, schedule: null };

  const arr = cfg.arr;
  const statusEl = cfg.statusEl;
  const boxEl = cfg.boxEl;

  if (mode === "replace") {
    arr.length = 0;
  }

  // Feedback imediato (para não parecer que "não aconteceu nada")
  setElementText(statusEl, "Carregando imagem(ns).");
  setElementText(boxEl, "Processando.");
  if (cfg && cfg.update) cfg.update();

  const remaining = Math.max(0, 4 - arr.length);
  const slice = list.slice(0, remaining);

  let added = 0;
  let failed = 0;

  for (const file of slice) {
    try {
      // 1) tenta canvas->JPEG (melhor para upload)
      let dataUrl = await fileToCompressedDataUrl(file);
      // 2) fallback: dataURL direto (quando canvas falha)
      if (!dataUrl) dataUrl = await fileToDataUrl(file);

      if (dataUrl && dataUrl.startsWith("data:image/")) {
        arr.push(dataUrl);
        added += 1;
      } else {
        failed += 1;
      }
    } catch (e) {
      failed += 1;
    }
  }

  if (!arr.length) {
    const msg = "Não foi possível ler a imagem selecionada neste aparelho. Tente usar JPG/PNG (ou ajuste a câmera para modo mais compatível).";
    if (statusEl) statusEl.textContent = msg;
    if (boxEl) boxEl.textContent = "Nenhum conteúdo disponível.";
    if (cfg && cfg.update) cfg.update();
    return;
  }

  // Dispara análise automática
  const countMsg = arr.length + " imagem(ns) selecionada(s). Enviando para análise.";
  if (statusEl) statusEl.textContent = countMsg;

  if (cfg && cfg.schedule) cfg.schedule();
}
    async function analyzeWoundWithImages(dataUrls) {
  if (!presentationsMaxDoseStatus || !presentationsMaxDoseBox) return;

  const images = Array.isArray(dataUrls) ? dataUrls.filter(Boolean) : [];
  if (!images.length) {
    presentationsMaxDoseStatus.textContent = "Nenhuma imagem selecionada.";
    setPlainOutput(presentationsMaxDoseBox, "Nenhum conteúdo disponível.");
    updateWoundActions();
    return;
  }

  presentationsMaxDoseStatus.textContent = "Analisando imagem(ns) da lesão.";
  setPlainOutput(presentationsMaxDoseBox, "Processando.");
  updateWoundActions();

  try {
    const payload = {
      images_data_url: images,
      image_data_url: images[0] // compatibilidade
    };

    const resp = await fetch(BACKEND_URL + "/api/analisar-lesao-imagem", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const data = await resp.json().catch(() => ({}));
    if (!resp.ok) throw new Error(data?.error || "Falha ao analisar imagem.");

    const texto = (data?.texto || "").trim();
    setFormattedOutput(presentationsMaxDoseBox, texto || "Nenhum conteúdo disponível.");
    presentationsMaxDoseStatus.textContent = "Análise concluída.";
    updateWoundActions();
  } catch (e) {
    presentationsMaxDoseStatus.textContent = "Falha ao analisar imagem. " + (e && e.message ? e.message : "");
    setPlainOutput(presentationsMaxDoseBox, "Nenhum conteúdo disponível.");
    updateWoundActions();
  }
}


    function buildMonographText(m) {
  if (!m || typeof m !== 'object') return 'Nenhum conteúdo disponível.';

  const ln = [];

  function isMeaningful(v) {
    const s = (v === null || v === undefined) ? '' : String(v).trim();
    if (!s) return false;
    const low = s.toLowerCase();
    if (low === 'não informado' || low === 'nao informado') return false;
    return true;
  }

  function pushKeyVal(k, v) {
    if (!isMeaningful(v)) return;
    ln.push(k + ': ' + String(v).trim());
  }

  function pushList(k, arr) {
    const a = Array.isArray(arr)
      ? Array.from(new Set(arr.map(x => (x === null || x === undefined) ? '' : String(x).trim()).filter(isMeaningful)))
      : [];
    if (!a.length) return;
    ln.push(k + ':');
    for (const it of a) ln.push('- ' + it);
    ln.push('');
  }

  // Cabeçalho (sem título "Monografia")
  pushKeyVal('Medicamento', m.medicamento || m.nome || m.principio_ativo);
  pushKeyVal('Classe', m.classe);
  pushKeyVal('Mecanismo de ação', m.mecanismo_acao);
  if (ln.length) ln.push('');

  // Apresentações: mostrar apenas as que existirem
  const ap = (m.apresentacoes && typeof m.apresentacoes === 'object') ? m.apresentacoes : {};
  const apKeys = [
    ['Solução oral', 'solucao_oral'],
    ['Gotas', 'gotas'],
    ['Suspensão', 'suspensao'],
    ['Xarope', 'xarope'],
    ['Comprimidos', 'comprimidos'],
    ['Cápsulas', 'capsulas'],
    ['Injetável', 'injetavel'],
    ['Supositório', 'supositorio'],
    ['Tópicos', 'topicos'],
    ['Inalatório', 'inalatorio'],
    ['Outros', 'outros']
  ];
  const apLines = [];
  for (const [label, key] of apKeys) {
    const v = ap ? ap[key] : '';
    if (!isMeaningful(v)) continue;
    apLines.push('- ' + label + ': ' + String(v).trim());
  }
  if (apLines.length) {
    ln.push('Apresentações:');
    for (const x of apLines) ln.push(x);
    ln.push('');
  }

  pushList('Uso clínico', m.uso_clinico);
  pushKeyVal('Tipo de receituário', m.tipo_receituario);
  if (ln.length && ln[ln.length - 1] !== '') ln.push('');

  // Posologia adulta: mostrar apenas vias com conteúdo
  const ad = (m.posologia_adulta && typeof m.posologia_adulta === 'object') ? m.posologia_adulta : {};
  const viasAd = [
    ['oral', 'Oral'],
    ['injetavel', 'Injetável'],
    ['outros', 'Outros']
  ];
  const adBlocks = [];
  for (const [k, label] of viasAd) {
    const v = (ad && ad[k] && typeof ad[k] === 'object') ? ad[k] : {};
    const lines = [];
    if (isMeaningful(v.dose_usual)) lines.push('- Dose usual: ' + String(v.dose_usual).trim());
    if (isMeaningful(v.dose_maxima)) lines.push('- Dose máxima: ' + String(v.dose_maxima).trim());
    if (isMeaningful(v.observacoes)) lines.push('- Observações: ' + String(v.observacoes).trim());
    if (lines.length) {
      adBlocks.push(label + ':');
      adBlocks.push(...lines);
      adBlocks.push('');
    }
  }
  if (adBlocks.length) {
    ln.push('Posologia adulta (por via):');
    ln.push(...adBlocks);
  }

  pushKeyVal('Categoria na gravidez', m.categoria_gravidez);
  pushKeyVal('Uso na lactação', m.uso_lactacao);
  pushKeyVal('Uso geriátrico', m.uso_geriatrico);
  if (ln.length && ln[ln.length - 1] !== '') ln.push('');

  // Posologia pediátrica: mostrar apenas vias/apresentações com conteúdo
  const pd = (m.posologia_pediatrica && typeof m.posologia_pediatrica === 'object') ? m.posologia_pediatrica : {};
  const pdKeys = [
    ['oral', 'Oral'],
    ['gotas', 'Gotas'],
    ['xarope', 'Xarope'],
    ['comprimido_capsula', 'Comprimido/Cápsula'],
    ['injetavel', 'Injetável']
  ];
  const pdBlocks = [];
  for (const [k, label] of pdKeys) {
    const v = (pd && pd[k] && typeof pd[k] === 'object') ? pd[k] : {};
    const lines = [];
    const dose = v.dose_mgkg || v.dose;
    const intervalo = v.intervalo || v.frequencia;
    if (isMeaningful(dose)) lines.push('- Dose (mg/kg ou equivalente): ' + String(dose).trim());
    if (isMeaningful(intervalo)) lines.push('- Intervalo/frequência: ' + String(intervalo).trim());
    if (isMeaningful(v.dose_maxima)) lines.push('- Dose máxima: ' + String(v.dose_maxima).trim());
    if (isMeaningful(v.restricoes_etarias)) lines.push('- Restrições etárias: ' + String(v.restricoes_etarias).trim());
    if (isMeaningful(v.modo_uso)) lines.push('- Modo de uso: ' + String(v.modo_uso).trim());
    if (lines.length) {
      pdBlocks.push(label + ':');
      pdBlocks.push(...lines);
      pdBlocks.push('');
    }
  }
  if (pdBlocks.length) {
    ln.push('Posologia pediátrica (por via/apresentação):');
    ln.push(...pdBlocks);
  }

  pushList('Interações medicamentosas', m.interacoes_medicamentosas);
  pushList('Pontos de enfermagem', m.pontos_enfermagem);

  return ln.join('\n').trim();
}

function showMedMonographOverlay(show) {
  if (!medMonographOverlay) return;
  if (show) medMonographOverlay.classList.remove('hidden');
  else medMonographOverlay.classList.add('hidden');
}

async function openMedicationMonograph(name) {
  const medName = String(name || '').trim();
  if (!medName) return;
  if (medMonographTitle) medMonographTitle.textContent = 'Informações do medicamento: ' + medName;
  if (medMonographStatus) medMonographStatus.textContent = 'Carregando informações do medicamento.';
  if (medMonographContent) medMonographContent.textContent = 'Processando.';
  if (medMonographContent && medMonographContent.dataset) medMonographContent.dataset.copyText = '';
  showMedMonographOverlay(true);

  try {
    const resp = await fetch(BACKEND_URL + '/api/medicamento-monografia', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ medicamento: medName })
    });
    const data = await resp.json().catch(() => ({}));
    if (!resp.ok) throw new Error(data?.error || 'Falha ao obter informações do medicamento.');
    const monografia = data?.monografia || data || {};
    const txt = buildMonographText(monografia);
    if (medMonographContent) {
      medMonographContent.textContent = txt || 'Nenhum conteúdo disponível.';
      if (medMonographContent.dataset) medMonographContent.dataset.copyText = medMonographContent.textContent;
    }
    if (medMonographStatus) medMonographStatus.textContent = 'Informações prontas.';
  } catch (e) {
    if (medMonographStatus) medMonographStatus.textContent = 'Falha ao obter informações do medicamento. ' + (e && e.message ? e.message : '');
    if (medMonographContent) medMonographContent.textContent = 'Nenhum conteúdo disponível.';
  }
}




    async function analyzeExamWithImages(dataUrls) {
  if (!examInterpretationStatus || !examInterpretationBox) return;

  const images = Array.isArray(dataUrls) ? dataUrls.filter(Boolean) : [];
  if (!images.length) {
    examInterpretationStatus.textContent = "Nenhuma imagem selecionada.";
    setPlainOutput(examInterpretationBox, "Nenhum conteúdo disponível.");
    updateExamActions();
    return;
  }

  examInterpretationStatus.textContent = "Analisando exame (imagem(ns)).";
  setPlainOutput(examInterpretationBox, "Processando.");
  updateExamActions();

  try {
    const payload = {
      images_data_url: images,
      image_data_url: images[0] // compatibilidade
    };

    const resp = await fetch(BACKEND_URL + "/api/interpretar-exame-imagem", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const data = await resp.json().catch(() => ({}));
    if (!resp.ok) throw new Error(data?.error || "Falha ao interpretar o exame.");

    const texto = (data?.texto || "").trim();
    setFormattedOutput(examInterpretationBox, texto || "Nenhum conteúdo disponível.");
    examInterpretationStatus.textContent = "Análise concluída.";
    updateExamActions();
  } catch (e) {
    examInterpretationStatus.textContent = "Falha ao interpretar o exame. " + (e && e.message ? e.message : "");
    setPlainOutput(examInterpretationBox, "Nenhum conteúdo disponível.");
    updateExamActions();
  }
}

    async function analyzeTranscriptionWithImages(dataUrls) {
  if (!transcriptionStatus || !transcriptionBox) return;

  const images = Array.isArray(dataUrls) ? dataUrls.filter(Boolean) : [];
  if (!images.length) {
    transcriptionStatus.textContent = "Nenhuma imagem selecionada.";
    setPlainOutput(transcriptionBox, "Nenhum conteúdo disponível.");
    updateTranscriptionActions();
    return;
  }

  transcriptionStatus.textContent = "Transcrevendo documento (imagem(ns)).";
  setPlainOutput(transcriptionBox, "Processando.");
  updateTranscriptionActions();

  try {
    const payload = {
      images_data_url: images,
      image_data_url: images[0] // compatibilidade
    };

    const resp = await fetch(BACKEND_URL + "/api/transcrever-documento-imagem", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const data = await resp.json().catch(() => ({}));
    if (!resp.ok) throw new Error(data?.error || "Falha ao transcrever o documento.");

    const texto = (data?.texto || "").trim();
    setFormattedOutput(transcriptionBox, texto || "Nenhum conteúdo disponível.");
    transcriptionStatus.textContent = "Transcrição concluída.";
    updateTranscriptionActions();
  } catch (e) {
    transcriptionStatus.textContent = "Falha ao transcrever o documento. " + (e && e.message ? e.message : "");
    setPlainOutput(transcriptionBox, "Nenhum conteúdo disponível.");
    updateTranscriptionActions();
  }
}


    function asStr(v) {
      if (v === null || v === undefined) return "";
      return String(v);
    }

    function normalizeHHMM(t) {
      const s = asStr(t).trim();
      if (!s) return "";
      const m = s.match(/(\d{1,2})\s*[:hH]\s*(\d{2})/);
      if (m) {
        const hh = String(Math.min(23, Math.max(0, parseInt(m[1], 10)))).padStart(2, "0");
        const mm = String(Math.min(59, Math.max(0, parseInt(m[2], 10)))).padStart(2, "0");
        return `${hh}:${mm}`;
      }
      const m2 = s.match(/^\s*(\d{1,2})\s*$/);
      if (m2) {
        const hh = String(Math.min(23, Math.max(0, parseInt(m2[1], 10)))).padStart(2, "0");
        return `${hh}:00`;
      }
      return "";
    }

    function uniq(list) {
      const out = [];
      const seen = new Set();
      for (const x of (Array.isArray(list) ? list : [])) {
        const v = String(x || "").trim();
        if (!v) continue;
        const k = v.toLowerCase();
        if (seen.has(k)) continue;
        seen.add(k);
        out.push(v);
      }
      return out;
    }

    function inferIntervalHours(freqText) {
      const t = asStr(freqText).toLowerCase();
      if (!t) return null;

      const m0 = t.match(/\b(\d{1,2})\s*\/\s*h\b/);
      if (m0) {
        const n = parseInt(m0[1], 10);
        if (Number.isFinite(n) && n > 0 && n <= 24) return n;
      }

      const mA = t.match(/(\d{1,2})\s*\/\s*(\d{1,2})\s*h/);
      if (mA) {
        const n = parseInt(mA[2], 10);
        if (Number.isFinite(n) && n > 0 && n <= 24) return n;
      }

      const mB = t.match(/(\d{1,2})\s*\/\s*(\d{1,2})/);
      if (mB) {
        const n = parseInt(mB[2], 10);
        if (Number.isFinite(n) && n > 0 && n <= 24) return n;
      }

      const mC = t.match(/\b(q|a cada)\s*(\d{1,2})\s*h\b/);
      if (mC) {
        const n = parseInt(mC[2], 10);
        if (Number.isFinite(n) && n > 0 && n <= 24) return n;
      }

      const mD = t.match(/\bde\s*(\d{1,2})\s*\/\s*de\s*(\d{1,2})\s*h\b/);
      if (mD) {
        const n = parseInt(mD[2], 10);
        if (Number.isFinite(n) && n > 0 && n <= 24) return n;
      }

      return null;
    }

    function inferTimesPerDay(freqText) {
      const t = asStr(freqText).toLowerCase();
      if (!t) return null;

      const m1 = t.match(/\b(\d)\s*x\s*ao\s*dia\b/);
      if (m1) {
        const n = parseInt(m1[1], 10);
        if (Number.isFinite(n) && n >= 1 && n <= 12) return n;
      }

      const m2 = t.match(/\b(\d)\s*vez(es)?\s*ao\s*dia\b/);
      if (m2) {
        const n = parseInt(m2[1], 10);
        if (Number.isFinite(n) && n >= 1 && n <= 12) return n;
      }

      return null;
    }

    function suggestStandardTimes(intervalHours, timesPerDay, freqText) {
      const t = asStr(freqText).toLowerCase();

      if (/\b(se necess[aá]rio|s\/n|sn|prn|acm|quando necess[aá]rio)\b/.test(t)) return [];
      if (/\b(cont[ií]nuo|bomba|infus[aã]o cont[ií]nua)\b/.test(t)) return [];

      const hasHs = /\b(hs|ao deitar|noite)\b/.test(t);
      if (hasHs) return ["22:00"];

      const hasManha = /\b(man[hã]a)\b/.test(t);
      const hasTarde = /\b(tarde)\b/.test(t);

      if (!intervalHours && timesPerDay) {
        if (timesPerDay === 1) return ["06:00"];
        if (timesPerDay === 2) return ["06:00", "18:00"];
        if (timesPerDay === 3) return ["06:00", "14:00", "22:00"];
        if (timesPerDay === 4) return ["06:00", "12:00", "18:00", "00:00"];
      }

      if (intervalHours === 24) return ["06:00"];
      if (intervalHours === 12) return ["06:00", "18:00"];
      if (intervalHours === 8) return ["06:00", "14:00", "22:00"];
      if (intervalHours === 6) return ["00:00", "06:00", "12:00", "18:00"];
      if (intervalHours === 4) return ["00:00", "04:00", "08:00", "12:00", "16:00", "20:00"];
      if (intervalHours === 3) return ["00:00", "03:00", "06:00", "09:00", "12:00", "15:00", "18:00", "21:00"];
      if (intervalHours === 2) return ["00:00", "02:00", "04:00", "06:00", "08:00", "10:00", "12:00", "14:00", "16:00", "18:00", "20:00", "22:00"];
      if (intervalHours === 1) {
        const arr = [];
        for (let h = 0; h < 24; h++) arr.push(String(h).padStart(2, "0") + ":00");
        return arr;
      }

      if (hasManha && !hasTarde) return ["08:00"];
      if (hasTarde && !hasManha) return ["14:00"];

      return [];
    }

    function formatMinutesToHHMM(totalMinutes) {
      const m = ((Number(totalMinutes) || 0) % 1440 + 1440) % 1440;
      const hh = String(Math.floor(m / 60) % 24).padStart(2, "0");
      const mm = String(m % 60).padStart(2, "0");
      return `${hh}:${mm}`;
    }

    // Define o primeiro horário da grade baseado no relógio local.
    // Regra:
    // - A grade trabalha em blocos de 2 horas.
    // - Se o horário atual estiver até 15 minutos após um bloco, usa o bloco anterior.
    // - Caso contrário, arredonda para o próximo bloco.
    function getAprazStartInfo(dateObj) {
      const now = (dateObj instanceof Date) ? dateObj : new Date();
      const nowMin = (now.getHours() * 60) + now.getMinutes();
      const stepMin = 120;
      const graceMin = 15;
      const floor = Math.floor(nowMin / stepMin) * stepMin;
      const useFloor = (nowMin - floor) <= graceMin;
      const startMin = (useFloor ? floor : (Math.ceil(nowMin / stepMin) * stepMin)) % 1440;
      return {
        nowMin,
        startMin,
        nowHHMM: formatMinutesToHHMM(nowMin),
        startHHMM: formatMinutesToHHMM(startMin),
        stepMin,
        graceMin
      };
    }

    function buildHourColumnsFromStart(startMin, stepMin) {
      const cols = [];
      const step = (Number(stepMin) || 120);
      const start = (Number(startMin) || 0);
      for (let i = 0; i < 1440; i += step) {
        cols.push(formatMinutesToHHMM(start + i));
      }
      return cols;
    }

    function buildHourColumns2h(startInfo) {
      const info = (startInfo && typeof startInfo === "object") ? startInfo : getAprazStartInfo(new Date());
      return buildHourColumnsFromStart(info.startMin, 120);
    }

    function generateTimesFromStart(startMin, intervalHours) {
      const ih = Number(intervalHours);
      if (!Number.isFinite(ih) || ih <= 0) return [];
      const step = Math.round(ih * 60);
      if (!step || step <= 0) return [];
      const arr = [];
      for (let offset = 0; offset < 1440; offset += step) {
        arr.push(formatMinutesToHHMM((Number(startMin) || 0) + offset));
      }
      return arr;
    }

    function timesToText(times) {
      const arr = uniq((Array.isArray(times) ? times : []).map(normalizeHHMM).filter(Boolean));
      return arr.join(", ");
    }

    function isDue(colHHMM, times) {
      const col = normalizeHHMM(colHHMM);
      if (!col) return false;
      const colH = col.slice(0, 2);
      const colM = col.slice(3, 5);

      for (const t of (Array.isArray(times) ? times : [])) {
        const tt = normalizeHHMM(t);
        if (!tt) continue;
        if (tt.slice(0, 2) === colH && tt.slice(3, 5) === colM) return true;
      }
      return false;
    }

    function safeField(v) {
      const s = asStr(v).trim();
      return s ? s : "não informado";
    }

    
    function setElementText(el, text) {
      if (!el) return;
      const t = (text === null || text === undefined) ? "" : String(text);
      if (el.tagName === "TEXTAREA" || el.tagName === "INPUT") el.value = t;
      else el.textContent = t;
      if (el.dataset) el.dataset.copyText = t;
    }

    function escapeText(v) {
      return escapeHtml(String(v === null || v === undefined ? "" : v));
    }

    function buildMonographHtml(m) {
      if (!m || typeof m !== "object") return '<div class="rx-paragraph">Nenhum conteúdo disponível.</div>';

      const parts = [];
      const pushTopic = (title) => parts.push('<div class="rx-topic">' + escapeText(title) + '</div>');
      const isMeaningful = (v) => {
        const s = String(v === null || v === undefined ? "" : v).trim();
        if (!s) return false;
        const low = s.toLowerCase();
        return low !== "não informado" && low !== "nao informado";
      };
      const pushP = (txt) => {
        const s = String(txt === null || txt === undefined ? "" : txt).trim();
        if (!s || s.toLowerCase() === "não informado" || s.toLowerCase() === "nao informado") return;
        parts.push('<div class="rx-paragraph">' + escapeText(s) + "</div>");
      };
      const pushList = (arr) => {
        const a = Array.isArray(arr)
          ? arr.map(x => String(x || "").trim()).filter(x => isMeaningful(x))
          : [];
        if (!a.length) return;
        parts.push('<ul style="margin: 0 0 10px 18px;">' + a.map(x => "<li>" + escapeText(x) + "</li>").join("") + "</ul>");
      };

      const nome = m.medicamento || m.nome || m.principio_ativo || "";
      pushTopic("Medicamento");
      pushP(nome || "não informado");

      if (isMeaningful(m.classe)) {
        pushTopic("Classe");
        pushP(m.classe);
      }

      if (isMeaningful(m.mecanismo_acao)) {
        pushTopic("Mecanismo de ação");
        pushP(m.mecanismo_acao);
      }

      // Apresentações
      const ap = (m.apresentacoes && typeof m.apresentacoes === "object") ? m.apresentacoes : {};
      const apItems = [];
      for (const k of Object.keys(ap)) {
        const v = ap[k];
        const s = (v === null || v === undefined) ? "" : String(v).trim();
        if (s && s.toLowerCase() !== "não informado" && s.toLowerCase() !== "nao informado") apItems.push(s);
      }

      if (apItems.length) {
        pushTopic("Apresentações no mercado brasileiro");
        pushList(apItems);
      }

      // Uso clínico
      const uso = Array.isArray(m.uso_clinico) ? m.uso_clinico.map(x => String(x || "").trim()).filter(x => isMeaningful(x)) : [];
      if (uso.length) {
        pushTopic("Uso clínico (doenças mais comuns)");
        pushList(uso);
      }

      // Tipo de receituário
      if (isMeaningful(m.tipo_receituario)) {
        pushTopic("Tipo de receituário");
        pushP(m.tipo_receituario);
      }

      // Adultos (por apresentação)
      const pa = (m.posologia_adulto && typeof m.posologia_adulto === "object") ? m.posologia_adulto : {};
      const paBlocks = [];
      for (const k of Object.keys(pa)) {
        const v = pa[k] || {};
        const lines = [];
        const label = String(k || "").trim();
        if (isMeaningful(v.dose_usual)) lines.push("Dose usual: " + String(v.dose_usual).trim());
        if (isMeaningful(v.dose_maxima)) lines.push("Dose máxima: " + String(v.dose_maxima).trim());
        if (isMeaningful(v.modo_uso)) lines.push("Modo de uso: " + String(v.modo_uso).trim());
        if (lines.length) paBlocks.push("<div class='rx-paragraph'><strong>" + escapeText(label) + ":</strong><br>" + lines.map(escapeText).join("<br>") + "</div>");
      }

      if (paBlocks.length) {
        pushTopic("Posologia em adultos (por via/apresentação)");
        parts.push(paBlocks.join(""));
      }

      // Gravidez/lactação
      const grav = m.categoria_gravidez || m.gravidez_categoria;
      if (isMeaningful(grav)) {
        pushTopic("Uso na gravidez");
        pushP(grav);
      }

      const lact = m.uso_lactacao || m.lactacao_risco;
      if (isMeaningful(lact)) {
        pushTopic("Uso na lactação");
        pushP(lact);
      }

      // Pediatria
      const pp = (m.posologia_pediatrica && typeof m.posologia_pediatrica === "object") ? m.posologia_pediatrica : {};
      const ppBlocks = [];
      for (const k of Object.keys(pp)) {
        const v = pp[k] || {};
        const lines = [];
        const label = String(k || "").trim();
        if (isMeaningful(v.dose_mgkg)) lines.push("Dose (mg/kg): " + String(v.dose_mgkg).trim());
        if (isMeaningful(v.intervalo)) lines.push("Intervalo/frequência: " + String(v.intervalo).trim());
        if (isMeaningful(v.dose_maxima)) lines.push("Dose máxima: " + String(v.dose_maxima).trim());
        if (isMeaningful(v.restricoes_etarias)) lines.push("Restrições etárias: " + String(v.restricoes_etarias).trim());
        if (isMeaningful(v.modo_uso)) lines.push("Modo de uso: " + String(v.modo_uso).trim());
        if (lines.length) ppBlocks.push("<div class='rx-paragraph'><strong>" + escapeText(label) + ":</strong><br>" + lines.map(escapeText).join("<br>") + "</div>");
      }

      if (ppBlocks.length) {
        pushTopic("Posologia pediátrica (por via/apresentação)");
        parts.push(ppBlocks.join(""));
      }

      // Interações e enfermagem
      const inter = Array.isArray(m.interacoes_medicamentosas) ? m.interacoes_medicamentosas.map(x => String(x || "").trim()).filter(x => isMeaningful(x)) : [];
      if (inter.length) {
        pushTopic("Interações medicamentosas");
        pushList(inter);
      }

      const enf = Array.isArray(m.pontos_enfermagem) ? m.pontos_enfermagem.map(x => String(x || "").trim()).filter(x => isMeaningful(x)) : [];
      if (enf.length) {
        pushTopic("Pontos de enfermagem");
        pushList(enf);
      }

      // Fontes sugeridas
      const fontes = Array.isArray(m.fontes_sugeridas) ? m.fontes_sugeridas : [];
      if (fontes.length) {
        pushTopic("Fontes sugeridas para conferência");
        const links = fontes
          .map(f => f && f.url ? '<a class="rx-link-btn" target="_blank" rel="noopener noreferrer" href="' + escapeText(f.url) + '">' + escapeText(f.nome || "Fonte") + "</a>" : "")
          .filter(Boolean)
          .join("");
        parts.push('<div class="rx-links">' + links + "</div>");
      }

      return parts.join("");
    }

    function normalizeMedNameForLink(name) {
      return encodeURIComponent(String(name || "").trim());
    }

    function suggestedSourcesForDrug(name) {
      const q = normalizeMedNameForLink(name);
      return [
        { nome: "Bulário Eletrônico (Anvisa)", url: "https://consultas.anvisa.gov.br/#/bulario/" },
        { nome: "Consulta Remédios (bula)", url: "https://consultaremedios.com.br/busca?termo=" + q },
        { nome: "BulasMed (bula)", url: "https://www.bulas.med.br/?s=" + q }
      ];
    }

    function renderRxEvalMedsButtons(meds) {
      if (!rxEvalMedsButtons || !rxEvalMedsCount) return;
      rxEvalMedsButtons.innerHTML = "";
      const uniq = Array.from(new Set((Array.isArray(meds) ? meds : []).map(x => String(x || "").trim()).filter(Boolean)));
      if (!uniq.length) {
        rxEvalMedsCount.textContent = "Nenhum medicamento identificado.";
        return;
      }
      rxEvalMedsCount.textContent = "Medicamentos identificados: " + uniq.length + ". Clique em um medicamento para ver a bula e informações.";
      for (const med of uniq) {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "rx-pill-btn";
        btn.textContent = med;
        btn.addEventListener("click", () => loadRxEvalMedication(med));
        rxEvalMedsButtons.appendChild(btn);
      }
    }

    async function loadRxEvalMedication(medName) {
      const med = String(medName || "").trim();
      if (!med) return;

      if (rxEvalDetails) {
        rxEvalDetails.innerHTML = '<div class="rx-paragraph">Carregando informações do medicamento.</div>';
        if (rxEvalDetails.dataset) rxEvalDetails.dataset.copyText = "";
      }
      if (rxEvalCopyDetailsBtn) rxEvalCopyDetailsBtn.classList.add("hidden");
      if (rxEvalPrintDetailsBtn) rxEvalPrintDetailsBtn.classList.add("hidden");

      try {
        const resp = await fetch(BACKEND_URL + "/api/medicamento-monografia", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ medicamento: med, fontes_sugeridas: suggestedSourcesForDrug(med) })
        });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) throw new Error(data?.error || "Falha ao obter informações do medicamento.");

        const monografia = data?.monografia || data || {};
        // garante fontes sugeridas básicas, caso o backend não preencha
        if (!Array.isArray(monografia.fontes_sugeridas) || !monografia.fontes_sugeridas.length) {
          monografia.fontes_sugeridas = suggestedSourcesForDrug(med);
        }

        const html = buildMonographHtml(monografia);
        if (rxEvalDetails) {
          rxEvalDetails.innerHTML = html || '<div class="rx-paragraph">Nenhum conteúdo disponível.</div>';
          if (rxEvalDetails.dataset) rxEvalDetails.dataset.copyText = rxEvalDetails.innerText || "";
        }
        if (rxEvalCopyDetailsBtn) rxEvalCopyDetailsBtn.classList.remove("hidden");
        if (rxEvalPrintDetailsBtn) rxEvalPrintDetailsBtn.classList.remove("hidden");
      } catch (e) {
        if (rxEvalDetails) {
          rxEvalDetails.innerHTML = '<div class="rx-paragraph">Falha ao obter informações do medicamento. ' + escapeText(e && e.message ? e.message : "") + "</div>";
        }
      }
    }

    function updateRxEvalActions() {
      if (!rxEvalTranscription || !rxEvalCopyTranscriptionBtn || !rxEvalPrintTranscriptionBtn) return;
      const hasText = String(rxEvalTranscription.value || "").trim().length > 0;
      if (hasText) {
        rxEvalCopyTranscriptionBtn.classList.remove("hidden");
        rxEvalPrintTranscriptionBtn.classList.remove("hidden");
      } else {
        rxEvalCopyTranscriptionBtn.classList.add("hidden");
        rxEvalPrintTranscriptionBtn.classList.add("hidden");
      }
    }

    async function analyzeRxEvalWithImages(dataUrls) {
      const images = Array.isArray(dataUrls) ? dataUrls.filter(Boolean) : [];
      if (!rxEvalStatus || !rxEvalTranscription) return;
      if (rxEvalResults) {
        if (images.length) rxEvalResults.classList.remove("hidden");
        else rxEvalResults.classList.add("hidden");
      }

      if (!images.length) {
        rxEvalStatus.textContent = "Nenhuma imagem selecionada.";
        rxEvalTranscription.value = "";
        renderRxEvalMedsButtons([]);
        if (rxEvalDetails) {
          rxEvalDetails.innerHTML = "Selecione um medicamento acima para ver as informações.";
          if (rxEvalDetails.dataset) rxEvalDetails.dataset.copyText = "";
        }
        if (rxEvalCopyDetailsBtn) rxEvalCopyDetailsBtn.classList.add("hidden");
        if (rxEvalPrintDetailsBtn) rxEvalPrintDetailsBtn.classList.add("hidden");
        updateRxEvalActions();
        return;
      }

      rxEvalStatus.textContent = "Avaliando receita (imagem(ns)).";
      rxEvalTranscription.value = "Processando.";
      renderRxEvalMedsButtons([]);
      updateRxEvalActions();

      try {
        const payload = { images_data_url: images, image_data_url: images[0] };
        const resp = await fetch(BACKEND_URL + "/api/avaliar-receita-imagem", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) throw new Error(data?.error || "Falha ao avaliar a receita.");

        const out = data?.avaliacao || data || {};
        const trans = String(out?.transcricao_organizada || out?.transcricao || out?.texto || "").trim();
        rxEvalTranscription.value = trans || "";
        updateRxEvalActions();

        const meds = Array.isArray(out?.medicamentos) ? out.medicamentos : [];
        const medNames = meds.map(x => (typeof x === "string" ? x : (x?.nome || x?.medicamento || ""))).map(x => String(x || "").trim()).filter(Boolean);
        const fallback = extractMedicationsFromPrescriptionText(trans || "");
        const list = medNames.length ? medNames : fallback;
        renderRxEvalMedsButtons(list);

        rxEvalStatus.textContent = "Avaliação concluída.";
      } catch (e) {
        rxEvalStatus.textContent = "Falha ao avaliar a receita. " + (e && e.message ? e.message : "");
        rxEvalTranscription.value = "";
        renderRxEvalMedsButtons([]);
        updateRxEvalActions();
      }
    }

function normalizeFolhaData(rawFolha, startInfo) {
      const folha = rawFolha && typeof rawFolha === "object" ? rawFolha : {};
      const cab = (folha.cabecalho && typeof folha.cabecalho === "object") ? folha.cabecalho : {};
      const meds = Array.isArray(folha.medicamentos) ? folha.medicamentos : [];
      const outMeds = [];

      const info = (startInfo && typeof startInfo === "object") ? startInfo : getAprazStartInfo(new Date());
      const startMin = info.startMin;

      for (const it of meds.slice(0, 60)) {
        const nome = safeField(it?.medicamento || it?.nome);
        const dose = safeField(it?.dose);
        const via = safeField(it?.via);
        const freq = safeField(it?.frequencia || it?.posologia);
        const obs = safeField(it?.observacoes || it?.observacao || it?.notas);

        const horariosExpl = Array.isArray(it?.horarios_explicitados) ? it.horarios_explicitados : (Array.isArray(it?.horarios) ? it.horarios : []);
        const horariosLegiveis = uniq(horariosExpl.map(normalizeHHMM).filter(Boolean));

        const intervalo = (typeof it?.intervalo_horas === "number" && Number.isFinite(it.intervalo_horas)) ? it.intervalo_horas : inferIntervalHours(freq);
        const vezesDia = (typeof it?.vezes_ao_dia === "number" && Number.isFinite(it.vezes_ao_dia)) ? it.vezes_ao_dia : inferTimesPerDay(freq);

        let sugeridos = [];

        if (horariosLegiveis.length) {
          sugeridos = horariosLegiveis;
        } else {
          const ft = asStr(freq).toLowerCase();
          const isPrn = /\b(se necess[aá]rio|s\/n|sn|prn|acm|quando necess[aá]rio)\b/.test(ft);
          const isContinuous = /\b(cont[ií]nuo|bomba|infus[aã]o cont[ií]nua)\b/.test(ft);
          if (isPrn || isContinuous) {
            sugeridos = [];
          } else {
            // Casos especiais (ex.: hs/noite, manhã, tarde) mantêm padrão.
            const special = suggestStandardTimes(null, null, freq);
            if (Array.isArray(special) && special.length) {
              sugeridos = special;
            } else {
              // Se houver intervalo (explícito ou inferido), gera a partir do horário de início.
              let intervalToUse = (typeof intervalo === "number" && Number.isFinite(intervalo)) ? intervalo : null;
              if (!intervalToUse && typeof vezesDia === "number" && Number.isFinite(vezesDia) && vezesDia >= 1 && vezesDia <= 4) {
                intervalToUse = 24 / vezesDia;
              }

              if (intervalToUse && Number.isFinite(intervalToUse) && intervalToUse > 0) {
                sugeridos = generateTimesFromStart(startMin, intervalToUse);
              } else {
                sugeridos = suggestStandardTimes(intervalo, vezesDia, freq);
              }
            }
          }
        }
        outMeds.push({
          medicamento: nome,
          dose,
          via,
          frequencia: freq,
          observacoes: obs,
          horarios: sugeridos
        });
      }

      return {
        cabecalho: cab,
        medicamentos: outMeds,
        observacoes_folha: safeField(folha?.observacoes_folha || folha?.observacoes_gerais),
        limitacoes: safeField(folha?.limitacoes)
      };
    }

    function buildAprazamentoSheetHtml(rawFolha, startInfo) {
      const info = (startInfo && typeof startInfo === "object") ? startInfo : ((aprazStartInfo && typeof aprazStartInfo === "object") ? aprazStartInfo : getAprazStartInfo(new Date()));
      const data = normalizeFolhaData(rawFolha, info);
      const meds = Array.isArray(data.medicamentos) ? data.medicamentos : [];
      const cols = buildHourColumns2h(info);

      let html = "";
      html += `<div class="rx-sheet" id="aprazGridSheet">`;
      html += `<div class="rx-title">Grade de horários (24 horas) para checagem/assinatura</div>`;
      html += `<div class="rx-subtitle">Horário local no início da geração: ${escapeHtml(info.nowHHMM)}. Primeiro horário sugerido: ${escapeHtml(info.startHHMM)}. Transcrição somente do que estiver legível. Ajuste os nomes e preencha os quadrinhos conforme a prescrição oficial e a rotina do serviço.</div>`;

      html += `<div class="rx-hours" id="aprazGridContainer">`;
      html += `<table class="rx-hours-grid" id="aprazHoursGrid" aria-label="Grade de horários para checagem">`;
      html += `<thead><tr><th style="width: 180px; text-align: left;">Medicamento</th>`;
      for (const c of cols) html += `<th>${escapeHtml(c.slice(0,2))}</th>`;
      html += `</tr></thead><tbody>`;

      if (!meds.length) {
        html += `<tr><td colspan="${1 + cols.length}"><div class="rx-field" contenteditable="true">não informado</div></td></tr>`;
      } else {
        for (const m of meds) {
          html += `<tr>`;
          html += `<td style="text-align: left;"><div class="rx-field" contenteditable="true">${escapeHtml(m.medicamento)}</div></td>`;
          for (const c of cols) {
            const due = isDue(c, m.horarios);
            html += `<td class="${due ? "due" : ""}" data-hour="${escapeHtml(c)}"><div class="rx-field" contenteditable="true"></div></td>`;
          }
          html += `</tr>`;
        }
      }

      html += `</tbody></table>`;
      html += `</div>`;

      html += `<table class="rx-kv" style="margin-top: 10px;" aria-label="Assinatura">`;
      html += `<tr><td class="label">Assinatura do enfermeiro</td><td><div class="rx-field" contenteditable="true" style="min-height: 40px;"></div></td></tr>`;
      html += `</table>`;

      html += `</div>`;
      return html;
    }

    function renderAprazamentoSheet(rawFolha, images) {
      if (!aprazamentoSheetWrapper) return;

      const info = (aprazStartInfo && typeof aprazStartInfo === "object") ? aprazStartInfo : getAprazStartInfo(new Date());
      const html = buildAprazamentoSheetHtml(rawFolha, info);
      aprazamentoSheetWrapper.innerHTML = html;

      if (aprazOriginalDetails && aprazOriginalImages) {
        const imgs = Array.isArray(images) ? images.filter(Boolean) : [];
        if (!imgs.length) {
          aprazOriginalImages.innerHTML = "";
          aprazOriginalDetails.classList.add("hidden");
        } else {
          aprazOriginalImages.innerHTML = imgs.slice(0, 4).map((src) => `<img src="${src}" alt="Imagem original da prescrição">`).join("");
          aprazOriginalDetails.classList.remove("hidden");
        }
      }

      updateAprazamentoActions();

    }

    function getRxPrintCss() {
      return `
        body{ font-family: Arial, sans-serif; margin: 0; padding: 16px; color: #111827; }
        .rx-sheet{ border: 1px solid #111827; padding: 12px; }
        .rx-title{ font-size: 16px; font-weight: 700; margin: 0 0 8px 0; }
        .rx-subtitle{ font-size: 12px; margin: 0 0 10px 0; }
        .rx-kv{ width: 100%; border-collapse: collapse; margin-bottom: 10px; }
        .rx-kv td{ border: 1px solid #111827; padding: 6px 6px; font-size: 12px; }
        .rx-kv .label{ width: 140px; font-weight: 700; }
        .rx-grid{ width: 100%; border-collapse: collapse; table-layout: fixed; }
        .rx-grid th, .rx-grid td{ border: 1px solid #111827; padding: 6px 6px; font-size: 12px; vertical-align: top; word-break: break-word; }
        .rx-grid th{ background: #f3f4f6; font-weight: 700; }
        .rx-hours-title{ font-size: 12px; font-weight: 700; margin: 10px 0 6px 0; }
        .rx-hours-grid{ width: 100%; border-collapse: collapse; table-layout: fixed; }
        .rx-hours-grid th, .rx-hours-grid td{ border: 1px solid #111827; font-size: 10px; padding: 4px 2px; text-align: center; }
        .rx-hours-grid th{ background: #f3f4f6; font-weight: 700; }
        .rx-hours-grid td.due{ background: #d32f2f; color: #ffffff; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
        .rx-field{ white-space: pre-wrap; }
      `;
    }

    function openPrintWindowHtml(title, html) {
      const content = String(html || "").trim();
      if (!content) {
        alert("Não há conteúdo para imprimir.");
        return;
      }
      const w = window.open("", "_blank", "width=900,height=700");
      if (!w) {
        alert("Não foi possível abrir a janela de impressão.");
        return;
      }
      w.document.write("<html><head><title>" + escapeHtml(title) + "</title>");
      w.document.write("<style>" + getRxPrintCss() + "</style>");
      w.document.write("</head><body>");
      w.document.write(content);
      w.document.write("</body></html>");
      w.document.close();
      w.focus();
      w.print();
    }

    async function analyzeAprazamentoWithImages(dataUrls) {
      if (!aprazamentoStatus || !aprazamentoSheetWrapper) return;

      if (!aprazStartTs) aprazStartTs = new Date();
      if (!aprazStartInfo) aprazStartInfo = getAprazStartInfo(aprazStartTs);

      const images = Array.isArray(dataUrls) ? dataUrls.filter(Boolean) : [];
      if (!images.length) {
        aprazamentoStatus.textContent = "Nenhuma imagem selecionada.";
        aprazamentoSheetWrapper.innerHTML = '<div class="rx-sheet-placeholder">Nenhum conteúdo disponível.</div>';
        updateAprazamentoActions();
        return;
      }

      aprazamentoStatus.textContent = "Lendo a prescrição e montando a grade de horários (imagem(ns)).";
      aprazamentoSheetWrapper.innerHTML = '<div class="rx-sheet-placeholder">Processando.</div>';
      updateAprazamentoActions();

      try {
        const payload = {
          images_data_url: images,
          image_data_url: images[0]
        };

        const resp = await fetch(BACKEND_URL + "/api/aprazar-prescricao-imagem", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) throw new Error(data?.error || "Falha ao aprazar a prescrição.");

        const folha = data?.folha || data?.prescricao || data;
        renderAprazamentoSheet(folha, images);
        aprazamentoStatus.textContent = "Grade de horários gerada. Revise e edite antes de imprimir.";
        updateAprazamentoActions();
      } catch (e) {
        aprazamentoStatus.textContent = "Falha ao aprazar a prescrição. " + (e && e.message ? e.message : "");
        aprazamentoSheetWrapper.innerHTML = '<div class="rx-sheet-placeholder">Nenhum conteúdo disponível.</div>';
        updateAprazamentoActions();
      }
    }

    function getSoapSectionText(letter) {
      switch (letter) {
        case "S":
          return soapS.value.trim();
        case "O":
          return soapO.value.trim();
        case "A":
          return soapA.value.trim();
        case "P":
          return soapP.value.trim();
        default:
          return "";
      }
    }

    function openPrintWindow(title, text) {
      const content = (text || "").trim();
      if (!content) {
        alert("Não há conteúdo para imprimir.");
        return;
      }

      const w = window.open("", "_blank", "width=800,height=600");
      if (!w) {
        alert("Não foi possível abrir a janela de impressão.");
        return;
      }

      w.document.write("<html><head><title>" + escapeHtml(title) + "</title></head><body>");
      w.document.write("<pre style='font-family: Arial, sans-serif; white-space: pre-wrap;'>" +
        escapeHtml(content) +
        "</pre>");
      w.document.write("</body></html>");
      w.document.close();
      w.focus();
      w.print();
    }

    
    function extractMedicationsFromPrescriptionText(text) {
      const raw = String(text || "").replace(/\r/g, "").trim();
      if (!raw) return [];

      const lines = raw.split("\n").map(l => l.trim()).filter(Boolean);

      const meds = [];

      // Heurística principal:
      // - Prescrição ambulatorial: medicamentos aparecem em lista numerada e a seção "Orientações:" deve ser ignorada.
      // - Prescrição hospitalar: medicamentos aparecem em bullets dentro das seções
      //   "Medicamentos contínuos:" e/ou "Medicamentos se necessário:".

      const isHospital =
        lines.some(l => /^medicamentos\s+cont[ií]nuos\s*:/i.test(l)) ||
        lines.some(l => /^medicamentos\s+se\s+necess[aá]rio\s*:/i.test(l)) ||
        lines.some(l => /^medicamentos\s+se\s+necessario\s*:/i.test(l));

      if (!isHospital) {
        for (const line of lines) {
          const low = line.toLowerCase();

          // Para de coletar ao entrar em orientações/assinatura
          if (low.startsWith("orientações:") || low.startsWith("orientacoes:")) break;
          if (low.startsWith("assinatura:")) break;
          if (low.startsWith("médico") || low.startsWith("medico")) break;

          const m = line.match(/^\s*\d+\s*[\.\)]\s*([^—–-]+?)\s*(?:[—–-].*)?$/);
          if (m && m[1]) {
            const name = m[1].trim();
            if (name && name.length >= 2) meds.push(name);
          }
        }
      } else {
        let section = null; // "cont", "prn", "other"

        for (const line of lines) {
          const low = line.toLowerCase();

          if (/^medicamentos\s+cont[ií]nuos\s*:/i.test(line) || /^medicamentos\s+continuos\s*:/i.test(line)) {
            section = "cont";
            continue;
          }
          if (/^medicamentos\s+se\s+necess[aá]rio\s*:/i.test(line) || /^medicamentos\s+se\s+necessario\s*:/i.test(line)) {
            section = "prn";
            continue;
          }

          // Qualquer outro cabeçalho em formato "X:" encerra a seção de medicamentos
          if (/^[a-zA-ZÀ-ÿ].*:\s*$/.test(line) && !/^medicamentos\s+/i.test(line)) {
            section = "other";
            continue;
          }

          // Captura bullets apenas nas seções corretas
          const isBullet = /^\s*[-•]\s+/.test(line);
          if (!isBullet) continue;
          if (section !== "cont" && section !== "prn") continue;

          const m = line.match(/^\s*[-•]\s*([^—–-]+?)\s*(?:[—–-].*)?$/);
          if (!m || !m[1]) continue;

          const name = m[1].trim();
          if (!name || name.length < 2) continue;
          if (/^(n[aã]o informado)$/i.test(name)) continue;

          meds.push(name);
        }
      }

      // Deduplicação preservando ordem
      const seen = new Set();
      const unique = [];
      for (const x of meds) {
        const key = x.toLowerCase();
        if (seen.has(key)) continue;
        seen.add(key);
        unique.push(x);
      }

      return unique.slice(0, 60);
    }

    function getAllPrescribedMedications() {
      const amb = prescriptionOutput.value || "";
      const hosp = sbarOutput.value || "";
      const meds = [
        ...extractMedicationsFromPrescriptionText(amb),
        ...extractMedicationsFromPrescriptionText(hosp)
      ];

      const seen = new Set();
      const unique = [];
      for (const x of meds) {
        const key = x.toLowerCase();
        if (seen.has(key)) continue;
        seen.add(key);
        unique.push(x);
      }
      return unique.slice(0, 60);
    }

                let sbarTimerInterval = null;
        let sbarStartTs = 0;

        let sbarRecognition = null;
        let sbarIsRecording = false;
        

          stopSbarTimer();
let sbarFinalTranscript = "";
        let sbarInterimTranscript = "";
        let sbarHasStarted = false;
        let sbarHasAnyResult = false;
        let sbarStartAttemptId = 0;


        function startSbarTimer() {
          if (!sbarTimer) return;
          sbarStartTs = Date.now();
          sbarTimer.textContent = "00:00";
          sbarTimer.classList.remove("hidden");
          if (sbarTimerInterval) clearInterval(sbarTimerInterval);
          sbarTimerInterval = setInterval(() => {
            const elapsed = Math.max(0, Date.now() - sbarStartTs);
            const totalSec = Math.floor(elapsed / 1000);
            const mm = String(Math.floor(totalSec / 60)).padStart(2, "0");
            const ss = String(totalSec % 60).padStart(2, "0");
            sbarTimer.textContent = `${mm}:${ss}`;
            if (sbarIsRecording && sbarStatus) {
              sbarStatus.textContent = `Gravando passagem de plantão (SBAR)... ${mm}:${ss} (clique novamente em "Encerrar e gerar SBAR" quando terminar)`;
            }
          }, 500);
        }

        function stopSbarTimer() {
          if (sbarTimerInterval) clearInterval(sbarTimerInterval);
          sbarTimerInterval = null;
          if (!sbarTimer) return;
          sbarTimer.classList.add("hidden");
        }

        function initSbarSpeech() {
          const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
          if (!SR) {
            if (sbarStatus) {
              sbarStatus.textContent = "Seu navegador não suporta reconhecimento de voz. Use Google Chrome.";
            }
            return;
          }

          sbarRecognition = new SR();
          sbarRecognition.lang = "pt-BR";
          sbarRecognition.continuous = true;
          sbarRecognition.interimResults = true;

          
          sbarRecognition.onstart = () => {
            sbarHasStarted = true;
            if (sbarStatus) {
              sbarStatus.textContent = "Gravando passagem de plantão (SBAR)... Quando terminar, clique em \"Encerrar e gerar SBAR\".";
              sbarStatus.classList.remove("loading-dot");
            }
          };
sbarRecognition.onresult = (event) => {
            
            sbarHasAnyResult = true;
let interim = "";
            for (let i = event.resultIndex; i < event.results.length; i++) {
              const transcript = event.results[i][0].transcript;
              if (event.results[i].isFinal) {
                sbarFinalTranscript += transcript + " ";
              } else {
                interim += transcript;
              }
            }
            sbarInterimTranscript = interim.trim();
          };

          sbarRecognition.onerror = (event) => {
            console.error("Erro no reconhecimento de voz (SBAR):", event.error);
            if (sbarStatus) {
              if (event.error === "not-allowed" || event.error === "service-not-allowed") {
                sbarStatus.textContent = "Permita o acesso ao microfone nas configurações do navegador e tente novamente.";
              } else {
                sbarStatus.textContent = "Ocorreu um erro no reconhecimento de voz. Tente novamente.";
              }
            }
          };

          sbarRecognition.onend = () => {
            if (sbarIsRecording) {
              try {
                sbarRecognition.start();
              } catch (err) {
                console.warn("Não foi possível retomar reconhecimento (SBAR):", err);
              }
            }
          };
        }

        function hasAnyOtherRecordingActive() {
          // isRecording: consulta SOAP
          // triageIsRecording: triagem
          // reportIsRecording: relatórios
          // questionsIsRecording: perguntas adicionais
          return !!(isRecording || triageIsRecording || reportIsRecording || questionsIsRecording || docsIsRecording);
        }

        // Guia do SBAR (inline, dentro do próprio módulo)
        if (openSbarGuideBtn && sbarGuidePanel) {
          openSbarGuideBtn.addEventListener("click", () => {
            const willOpen = sbarGuidePanel.classList.contains("hidden");
            sbarGuidePanel.classList.toggle("hidden");
            if (willOpen) {
              // Mantém o usuário no módulo SBAR (sem rolar para o topo)
              sbarGuidePanel.scrollIntoView({ behavior: "smooth", block: "nearest" });
            }
          });
        }


        async function startSbarRecording() {
          if (hasAnyOtherRecordingActive()) {
            alert("Finalize a gravação atual (consulta/triagem/relatórios) antes de iniciar o SBAR.");
            return;
          }

          if (!sbarRecognition) {
            initSbarSpeech();
            if (!sbarRecognition) return;
          }

          // Reset de estado
          sbarIsRecording = true;
          sbarFinalTranscript = "";
          sbarInterimTranscript = "";
          
          sbarHasStarted = false;
          sbarHasAnyResult = false;
          const myAttempt = ++sbarStartAttemptId;
          // Se o reconhecimento não iniciar em ~2.5s, aborta e orienta o usuário.
          setTimeout(() => {
            if (sbarIsRecording && !sbarHasStarted && myAttempt === sbarStartAttemptId) {
              try { if (sbarRecognition) sbarRecognition.stop(); } catch (e) {}
              sbarIsRecording = false;
              stopSbarTimer();
              if (sbarStatus) {
                sbarStatus.textContent = "Não foi possível iniciar o microfone. Verifique permissão, selecione o microfone correto e tente novamente."; 
                sbarStatus.classList.remove("loading-dot");
              }
              if (sbarRecordBtn) {
                sbarRecordBtn.classList.remove("recording");
                sbarRecordBtn.classList.add("start");
                sbarRecordBtn.textContent = "Iniciar passagem de plantão (SBAR)";
                sbarRecordBtn.disabled = false;
              }
            }
          }, 2500);
if (sbarOutput) sbarOutput.value = "";
          if (sbarStatus) {
            sbarStatus.textContent = "Gravando SBAR. Fale em voz alta, de preferência próximo ao microfone. Clique novamente em \"Encerrar e gerar SBAR\" quando terminar.";
            sbarStatus.classList.remove("loading-dot");
          }

          if (sbarRecordBtn) {
            sbarRecordBtn.classList.remove("start");
            sbarRecordBtn.classList.add("recording");
            sbarRecordBtn.textContent = "Encerrar e gerar SBAR";
            sbarRecordBtn.disabled = false;
          }

          startSbarTimer();

          // Garante permissão do microfone (reduz falhas silenciosas em alguns navegadores)
          try {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
              const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
              // libera imediatamente (SpeechRecognition usa o próprio pipeline)
              stream.getTracks().forEach(t => t.stop());
            }
          } catch (e) {
            if (sbarStatus) {
              sbarStatus.textContent = "Permissão de microfone negada ou indisponível.";
              sbarStatus.classList.remove("loading-dot");
            }
          }

          try {
            // Evita erro 'recognition has already started'
            try { sbarRecognition.abort(); } catch (e) {}
            sbarRecognition.start();
          } catch (err) {
            console.error("Falha ao iniciar reconhecimento (SBAR):", err);
            if (sbarStatus) sbarStatus.textContent = "Não foi possível iniciar a gravação do SBAR.";
            sbarIsRecording = false;
            if (sbarRecordBtn) {
              sbarRecordBtn.classList.remove("recording");
              sbarRecordBtn.classList.add("start");
              sbarRecordBtn.textContent = "Iniciar passagem de plantão (SBAR)";
            }
            stopSbarTimer();
          }
        }

        async function stopSbarRecordingAndGenerate() {
          if (!sbarIsRecording) return;

          sbarIsRecording = false;

          if (sbarRecordBtn) {
            sbarRecordBtn.disabled = true;
          }

          try {
            if (sbarRecognition) sbarRecognition.stop();
          } catch (e) {
            console.warn("Erro ao parar reconhecimento (SBAR):", e);
          }

          // pequena espera para capturar os últimos resultados finais
          await new Promise(r => setTimeout(r, 900));

          const transcricao = String(((sbarFinalTranscript || "") + " " + (sbarInterimTranscript || ""))).trim();

          if (!transcricao) {
            if (sbarStatus) {
              sbarStatus.textContent = (!sbarHasStarted ? "A gravação não iniciou. Verifique permissão do microfone e tente novamente." : "Nenhuma fala foi capturada. Tente novamente, falando mais próximo ao microfone (ou aguarde 1 a 2 segundos antes de começar a falar).");
              sbarStatus.classList.remove("loading-dot");
            }
            if (sbarRecordBtn) {
              sbarRecordBtn.disabled = false;
              sbarRecordBtn.classList.remove("recording");
              sbarRecordBtn.classList.add("start");
              sbarRecordBtn.textContent = "Iniciar passagem de plantão (SBAR)";
            }
            stopSbarTimer();
            return;
          }

          await generateHospitalPrescriptionFromTranscript(transcricao);
        }

        async function generateHospitalPrescriptionFromTranscript(transcricao) {
          if (!sbarRecordBtn) return;

          sbarRecordBtn.classList.add("generating");
          sbarRecordBtn.disabled = true;

          if (sbarStatus) {
            sbarStatus.textContent = "Gerando SBAR...";
            sbarStatus.classList.add("loading-dot");
          }

          try {
            const resp = await fetch(BACKEND_URL + "/api/gerar-sbar", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ transcricao })
            });

            if (!resp.ok) {
              const txt = await resp.text().catch(() => "");
              console.error("Erro HTTP do backend (SBAR):", resp.status, txt);
              if (sbarStatus) {
                sbarStatus.textContent = "Não foi possível gerar o SBAR.";
                sbarStatus.classList.remove("loading-dot");
              }
              return;
            }

            const data = await resp.json().catch(() => null);
            const texto = (data && (data.sbar || data.passagem_plantao || data.passagem_plantao_sbar || data.prescricao_hospitalar || data.texto)) ? String(data.sbar || data.passagem_plantao || data.passagem_plantao_sbar || data.prescricao_hospitalar || data.texto).trim() : "";
            if (!texto) {
              console.error("Resposta inválida do backend (SBAR):", data);
              if (sbarStatus) {
                sbarStatus.textContent = "Resposta inválida ao gerar o SBAR.";
                sbarStatus.classList.remove("loading-dot");
              }
              return;
            }

            if (sbarOutput) sbarOutput.value = texto;
            if (sbarStatus) {
              sbarStatus.textContent = "SBAR gerado.";
              sbarStatus.classList.remove("loading-dot");
            }
          } catch (err) {
            console.error("Erro ao gerar SBAR:", err);
            if (sbarStatus) {
              sbarStatus.textContent = "Erro ao gerar SBAR.";
              sbarStatus.classList.remove("loading-dot");
            }
          } finally {
            stopSbarTimer();
            if (sbarRecordBtn) {
              sbarRecordBtn.classList.remove("generating");
              sbarRecordBtn.classList.remove("recording");
              sbarRecordBtn.classList.add("start");
              sbarRecordBtn.textContent = "Iniciar passagem de plantão (SBAR)";
              sbarRecordBtn.disabled = false;
            }
          }
        }

    function formatClassificationList(items) {
      if (!Array.isArray(items) || !items.length) {
        return "Nenhum conteúdo disponível.";
      }
      const lines = [];
      for (const it of items) {
        const med = (it && it.medicamento) ? String(it.medicamento) : "não informado";
        const cat = (it && it.categoria) ? String(it.categoria) : "NA";
        const desc = (it && it.descricao) ? String(it.descricao) : "categoria não informada (dados insuficientes)";
        if (cat === "NA") {
          lines.push(med + ": categoria não informada (dados insuficientes)");
        } else {
          lines.push(med + ": " + cat + " (" + desc + ")");
        }
      }
      return lines.join("\n");
    }

    async function updateClassifications() {
      classificationsStatus.textContent = "";

      const contexto = getNursingContext();
      if (!contexto) {
        pregnancyBox.textContent = "Nenhum conteúdo disponível.";
        lactationBox.textContent = "Nenhum conteúdo disponível.";
        return;
      }

      classificationsStatus.textContent = "Gerando SAE e orientações...";
      classificationsStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/classificar-gestacao-lactacao", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ contexto })
        });

        if (!resp.ok) {
          const ct = (resp.headers && resp.headers.get) ? (resp.headers.get("content-type") || "") : "";
          let msg = "";
          try {
            if (ct.includes("application/json")) {
              const j = await resp.json();
              msg = (j && (j.error || j.message)) ? String(j.error || j.message) : "";
              if (j && j.code) msg = msg ? (msg + " (" + String(j.code) + ")") : String(j.code);
            } else {
              msg = await resp.text();
            }
          } catch {
            try { msg = await resp.text(); } catch {}
          }
          msg = (msg || "").trim() || (`Falha no backend (HTTP ${resp.status}).`);
          console.error("Erro HTTP (SAE/orientações):", resp.status, msg);
          pregnancyBox.textContent = msg;
          lactationBox.textContent = msg;
          return;
        }

        const data = await resp.json().catch(() => ({}));
        pregnancyBox.textContent = (data.sae || "").trim() || "Nenhum conteúdo disponível.";
        lactationBox.textContent = (data.orientacoes || "").trim() || "Nenhum conteúdo disponível.";
      } catch (e) {
        console.error(e);
        pregnancyBox.textContent = "Falha ao gerar SAE (rede/backend).";
        lactationBox.textContent = "Falha ao gerar orientações (rede/backend).";
      } finally {
        classificationsStatus.classList.remove("loading-dot");
        classificationsStatus.textContent = "";
      }
    }

    let reportTimerInterval = null;
    let reportTimerSeconds = 0;

    function formatSecondsMMSS(totalSeconds) {
      const secs = Math.max(0, Number(totalSeconds) || 0);
      const m = ("0" + Math.floor(secs / 60)).slice(-2);
      const s = ("0" + (secs % 60)).slice(-2);
      return `${m}:${s}`;
    }

    function updateReportStatusTimer() {
      if (!reportIsRecording) return;
      const mmss = formatSecondsMMSS(reportTimerSeconds);
      reportStatus.textContent = `Gravando relatório... ${mmss}`;
    }

    function startReportStatusTimer() {
      reportTimerSeconds = 0;
      if (reportTimerInterval) clearInterval(reportTimerInterval);
      updateReportStatusTimer();
      reportTimerInterval = setInterval(() => {
        reportTimerSeconds += 1;
        updateReportStatusTimer();
      }, 1000);
    }

    function stopReportStatusTimer() {
      if (reportTimerInterval) clearInterval(reportTimerInterval);
      reportTimerInterval = null;
    }


    function initReportSpeech() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        reportStatus.textContent =
          "Seu navegador não suporta reconhecimento de voz. Use Google Chrome em um computador.";
        return null;
      }

      const rec = new SR();
      rec.lang = "pt-BR";
      rec.continuous = true;
      rec.interimResults = true;

      rec.onresult = (event) => {
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            reportFinalTranscript += transcript + " ";
          }
        }
      };

      rec.onerror = (event) => {
        console.error("Erro no reconhecimento do relatório:", event.error);
        reportStatus.textContent =
          "Ocorreu um erro no reconhecimento de voz do relatório. Tente novamente.";
      };

      rec.onend = () => {
        if (reportIsRecording && !reportIsPaused) {
          try {
            rec.start();
          } catch (err) {
            console.warn("Não foi possível retomar reconhecimento do relatório:", err);
          }
        }
      };

      return rec;
    }

    async function startReportRecording() {
      reportStatus.textContent = "";
      reportOutput.value = "";
      
      if (reportPreview) {
        reportPreview.style.display = "none";
        setPlainOutput(reportPreview, "Nenhum conteúdo disponível.");
      }
reportFinalTranscript = "";
      updateReportActions();
      if (reportDocTypeDetected) reportDocTypeDetected.textContent = "";
      if (reportMissingFields) reportMissingFields.textContent = "";

      if (!reportRecognition) {
        reportRecognition = initReportSpeech();
        if (!reportRecognition) return;
      }

      reportIsRecording = true;
      reportIsPaused = false;

      reportRecordBtn.className = "small-record-btn recording";
      reportRecordBtn.innerText = "Encerrar gravação";
      reportStatus.textContent = "Gravando documento...";
      reportStatus.classList.remove("loading-dot");
      reportStatus.classList.add("loading-dot");

      startReportStatusTimer();

      try {
        reportRecognition.start();
      } catch (e) {
        console.warn("Erro ao iniciar reconhecimento do relatório:", e);
      }
    }

    async function stopReportRecordingAndGenerate() {
      reportIsRecording = false;
      reportIsPaused = false;

      if (reportRecognition) {
        try {
          reportRecognition.stop();
        } catch (e) {
          console.warn("Erro ao parar reconhecimento do relatório:", e);
        }
      }

      stopReportStatusTimer();

      reportRecordBtn.className = "small-record-btn start";
      reportRecordBtn.innerText = "Gravar documento";

      const transcricao = reportFinalTranscript.trim();
      if (!transcricao) {
        reportStatus.classList.remove("loading-dot");
        reportStatus.textContent = "Nenhuma fala foi capturada no relatório.";
        return;
      }

      reportStatus.textContent = "Gerando documento...";
      reportStatus.classList.add("loading-dot");

      try {
        const resp = await fetch(BACKEND_URL + "/api/gerar-relatorio", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (relatório):", resp.status, txt);
          reportStatus.textContent = "Não foi possível gerar o relatório.";
          reportStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const documento = (data && (data.documento || data.relatorio)) ? String(data.documento || data.relatorio) : "";
        const tipoIdentificado = (data && data.tipo_documento) ? String(data.tipo_documento) : "";
        const pendentes = Array.isArray(data?.campos_pendentes) ? data.campos_pendentes : (Array.isArray(data?.campos_faltantes) ? data.campos_faltantes : []);

        if (reportDocTypeDetected) reportDocTypeDetected.textContent = tipoIdentificado ? tipoIdentificado : "não informado";
        if (reportMissingFields) reportMissingFields.textContent = pendentes.length ? pendentes.join("\n") : "Nenhum";

        reportOutput.value = normalizeNumberedParagraphs(documento);
        
        if (reportPreview) {
          if (documento && String(documento).trim()) {
            reportPreview.style.display = "block";
            setFormattedOutput(reportPreview, reportOutput.value);
          } else {
            reportPreview.style.display = "none";
            setPlainOutput(reportPreview, "Nenhum conteúdo disponível.");
          }
        }
updateReportActions();

        reportStatus.textContent = documento ? "Documento gerado." : "Não foi possível gerar o documento.";
        reportStatus.classList.remove("loading-dot");
      } catch (err) {
        console.error("Erro ao gerar relatório:", err);
        reportStatus.textContent = "Erro ao gerar relatório.";
        reportStatus.classList.remove("loading-dot");
        updateReportActions();
      }
    }

    async function submitMedicalDoubt() {
      const q = (medicalDoubtInput.value || "").trim();
      if (!q) return;

      medicalDoubtStatus.textContent = "Respondendo dúvida...";
      medicalDoubtStatus.classList.add("loading-dot");
      setPlainOutput(medicalDoubtAnswer, "");

      try {
        const resp = await fetch(BACKEND_URL + "/api/duvidas-medicas", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ duvida: q })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (dúvidas):", resp.status, txt);
          medicalDoubtStatus.textContent = "Não foi possível responder a dúvida.";
          medicalDoubtStatus.classList.remove("loading-dot");
          return;
        }

        const data = await resp.json();
        const resposta = data.resposta || "";
        setFormattedOutput(medicalDoubtAnswer, resposta || "Sem resposta disponível.");
        medicalDoubtStatus.textContent = "Resposta gerada.";
        medicalDoubtStatus.classList.remove("loading-dot");
      } catch (err) {
        console.error("Erro ao responder dúvida:", err);
        medicalDoubtStatus.textContent = "Erro ao responder a dúvida.";
        medicalDoubtStatus.classList.remove("loading-dot");
      }
    }

    async function downloadHealthEducationPptx() {
      if (!healthEduTheme || !healthEduDuration || !healthEduDownloadBtn) return;

      const tema = (healthEduTheme.value || "").trim();
      const duracao = parseInt(String(healthEduDuration.value || ""), 10);

      if (!tema) {
        if (healthEduStatus) healthEduStatus.textContent = "Informe o tema para gerar a apresentação.";
        return;
      }

      if (!(duracao >= 10 && duracao <= 60)) {
        if (healthEduStatus) healthEduStatus.textContent = "A duração deve estar entre 10 e 60 minutos.";
        return;
      }

      healthEduDownloadBtn.disabled = true;
      if (healthEduStatus) {
        healthEduStatus.textContent = "Gerando apresentação...";
        healthEduStatus.classList.add("loading-dot");
      }

      try {
        const resp = await fetch(BACKEND_URL + "/api/educacao-saude-pptx", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ tema, duracao_minutos: duracao })
        });

        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (educação em saúde):", resp.status, txt);
          if (healthEduStatus) {
            healthEduStatus.textContent = "Não foi possível gerar a apresentação.";
            healthEduStatus.classList.remove("loading-dot");
          }
          return;
        }

        const blob = await resp.blob();
        const cd = resp.headers.get("content-disposition") || "";
        let filename = "";
        const m = cd.match(/filename\*=UTF-8''([^;]+)|filename=\"?([^\";]+)\"?/i);
        if (m) filename = decodeURIComponent(m[1] || m[2] || "");
        if (!filename) filename = "Educacao_em_Saude.pptx";

        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
          try { URL.revokeObjectURL(url); } catch {}
          try { a.remove(); } catch {}
        }, 300);

        if (healthEduStatus) {
          healthEduStatus.textContent = "Apresentação pronta.";
          healthEduStatus.classList.remove("loading-dot");
        }
      } catch (err) {
        console.error("Erro ao gerar PPTX (educação em saúde):", err);
        if (healthEduStatus) {
          healthEduStatus.textContent = "Erro ao gerar a apresentação.";
          healthEduStatus.classList.remove("loading-dot");
        }
      } finally {
        healthEduDownloadBtn.disabled = false;
        if (healthEduStatus) healthEduStatus.classList.remove("loading-dot");
      }
    }

    // Educação em Saúde: Enter no tema e botão Baixar
    if (healthEduTheme) {
      healthEduTheme.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          downloadHealthEducationPptx();
        }
      });
    }

    if (healthEduDownloadBtn) {
      healthEduDownloadBtn.addEventListener("click", () => {
        downloadHealthEducationPptx();
      });
    }



    // Dúvidas em Saúde: Enter e botão Enviar
if (medicalDoubtInput) {
  medicalDoubtInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      submitMedicalDoubt();
    }
  });
}

if (medicalDoubtSendBtn) {
  medicalDoubtSendBtn.addEventListener("click", () => {
    submitMedicalDoubt();
  });
}



// Pré-visualização formatada do documento gerado (mantém textarea para copiar/editar)
if (reportOutput) {
  reportOutput.addEventListener("input", () => {
    if (!reportPreview) return;
    const val = reportOutput.value || "";
    const has = isMeaningfulText(val);
    reportPreview.style.display = has ? "block" : "none";
    if (has) setFormattedOutput(reportPreview, val);
    else setPlainOutput(reportPreview, "Nenhum conteúdo disponível.");
  });
}

    // ============================
    // Documentos (gravação + geração via /api/gerar-relatorio)
    // ============================

    function docsResetTimer() {
      docsStartTime = null;
      docsAccumulatedSeconds = 0;
      if (docsTimerInterval) clearInterval(docsTimerInterval);
      docsTimerInterval = null;
      if (docsTimerEl) docsTimerEl.textContent = "00:00";
    }

    function docsStartTimer() {
      if (docsTimerInterval) clearInterval(docsTimerInterval);
      docsStartTime = new Date();
      docsTimerInterval = setInterval(() => {
        const now = new Date();
        const delta = Math.floor((now - docsStartTime) / 1000);
        const total = docsAccumulatedSeconds + delta;
        const mm = String(Math.floor(total / 60)).padStart(2, "0");
        const ss = String(total % 60).padStart(2, "0");
        if (docsTimerEl) docsTimerEl.textContent = `${mm}:${ss}`;
      }, 1000);
    }

    function docsPauseTimer() {
      if (!docsStartTime) return;
      const now = new Date();
      const delta = Math.floor((now - docsStartTime) / 1000);
      docsAccumulatedSeconds += delta;
      docsStartTime = null;
      if (docsTimerInterval) clearInterval(docsTimerInterval);
      docsTimerInterval = null;
    }

    function docsGetCombinedTranscript() {
      const full = (docsFinalTranscript || "").trim();
      const inter = (docsInterimTranscript || "").trim();
      return [full, inter].filter(Boolean).join(" ").trim();
    }

    function ensureDocsRecognition() {
      if (docsRecognition) return true;
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        if (docsError) docsError.textContent = "Seu navegador não suporta reconhecimento de voz. Use Chrome no computador ou Android.";
        return false;
      }
      docsRecognition = new SR();
      docsRecognition.continuous = true;
      docsRecognition.interimResults = true;
      docsRecognition.lang = "pt-BR";

      docsRecognition.onresult = (event) => {
        let interim = "";
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const res = event.results[i];
          const transcript = (res[0] && res[0].transcript) ? res[0].transcript : "";
          if (res.isFinal) {
            docsFinalTranscript += transcript + " ";
          } else {
            interim += transcript + " ";
          }
        }
        docsInterimTranscript = interim.trim();
      };

      docsRecognition.onerror = (e) => {
        console.error("Erro no reconhecimento (documentos):", e);
      };

      return true;
    }

    async function docsFetchLiveGuidance() {
      if (!docsIsRecording || docsIsPaused) return;
      if (docsGuidanceInFlight) return;

      const transcricao = docsGetCombinedTranscript();
      if (!transcricao || transcricao.length < 40) {
        if (docsLiveGuidanceStatus) {
          docsLiveGuidanceStatus.textContent = "Fale o conteúdo do documento para receber perguntas essenciais em tempo real.";
        }
        return;
      }

      const payload = { transcricao };
      const h = hashForGuidancePayload(payload);
      if (h === docsGuidanceLastHash) return;
      docsGuidanceLastHash = h;

      docsGuidanceInFlight = true;

      try {
        let resp = await fetch(BACKEND_URL + "/api/documento-tempo-real", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        if (resp.status === 404) {
          resp = await fetch(BACKEND_URL + "/api/guia-documento-tempo-real", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });
        }

        if (!resp.ok) {
          const t = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (guia documento):", resp.status, t);
          if (docsLiveGuidanceStatus) {
            docsLiveGuidanceStatus.textContent = "Não foi possível atualizar as perguntas em tempo real.";
          }
          return;
        }

        const data = await resp.json().catch(() => ({}));
        const tipo = (data && (data.tipo_documento || data.tipo)) ? String(data.tipo_documento || data.tipo).trim() : "";
        const perguntasRaw = Array.isArray(data?.perguntas)
          ? data.perguntas
          : (Array.isArray(data?.perguntas_sugeridas) ? data.perguntas_sugeridas : []);
        const perguntas = perguntasRaw.map(x => String(x || "").trim()).filter(Boolean).slice(0, 3);

        if (docsLiveGuidanceContext) {
          docsLiveGuidanceContext.textContent = tipo ? ("Tipo identificado: " + tipo) : "";
        }

        if (docsLiveGuidanceStatus) {
          docsLiveGuidanceStatus.textContent = perguntas.length
            ? "Perguntas essenciais sugeridas (não obrigatórias)."
            : "Nenhuma pergunta sugerida no momento.";
        }

        if (docsLiveGuidanceList) {
          if (!perguntas.length) {
            docsLiveGuidanceList.innerHTML = '<div class="live-guidance-empty">Nenhuma sugestão por enquanto.</div>';
          } else {
            docsLiveGuidanceList.innerHTML = "";
            perguntas.forEach((q, idx) => {
              const el = document.createElement("div");
              el.className = "live-guidance-item";
              el.innerHTML = `<div class="live-guidance-item-text">${idx + 1}. ${escapeHtml(q)}</div>`;
              docsLiveGuidanceList.appendChild(el);
            });
          }
        }
      } catch (e) {
        console.error("Erro ao atualizar guia de documento:", e);
        if (docsLiveGuidanceStatus) {
          docsLiveGuidanceStatus.textContent = "Erro ao atualizar as perguntas em tempo real.";
        }
      } finally {
        docsGuidanceInFlight = false;
      }
    }

    function startDocsLiveGuidancePolling() {
      stopDocsLiveGuidancePolling();
      docsFetchLiveGuidance();
      docsGuidanceInterval = setInterval(() => {
        docsFetchLiveGuidance();
      }, 2500);
    }

    function stopDocsLiveGuidancePolling() {
      if (docsGuidanceInterval) {
        clearInterval(docsGuidanceInterval);
      }
      docsGuidanceInterval = null;
      docsGuidanceInFlight = false;
      docsGuidanceLastHash = "";
    }

    function renderDocsFinalDocument(documento) {
      if (!docsResultsMount) return;

      const safeText = normalizeNumberedParagraphs(String(documento || "").trim());
      docsResultsMount.innerHTML = `
        <div class="module-card" style="margin-top: 14px;">
          <h3 style="margin: 0 0 10px 0;">Documento gerado</h3>
          <div class="prescription-actions">
            <button id="docsCopyFinalBtn" class="btn-copy" type="button">Copiar documento</button>
            <button id="docsPrintFinalBtn" class="btn-print" type="button">Imprimir documento</button>
          </div>
          <textarea id="docsFinalDocTextarea" class="prescription-textarea" spellcheck="false"></textarea>
        </div>
      `;

      const ta = document.getElementById("docsFinalDocTextarea");
      if (ta) ta.value = safeText;

      const copyBtn = document.getElementById("docsCopyFinalBtn");
      if (copyBtn) {
        copyBtn.addEventListener("click", () => {
          const txt = (ta && ta.value) ? String(ta.value).trim() : "";
          if (!txt) {
            alert("Não há documento para copiar.");
            return;
          }
          copyToClipboard(txt);
        });
      }

      const printBtn = document.getElementById("docsPrintFinalBtn");
      if (printBtn) {
        printBtn.addEventListener("click", () => {
          const txt = (ta && ta.value) ? String(ta.value) : "";
          openPrintWindow("Documento", txt);
        });
      }
    }

    function startDocsRecording() {
      const busy = !!(isRecording || triageIsRecording || handoffIsRecording || reportIsRecording || questionsIsRecording || sbarIsRecording);
      if (busy) {
        alert("Finalize a gravação atual antes de iniciar a geração de documentos.");
        return;
      }

      if (!ensureDocsRecognition()) return;

      docsIsRecording = true;
      docsIsPaused = false;
      docsFinalTranscript = "";
      docsInterimTranscript = "";
      docsLastGeneratedDocument = "";

      // Limpa resultado anterior
      if (docsResultsMount) docsResultsMount.innerHTML = "";

      // Inicializa guia em tempo real (apenas para orientar)
      if (docsLiveGuidanceStatus) docsLiveGuidanceStatus.textContent = "Iniciando guia em tempo real...";
      if (docsLiveGuidanceContext) docsLiveGuidanceContext.textContent = "";
      if (docsLiveGuidanceList) {
        docsLiveGuidanceList.innerHTML = '<div class="live-guidance-empty">Nenhuma sugestão por enquanto.</div>';
      }

      if (docsError) docsError.textContent = "";
      if (docsMicStatus) docsMicStatus.textContent = "Gravando documentos...";

      if (docsPauseBtn) {
        docsPauseBtn.style.display = "inline-block";
        docsPauseBtn.innerText = "Pausar";
      }

      if (docsRecordBtn) {
        docsRecordBtn.className = "recording";
        docsRecordBtn.innerText = "Encerrar gravação";
      }

      // Bloqueia outros módulos durante a gravação
      if (recordBtn) recordBtn.disabled = true;
      if (triageRecordBtn) triageRecordBtn.disabled = true;
      if (handoffRecordBtn) handoffRecordBtn.disabled = true;
      if (reportRecordBtn) reportRecordBtn.disabled = true;

      docsResetTimer();
      docsStartTimer();

      startDocsLiveGuidancePolling();

      try { docsRecognition.start(); } catch (e) {}
    }

    function stopDocsRecording() {
      docsIsRecording = false;
      docsIsPaused = false;

      stopDocsLiveGuidancePolling();

      if (docsRecognition) {
        try { docsRecognition.stop(); } catch (e) {}
      }
      docsPauseTimer();

      if (docsRecordBtn) {
        docsRecordBtn.className = "start";
        docsRecordBtn.innerText = "Iniciar geração de documentos";
      }
      if (docsPauseBtn) docsPauseBtn.style.display = "none";

      if (recordBtn) recordBtn.disabled = false;
      if (triageRecordBtn) triageRecordBtn.disabled = false;
      if (handoffRecordBtn) handoffRecordBtn.disabled = false;
      if (reportRecordBtn) reportRecordBtn.disabled = false;
    }

    function pauseDocsRecording() {
      if (!docsIsRecording || docsIsPaused) return;
      docsIsPaused = true;

      stopDocsLiveGuidancePolling();

      if (docsRecognition) {
        try { docsRecognition.stop(); } catch (e) {}
      }
      docsPauseTimer();

      if (docsPauseBtn) docsPauseBtn.innerText = "Retomar";
      if (docsMicStatus) docsMicStatus.innerText = "Gravação pausada.";
    }

    function resumeDocsRecording() {
      if (!docsIsRecording || !docsIsPaused) return;
      docsIsPaused = false;

      startDocsLiveGuidancePolling();

      if (docsRecognition) {
        try { docsRecognition.start(); } catch (e) {}
      }
      docsStartTimer();

      if (docsPauseBtn) docsPauseBtn.innerText = "Pausar";
      if (docsMicStatus) docsMicStatus.innerText = "Gravando documentos...";
    }

    async function generateDocumentFromTranscript(transcricao) {
      const txt = (transcricao || "").trim();
      if (!txt || txt.length < 40) {
        if (docsError) docsError.textContent = "A transcrição ficou muito curta. Tente novamente, falando mais próximo ao microfone.";
        return;
      }

      if (docsMicStatus) docsMicStatus.textContent = "Gerando documento...";
      if (docsRecordBtn) docsRecordBtn.disabled = true;

      try {
        const body = { transcricao: txt };

        const resp = await fetch(BACKEND_URL + "/api/gerar-relatorio", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body)
        });

        if (!resp.ok) {
          const t = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (documentos):", resp.status, t);
          if (docsError) docsError.textContent = "Não foi possível gerar o documento.";
          return;
        }

        const data = await resp.json().catch(() => ({}));
        const documento = (data && (data.documento || data.relatorio)) ? String(data.documento || data.relatorio) : "";

        docsLastGeneratedDocument = normalizeNumberedParagraphs(documento);
        renderDocsFinalDocument(docsLastGeneratedDocument);
        if (docsMicStatus) docsMicStatus.textContent = documento ? "Documento gerado." : "Não foi possível gerar o documento.";

      } catch (e) {
        console.error("Erro ao gerar documento:", e);
        if (docsError) docsError.textContent = "Erro ao gerar documento.";
      } finally {
        if (docsRecordBtn) docsRecordBtn.disabled = false;
      }
    }

    async function stopDocsRecordingAndGenerate() {
      stopDocsRecording();
      const combined = docsGetCombinedTranscript();
      await generateDocumentFromTranscript(combined);
    }



if (triageRecordBtn) {
  triageRecordBtn.onclick = () => {
    if (!triageIsRecording) {
      startTriageRecording();
    } else {
      stopTriageRecording();
      finalizarTriagemHospitalar();
    }
  };
}

if (triagePauseBtn) {
  triagePauseBtn.onclick = () => {
    if (!triageIsRecording) return;
    if (!triageIsPaused) pauseTriageRecording();
    else resumeTriageRecording();
  };
}

if (docsRecordBtn) {
  docsRecordBtn.onclick = () => {
    if (!docsIsRecording) {
      startDocsRecording();
    } else {
      stopDocsRecordingAndGenerate();
    }
  };
}

if (docsPauseBtn) {
  docsPauseBtn.onclick = () => {
    if (!docsIsRecording) return;
    if (!docsIsPaused) pauseDocsRecording();
    else resumeDocsRecording();
  };
}




if (handoffRecordBtn) {
  handoffRecordBtn.onclick = () => {
    if (!handoffIsRecording) {
      startHandoffRecording();
    } else {
      stopHandoffRecording();
      finalizarPassagemPlantao();
    }
  };
}

if (handoffPauseBtn) {
  handoffPauseBtn.onclick = () => {
    if (!handoffIsRecording) return;
    if (!handoffIsPaused) pauseHandoffRecording();
    else resumeHandoffRecording();
  };
}

if (handoffCopyBtn) {
  handoffCopyBtn.addEventListener("click", () => {
    const text = (handoffOutput && handoffOutput.value) ? handoffOutput.value.trim() : "";
    if (!text) {
      alert("Não há passagem de plantão para copiar.");
      return;
    }
    copyToClipboard(text);
  });
}

if (handoffPrintBtn) {
  handoffPrintBtn.addEventListener("click", () => {
    const text = (handoffOutput && handoffOutput.value) ? handoffOutput.value : "";
    openPrintWindow("Passagem de plantão", text);
  });
}

function setPanelVisible(panelEl, visible) {
  if (!panelEl) return;
  if (visible) panelEl.classList.add("visible");
  else panelEl.classList.remove("visible");
}

if (handoffGuideBtn) {
  handoffGuideBtn.addEventListener("click", () => {
    setPanelVisible(handoffGuidePanel, true);
  });
}



if (aprazamentoGuideBtn) {
  aprazamentoGuideBtn.addEventListener("click", () => {
    setPanelVisible(aprazamentoGuidePanel, true);
  });
}
if (closeAprazamentoGuideBtn) {
  closeAprazamentoGuideBtn.addEventListener("click", () => {
    setPanelVisible(aprazamentoGuidePanel, false);
  });
}


if (woundGuideBtn) {
  woundGuideBtn.addEventListener("click", () => {
    setPanelVisible(woundGuidePanel, true);
  });
}
if (closeWoundGuideBtn) {
  closeWoundGuideBtn.addEventListener("click", () => {
    setPanelVisible(woundGuidePanel, false);
  });
}

if (examGuideBtn) {
  examGuideBtn.addEventListener("click", () => {
    setPanelVisible(examGuidePanel, true);
  });
}
if (closeExamGuideBtn) {
  closeExamGuideBtn.addEventListener("click", () => {
    setPanelVisible(examGuidePanel, false);
  });
}

if (medicalDoubtsGuideBtn) {
  medicalDoubtsGuideBtn.addEventListener("click", () => {
    setPanelVisible(medicalDoubtsGuidePanel, true);
  });
}
if (closeMedicalDoubtsGuideBtn) {
  closeMedicalDoubtsGuideBtn.addEventListener("click", () => {
    setPanelVisible(medicalDoubtsGuidePanel, false);
  });
}

if (calculatorsGuideBtn) {
  calculatorsGuideBtn.addEventListener("click", () => {
    setPanelVisible(calculatorsGuidePanel, true);
  });
}
if (closeCalculatorsGuideBtn) {
  closeCalculatorsGuideBtn.addEventListener("click", () => {
    setPanelVisible(calculatorsGuidePanel, false);
  });
}

if (closeHandoffGuideBtn) {
  closeHandoffGuideBtn.addEventListener("click", () => {
    setPanelVisible(handoffGuidePanel, false);
  });
}

if (docsGuideBtn) {
  docsGuideBtn.addEventListener("click", () => {
    setPanelVisible(docsGuidePanel, true);
  });
}
if (closeDocsGuideBtn) {
  closeDocsGuideBtn.addEventListener("click", () => {
    setPanelVisible(docsGuidePanel, false);
  });
}

if (transcriptionGuideBtn) {
  transcriptionGuideBtn.addEventListener("click", () => {
    setPanelVisible(transcriptionGuidePanel, true);
  });
}
if (closeTranscriptionGuideBtn) {
  closeTranscriptionGuideBtn.addEventListener("click", () => {
    setPanelVisible(transcriptionGuidePanel, false);
  });
}


if (rxEvalGuideBtn) {
  rxEvalGuideBtn.addEventListener("click", () => {
    setPanelVisible(rxEvalGuidePanel, true);
  });
}
if (closeRxEvalGuideBtn) {
  closeRxEvalGuideBtn.addEventListener("click", () => {
    setPanelVisible(rxEvalGuidePanel, false);
  });
}



if (triageCopyFullBtn) {
  triageCopyFullBtn.addEventListener("click", () => {
    const text = (triageFullReport && triageFullReport.value) ? triageFullReport.value.trim() : "";
    if (!text) {
      alert("Não há relatório de triagem para copiar.");
      return;
    }
    copyToClipboard(text);
  });
}

if (triagePrintFullBtn) {
  triagePrintFullBtn.addEventListener("click", () => {
    const text = (triageFullReport && triageFullReport.value) ? triageFullReport.value : "";
    openPrintWindow("Triagem hospitalar", text);
  });
}

if (triageCopyProntuarioBtn) {
  triageCopyProntuarioBtn.addEventListener("click", () => {
    const text = (triageProntuario && triageProntuario.value) ? triageProntuario.value.trim() : "";
    if (!text) {
      alert("Não há texto de prontuário para copiar.");
      return;
    }
    copyToClipboard(text);
  });
}

if (triagePrintProntuarioBtn) {
  triagePrintProntuarioBtn.addEventListener("click", () => {
    const text = (triageProntuario && triageProntuario.value) ? triageProntuario.value : "";
    openPrintWindow("Texto para prontuário - Triagem", text);
  });
}

if (triageCopyPassagemBtn) {
  triageCopyPassagemBtn.addEventListener("click", () => {
    const text = (triagePassagemMedico && triagePassagemMedico.value) ? triagePassagemMedico.value.trim() : "";
    if (!text) {
      alert("Não há passagem ao médico para copiar.");
      return;
    }
    copyToClipboard(text);
  });
}

if (triagePrintPassagemBtn) {
  triagePrintPassagemBtn.addEventListener("click", () => {
    const text = (triagePassagemMedico && triagePassagemMedico.value) ? triagePassagemMedico.value : "";
    openPrintWindow("Passagem rápida ao médico - Triagem", text);
  });
}

recordBtn.onclick = () => {
      if (!isRecording) {
        startRecording();
      } else {
        stopRecording();
        finalizarConsulta();
      }
    };

    pauseBtn.onclick = () => {
      if (!isRecording) return;
      if (!isPaused) {
        pauseRecording();
      } else {
        resumeRecording();
      }
    };

    printBtn.onclick = () => {
      openPrintWindow("Plano de Cuidados (Prescrição de Enfermagem)", prescriptionOutput.value);
    };

    recommendationsBtn.addEventListener("click", () => {
      fetchRecommendations();
    });

    closeRecommendationsBtn.addEventListener("click", () => {
      if (questionsIsRecording) {
        recommendationsStatus.textContent =
          "Finalize a gravação das perguntas clicando em \"Encerrar perguntas\" antes de fechar.";
        return;
      }
      recommendationsPanel.classList.remove("visible");
    });

    askQuestionsBtn.addEventListener("click", () => {
      handleAskQuestionsFromPanel();
    });

    soapCopyButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const part = btn.getAttribute("data-part");
        const sectionText = getSoapSectionText(part);
        if (!sectionText) {
          alert("Seção " + part + " está vazia.");
          return;
        }
        copyToClipboard(part + ": " + sectionText);
      });

    if (copyFullSoapBtn) {
      copyFullSoapBtn.addEventListener("click", () => {
        const full = getCombinedSoapFromFields();
        if (!full.trim()) {
          alert("Não há SOAP disponível para copiar.");
          return;
        }
        copyToClipboard(full);
      });
    }

    if (printSoapBtn) {
      printSoapBtn.addEventListener("click", () => {
        const full = getCombinedSoapFromFields();
        openPrintWindow("SOAP", full);
      });
    }
    if (copyNursingEvolutionBtn) {
      copyNursingEvolutionBtn.addEventListener("click", () => {
        const text = (nursingEvolutionOutput && nursingEvolutionOutput.value) ? nursingEvolutionOutput.value.trim() : "";
        if (!text) {
          alert("Não há evolução de enfermagem para copiar.");
          return;
        }
        copyToClipboard(text);
      });
    }

    if (printNursingEvolutionBtn) {
      printNursingEvolutionBtn.addEventListener("click", () => {
        const text = (nursingEvolutionOutput && nursingEvolutionOutput.value) ? nursingEvolutionOutput.value : "";
        openPrintWindow("Evolução de Enfermagem", text);
      });
    }



    copyPrescriptionBtn.addEventListener("click", () => {
      const text = prescriptionOutput.value.trim();
      if (!text) {
        alert("Não há prescrição para copiar.");
        return;
      }
      copyToClipboard(text);
    });
    if (printAprazGridBtn) {
      printAprazGridBtn.addEventListener("click", () => {
        const el = aprazamentoSheetWrapper ? aprazamentoSheetWrapper.querySelector("#aprazGridSheet") : null;
        const html = el ? el.outerHTML : "";
        openPrintWindowHtml("Grade de horários (24 horas)", html);
      });
    }

    if (copyMedMonographBtn) {
      copyMedMonographBtn.addEventListener("click", () => {
        const t = (medMonographContent && medMonographContent.dataset && medMonographContent.dataset.copyText) ? medMonographContent.dataset.copyText : (medMonographContent ? medMonographContent.textContent : "");
        const s = String(t || "").trim();
        if (!s) {
          alert("Não há informações do medicamento para copiar.");
          return;
        }
        copyToClipboard(s);
      });
    }

    if (closeMedMonographBtn) {
      closeMedMonographBtn.addEventListener("click", () => {
        showMedMonographOverlay(false);
      });
    }

    if (medMonographOverlay) {
      medMonographOverlay.addEventListener("click", (e) => {
        if (e.target === medMonographOverlay) showMedMonographOverlay(false);
      });
    }


    if (sbarRecordBtn) {
      sbarRecordBtn.addEventListener("click", async (e) => {
        e.preventDefault();
        if (!sbarIsRecording) {
          await startSbarRecording();
        } else {
          await stopSbarRecordingAndGenerate();
        }
      });
    }

    // Relatórios de Enfermagem / Encaminhamentos etc.
    if (reportRecordBtn) {
      reportRecordBtn.addEventListener("click", async (e) => {
        e.preventDefault();
        if (!reportIsRecording) {
          startReportRecording();
        } else {
          await stopReportRecordingAndGenerate();
        }
      });
    }

    if (copyReportBtn) {
      copyReportBtn.addEventListener("click", (e) => {
        e.preventDefault();
        const t = reportOutput && reportOutput.value ? reportOutput.value.trim() : "";
        if (!t) {
          alert("Não há documento para copiar.");
          return;
        }
        copyToClipboard(t);
      });
    }

    if (printReportBtn) {
      printReportBtn.addEventListener("click", (e) => {
        e.preventDefault();
        const t = reportOutput && reportOutput.value ? reportOutput.value.trim() : "";
        if (!t) {
          alert("Não há documento para imprimir.");
          return;
        }
        openPrintWindow("Documento", t);
      });
    }
    copySbarBtn.addEventListener("click", () => {
      const text = sbarOutput.value.trim();
      if (!text) {
        alert("Não há SBAR para copiar.");
        return;
      }
      copyToClipboard(text);
    });

    printSbarBtn.addEventListener("click", () => {
      openPrintWindow("Passagem de Plantão (SBAR)", sbarOutput.value);
    });

    if (printRiskTriageBtn) {
      printRiskTriageBtn.addEventListener("click", () => {
        const text = (riskTriageMeaning && riskTriageMeaning.dataset && riskTriageMeaning.dataset.printText) ? riskTriageMeaning.dataset.printText : "";
        openPrintWindow("Classificação de risco por cores", text);
      });
    }

    
    if (copySaeBtn) {
      copySaeBtn.addEventListener("click", () => {
        const text = (pregnancyBox && pregnancyBox.textContent) ? pregnancyBox.textContent.trim() : "";
        if (!text) {
          alert("Não há SAE para copiar.");
          return;
        }
        copyToClipboard(text);
      });
    }

    if (copyOrientationsBtn) {
      copyOrientationsBtn.addEventListener("click", () => {
        const text = (lactationBox && lactationBox.textContent) ? lactationBox.textContent.trim() : "";
        if (!text) {
          alert("Não há orientações para copiar.");
          return;
        }
        copyToClipboard(text);
      });
    }

    if (copyRiskTriageBtn) {
      copyRiskTriageBtn.addEventListener("click", () => {
        const text = (riskTriageMeaning && riskTriageMeaning.dataset && riskTriageMeaning.dataset.printText) ? riskTriageMeaning.dataset.printText : "";
        if (!text.trim()) {
          alert("Não há classificação de risco para copiar.");
          return;
        }
        copyToClipboard(text);
      });
    }
    });

    printPregnancyBtn.addEventListener("click", () => {
      openPrintWindow("SAE (Processo de Enfermagem)", pregnancyBox.textContent);
    });

    printLactationBtn.addEventListener("click", () => {
      openPrintWindow("Orientações ao paciente", lactationBox.textContent);
    });


    if (chooseCameraBtn) {
  chooseCameraBtn.addEventListener("click", () => {
    const input = pendingCameraInput;
    if (input) input.click();
  });
}

    if (chooseFileBtn) {
  chooseFileBtn.addEventListener("click", () => {
    const input = pendingFileInput;
    if (input) input.click();
  });
}

if (clearChosenImagesBtn) {
  clearChosenImagesBtn.addEventListener("click", () => {
    clearPendingImages();
  });
}

if (runImageAnalysisBtn) {
  runImageAnalysisBtn.addEventListener("click", async () => {
    const fn = pendingAnalysisFn;
    const imgs = Array.isArray(pendingImages) ? pendingImages.slice() : [];
    hideImageChoice();
    if (fn && imgs.length) {
      await fn(imgs);
    }
  });
}

    // Estado inicial: painel de resultados do módulo de medicamentos fica oculto até selecionar foto/arquivo.
    // Estado inicial: botões de copiar/imprimir ficam ocultos até gerar conteúdo
    updateWoundActions();
    updateReportActions();
    updateExamActions();
    updateTranscriptionActions();
    updateAprazamentoActions();

    if (cancelImageChoiceBtn) {
      cancelImageChoiceBtn.addEventListener("click", () => {
        hideImageChoice();
      });
    }

    if (imageChoiceOverlay) {
      imageChoiceOverlay.addEventListener("click", (e) => {
        if (e.target === imageChoiceOverlay) hideImageChoice();
      });
    }

    if (woundPhotoBtn) {
      woundPhotoBtn.addEventListener("click", () => {
        if (woundCameraInput) woundCameraInput.click();
      });
    }

    if (woundFileBtn) {
      woundFileBtn.addEventListener("click", () => {
        if (woundFileInput) woundFileInput.click();
      });
    }
function getImageUiByKey(key) {
      const k = String(key || "").toLowerCase();
      if (k === "wound") return { statusEl: presentationsMaxDoseStatus, boxEl: presentationsMaxDoseBox };
      if (k === "exam") return { statusEl: examInterpretationStatus, boxEl: examInterpretationBox };
      if (k === "transcription") return { statusEl: transcriptionStatus, boxEl: transcriptionBox };
      if (k === "apraz") return { statusEl: aprazamentoStatus, boxEl: aprazamentoSheetWrapper };
      if (k === "rxeval" || k === "rx_eval" || k === "rx") return { statusEl: rxEvalStatus, boxEl: rxEvalTranscription };
      return { statusEl: null, boxEl: null };
    }

    function bindImageInput(inputEl, key, mode) {
      if (!inputEl) return;

      const handler = async (e) => {
        const input = e && e.currentTarget ? e.currentTarget : inputEl;
        const files = (input && input.files) ? Array.from(input.files) : [];
        if (!files.length) return;

        if (String(key || "").toLowerCase() === "med") {
          setMedSafetyResultsVisible(true);
        }

        const ui = getImageUiByKey(key);
        const firstName = (files[0] && files[0].name) ? files[0].name : "arquivo";
        const msg0 = `Arquivo recebido: ${firstName}. Preparando imagem.`;
        if (ui && ui.statusEl) ui.statusEl.textContent = msg0;

        // Evita que alguns navegadores invalidem o FileList ao limpar cedo demais.
        inputEl.disabled = true;
        try {
          await addFilesToTarget(files, key, mode);
        } catch (err) {
          const msg = "Erro ao processar a imagem selecionada. Tente JPG/PNG (ou refaça a foto) e confirme a conexão.";
          if (ui && ui.statusEl) ui.statusEl.textContent = msg;
          if (ui && ui.boxEl) ui.boxEl.textContent = "Nenhum conteúdo disponível.";
        } finally {
          try { input.value = ""; } catch {}
          inputEl.disabled = false;
        }
      };

      // Alguns navegadores disparam 'input' em vez de 'change' em certos fluxos.
      inputEl.addEventListener("change", handler);
      inputEl.addEventListener("input", handler);
    }

if (woundCameraInput) bindImageInput(woundCameraInput, "wound", "append");
    if (woundFileInput) bindImageInput(woundFileInput, "wound", "replace");
    if (examCameraInput) bindImageInput(examCameraInput, "exam", "append");
    if (examFileInput) bindImageInput(examFileInput, "exam", "replace");
    if (transcriptionCameraInput) bindImageInput(transcriptionCameraInput, "transcription", "append");
    if (transcriptionFileInput) bindImageInput(transcriptionFileInput, "transcription", "replace");
    if (rxEvalCameraInput) bindImageInput(rxEvalCameraInput, "rxEval", "append");
    if (rxEvalFileInput) bindImageInput(rxEvalFileInput, "rxEval", "replace");

    if (rxEvalTranscription) {
      rxEvalTranscription.addEventListener("input", () => {
        updateRxEvalActions();
      });
    }

    if (rxEvalCopyTranscriptionBtn) {
      rxEvalCopyTranscriptionBtn.addEventListener("click", () => {
        const text = (rxEvalTranscription && rxEvalTranscription.value) ? rxEvalTranscription.value.trim() : "";
        if (!text) {
          alert("Não há transcrição para copiar.");
          return;
        }
        copyToClipboard(text);
      });
    }

    if (rxEvalPrintTranscriptionBtn) {
      rxEvalPrintTranscriptionBtn.addEventListener("click", () => {
        const text = (rxEvalTranscription && rxEvalTranscription.value) ? rxEvalTranscription.value.trim() : "";
        if (!text) {
          alert("Não há transcrição para imprimir.");
          return;
        }
        printTextBlock("Transcrição da receita", text);
      });
    }

    if (rxEvalCopyDetailsBtn) {
      rxEvalCopyDetailsBtn.addEventListener("click", () => {
        const text = (rxEvalDetails && rxEvalDetails.dataset && rxEvalDetails.dataset.copyText) ? String(rxEvalDetails.dataset.copyText).trim() : "";
        if (!text) {
          alert("Não há informações do medicamento para copiar.");
          return;
        }
        copyToClipboard(text);
      });
    }

    if (rxEvalPrintDetailsBtn) {
      rxEvalPrintDetailsBtn.addEventListener("click", () => {
        const text = (rxEvalDetails && rxEvalDetails.dataset && rxEvalDetails.dataset.copyText) ? String(rxEvalDetails.dataset.copyText).trim() : "";
        if (!text) {
          alert("Não há informações do medicamento para imprimir.");
          return;
        }
        printTextBlock("Informações do medicamento", text);
      });
    }


    if (aprazamentoCameraInput) bindImageInput(aprazamentoCameraInput, "apraz", "append");
    if (aprazamentoFileInput) bindImageInput(aprazamentoFileInput, "apraz", "replace");

    // =========================
    // ADMIN (cadastro, mensalidade, histórico e auditoria)
    // =========================

    function fmtDt(iso) {
      if (!iso) return "-";
      try { return new Date(iso).toLocaleString("pt-BR"); } catch { return String(iso); }
    }

    function fmtMoney(v) {
      try {
        const n = Number(v);
        if (!Number.isFinite(n)) return String(v ?? "");
        return n.toLocaleString("pt-BR", { style: "currency", currency: "BRL" });
      } catch {
        return String(v ?? "");
      }
    }

    function currentYYYYMM() {
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      return `${y}-${m}`;
    }

    async function adminFetchJson(path, options) {
      const resp = await fetch(BACKEND_URL + path, Object.assign({ method: "GET" }, options || {}));
      const data = await resp.json().catch(() => ({}));
      if (!resp.ok) throw new Error(data.error || ("Falha: " + resp.status));
      return data;
    }

    async function autoRecoverIfEmpty() {
      try {
        if (RECOVERY_RUNNING) return;
        if (RECOVERY_TRIED) return;
        const payload = getLocalBackupPayload();
        const hasUsers = payload && Array.isArray(payload.users) && payload.users.length > 0;
        if (!hasUsers) return;
        if (!Array.isArray(ADMIN_CACHE_USERS) || ADMIN_CACHE_USERS.length !== 0) return;

        RECOVERY_RUNNING = true;
        RECOVERY_TRIED = true;

        const st = document.getElementById("adminStatus");
        if (st) st.textContent = "Recuperando usuários a partir do backup local...";

        // Cria backup manual no servidor (se houver)
        try { await adminFetchJson("/api/admin/backup/create", { method: "POST" }); } catch {}

        await adminFetchJson("/api/admin/backup/import", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        await adminLoadAll();
        if (st) st.textContent = "Recuperação concluída a partir do backup local.";
      } catch (e) {
        const st = document.getElementById("adminStatus");
        if (st) st.textContent = "Falha ao recuperar do backup local: " + String(e?.message || e || "");
      } finally {
        RECOVERY_RUNNING = false;
        updateAdminLocalBackupBadge();
      }
    }

    async function adminLoadAll() {
      try {
        const [users, audit] = await Promise.all([
          adminFetchJson("/api/admin/users"),
          adminFetchJson("/api/admin/audit")
        ]);
        ADMIN_CACHE_USERS = Array.isArray(users.users) ? users.users : [];
        ADMIN_CACHE_AUDIT = Array.isArray(audit.audit) ? audit.audit : [];
        renderAdminUsers();
        renderAdminAudit();
        const sub = document.getElementById("adminSubtitle");
        if (sub) sub.textContent = `Usuários cadastrados: ${ADMIN_CACHE_USERS.length}`;
        const st = document.getElementById("adminStatus");
        if (st) st.textContent = "";
        updateAdminLocalBackupBadge();
        // Atualiza backup local com a versão do servidor (quando houver dados)
        if (ADMIN_CACHE_USERS.length > 0) { await refreshLocalBackupFromServer(); }
        // Se o servidor vier vazio (ex.: redeploy), tenta restaurar automaticamente do backup local
        await autoRecoverIfEmpty();
      } catch (e) {
        const st = document.getElementById("adminStatus");
        if (st) st.textContent = String(e.message || e);
      }
    }

    function renderAdminAudit() {
      const tbody = document.getElementById("auditTbody");
      if (!tbody) return;
      tbody.innerHTML = "";

      for (const a of ADMIN_CACHE_AUDIT.slice().reverse().slice(0, 200)) {
        const tr = document.createElement("tr");
        const tdReg = document.createElement("td");
        const tdAdm = document.createElement("td");

        const dt = fmtDt(a.at || a.paidAt);
        const user = [a.userName, a.userLogin].filter(Boolean).join(" - ");
        const parts = [];
        if (dt && dt !== "-") parts.push(dt);
        if (user) parts.push(user);
        if (a.month) parts.push("Mês: " + a.month);
        if (a.amount !== undefined && a.amount !== null && String(a.amount) !== "") parts.push("Valor: " + fmtMoney(a.amount));
        if (a.method) parts.push("Método: " + a.method);
        if (a.notes) parts.push("Obs: " + a.notes);

        tdReg.textContent = parts.join(" / ");
        tdAdm.textContent = a.receivedBy || a.admin || a.actor || "-";
        tr.appendChild(tdReg);
        tr.appendChild(tdAdm);
        tbody.appendChild(tr);
      }
    }

    function isOnline(lastSeenAt) {
      if (!lastSeenAt) return false;
      try {
        const t = new Date(lastSeenAt).getTime();
        return (Date.now() - t) <= (2 * 60 * 1000);
      } catch {
        return false;
      }
    }

    function renderAdminUsers() {
      const tbody = document.getElementById("usersTbody");
      if (!tbody) return;
      tbody.innerHTML = "";

      const q = (document.getElementById("adminSearch")?.value || "").trim().toLowerCase();
      const rows = ADMIN_CACHE_USERS.filter(u => {
        if (!q) return true;
        const s = `${u.fullName||""} ${u.login||""} ${u.phone||""}`.toLowerCase();
        return s.includes(q);
      });

      for (const u of rows) {
        const tr = document.createElement("tr");
        const active = (u && (u.isActive !== undefined ? !!u.isActive : !!u.active));

        const tdName = document.createElement("td");
        tdName.textContent = u.fullName || "-";

        const tdLogin = document.createElement("td");
        tdLogin.textContent = u.login || "-";

        const tdPhone = document.createElement("td");
        tdPhone.textContent = u.phone || "-";

        const tdOnline = document.createElement("td");
        const on = isOnline(u.lastSeenAt);
        const pillOn = document.createElement("span");
        pillOn.className = "pill " + (on ? "green" : "gray");
        pillOn.textContent = on ? "Online" : "Offline";
        tdOnline.appendChild(pillOn);

        const tdPay = document.createElement("td");
        const paid = (u && (u.isPaidThisMonth !== undefined ? !!u.isPaidThisMonth : !!u.paidCurrentMonth));
        const pillPay = document.createElement("button");
        pillPay.type = "button";
        pillPay.className = "pill " + (paid ? "green" : "red");
        pillPay.textContent = paid ? "Em dia" : "Em atraso";
        pillPay.title = "Clique para marcar pagamento do mês";
        pillPay.addEventListener("click", async () => {
          const month = prompt("Mês no formato AAAA-MM", currentYYYYMM());
          if (!month) return;
          const amount = prompt("Valor (opcional)", "");
          const method = prompt("Método (opcional)", "PIX");
          const notes = prompt("Observações (opcional)", "");
          try {
            await adminFetchJson(`/api/admin/users/${encodeURIComponent(u.id)}/pay`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ month, amount, method, notes })
            });
            await adminLoadAll();
            await refreshLocalBackupFromServer();
          } catch (e) {
            const st = document.getElementById("adminStatus");
            if (st) st.textContent = String(e.message || e);
          }
        });
        tdPay.appendChild(pillPay);

        const tdLast = document.createElement("td");
        tdLast.textContent = u.lastLoginAt ? fmtDt(u.lastLoginAt) : "-";

        const tdActions = document.createElement("td");
        const actions = document.createElement("div");
        actions.className = "admin-actions";

        const btnEdit = document.createElement("button");
        btnEdit.className = "admin-btn secondary";
        btnEdit.type = "button";
        btnEdit.textContent = "Editar";
        btnEdit.addEventListener("click", () => {
          openEditUserModal(u);
        });

        const btnHist = document.createElement("button");
        btnHist.className = "admin-btn secondary";
        btnHist.type = "button";
        btnHist.textContent = "Histórico";
        btnHist.addEventListener("click", async () => {
          try {
            const data = await adminFetchJson(`/api/admin/users/${encodeURIComponent(u.id)}/payments`);
            openPaymentsModal(u, data.payments || []);
          } catch (e) {
            const st = document.getElementById("adminStatus");
            if (st) st.textContent = String(e.message || e);
          }
        });

        const btnActive = document.createElement("button");
        btnActive.type = "button";
        btnActive.className = "pill " + (active ? "green" : "red");
        btnActive.textContent = active ? "Ativado" : "Desativado";
        btnActive.title = "Clique para ativar/desativar. Se desativado ou em débito, o acesso do usuário será bloqueado.";
        btnActive.addEventListener("click", async () => {
          try {
            await adminFetchJson(`/api/admin/users/${encodeURIComponent(u.id)}/active`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ active: !active })
            });
            await adminLoadAll();
            await refreshLocalBackupFromServer();
          } catch (e) {
            const st = document.getElementById("adminStatus");
            if (st) st.textContent = String(e.message || e);
          }
        });

        const btnReset = document.createElement("button");
        btnReset.className = "admin-btn secondary";
        btnReset.type = "button";
        btnReset.textContent = "Reset senha";
        btnReset.addEventListener("click", async () => {
          const newPass = prompt("Nova senha (será salva)", "");
          if (!newPass) return;
          try {
            await adminFetchJson(`/api/admin/users/${encodeURIComponent(u.id)}/reset-password`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ password: newPass })
            });
            await adminLoadAll();
            await refreshLocalBackupFromServer();
          } catch (e) {
            const st = document.getElementById("adminStatus");
            if (st) st.textContent = String(e.message || e);
          }
        });

        const btnDelete = document.createElement("button");
        btnDelete.className = "admin-btn danger";
        btnDelete.type = "button";
        btnDelete.textContent = "Excluir";
        btnDelete.addEventListener("click", async () => {
          if (!confirm("Excluir este usuário? O histórico de pagamentos será preservado.")) return;
          try {
            await adminFetchJson(`/api/admin/users/${encodeURIComponent(u.id)}`, { method: "DELETE" });
            await adminLoadAll();
            await refreshLocalBackupFromServer();
          } catch (e) {
            const st = document.getElementById("adminStatus");
            if (st) st.textContent = String(e.message || e);
          }
        });

        actions.appendChild(btnEdit);
        actions.appendChild(btnHist);
        actions.appendChild(btnActive);
        actions.appendChild(btnReset);
        actions.appendChild(btnDelete);
        tdActions.appendChild(actions);

        tr.appendChild(tdName);
        tr.appendChild(tdLogin);
        tr.appendChild(tdPhone);
        tr.appendChild(tdOnline);
        tr.appendChild(tdPay);
        tr.appendChild(tdLast);
        tr.appendChild(tdActions);

        tbody.appendChild(tr);
      }
    }

    function openPaymentsModal(user, payments) {
      const modal = document.getElementById("paymentsModal");
      const subtitle = document.getElementById("paymentsModalSubtitle");
      const tbody = document.getElementById("paymentsTbody");
      if (!modal || !tbody) return;
      if (subtitle) subtitle.textContent = `${user.fullName || "-"} • ${user.login || "-"}`;

      tbody.innerHTML = "";
      const list = Array.isArray(payments) ? payments.slice().reverse() : [];
      for (const p of list) {
        const tr = document.createElement("tr");
        const tdM = document.createElement("td");
        const tdAt = document.createElement("td");
        const tdAm = document.createElement("td");
        const tdMe = document.createElement("td");
        const tdNo = document.createElement("td");
        tdM.textContent = p.month || "-";
        tdAt.textContent = fmtDt(p.paidAt);
        tdAm.textContent = (p.amount !== undefined && p.amount !== null && String(p.amount).trim() !== "") ? String(p.amount) : "-";
        tdMe.textContent = p.method || "-";
        tdNo.textContent = p.notes || "-";
        tr.appendChild(tdM); tr.appendChild(tdAt); tr.appendChild(tdAm); tr.appendChild(tdMe); tr.appendChild(tdNo);
        tbody.appendChild(tr);
      }

      modal.classList.remove("hidden");
    }

        // =========================
    // EDITAR USUÁRIO (ADMIN)
    // =========================
    let EDIT_USER_ID = null;

    function openEditUserModal(user) {
      EDIT_USER_ID = user?.id || null;
      document.getElementById("editUserSubtitle").textContent = `${user.fullName || "-"} • ${user.login || "-"}`;

      document.getElementById("editFullName").value = user.fullName || "";
      document.getElementById("editDob").value = user.dob || "";
      document.getElementById("editPhone").value = user.phone || "";
      document.getElementById("editLogin").value = user.login || "";
      document.getElementById("editPassword").value = "";

      document.getElementById("editUserModal").classList.remove("hidden");
    }

    function closeEditUserModal() {
      EDIT_USER_ID = null;
      document.getElementById("editUserModal")?.classList.add("hidden");
    }

    document.getElementById("cancelEditUserBtn")?.addEventListener("click", closeEditUserModal);

    document.getElementById("saveEditUserBtn")?.addEventListener("click", async () => {
      try {
        if (!EDIT_USER_ID) throw new Error("Usuário inválido.");
        const fullName = (document.getElementById("editFullName")?.value || "").trim();
        const dob = (document.getElementById("editDob")?.value || "").trim();
        const phone = (document.getElementById("editPhone")?.value || "").trim();
        const login = (document.getElementById("editLogin")?.value || "").trim();
        const password = (document.getElementById("editPassword")?.value || "").trim();

        if (!fullName || !dob || !phone || !login) {
          alert("Preencha: nome completo, data de nascimento, telefone e login.");
          return;
        }

        await adminFetchJson(`/api/admin/users/${encodeURIComponent(EDIT_USER_ID)}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ fullName, dob, phone, login, password })
        });

        closeEditUserModal();
        await adminLoadAll();
            await refreshLocalBackupFromServer();
      } catch (e) {
        alert(String(e?.message || e || "Falha ao editar usuário."));
      }
    });

document.getElementById("closePaymentsBtn")?.addEventListener("click", () => {
      document.getElementById("paymentsModal")?.classList.add("hidden");
    });

    document.getElementById("adminSearch")?.addEventListener("input", renderAdminUsers);

    document.getElementById("adminRefreshBtn")?.addEventListener("click", adminLoadAll);

    document.getElementById("adminBackupBtn")?.addEventListener("click", async () => {
      try {
        // Usa o token salvo em sessão (localStorage) e o wrapper de fetch já injeta Authorization
        const t = getToken();
        if (!t) throw new Error("Sessão inválida. Faça login novamente.");

        const resp = await fetch(BACKEND_URL + "/api/admin/backup/export", { method: "GET" });
        const ct = resp.headers.get("content-type") || "";

        if (!resp.ok) {
          let msg = "Falha ao exportar.";
          try {
            if (ct.includes("application/json")) {
              const j = await resp.json();
              msg = j?.error || msg;
            } else {
              msg = (await resp.text()) || msg;
            }
          } catch {}
          throw new Error(msg);
        }

        const blob = await resp.blob();
        const a = document.createElement("a");
        const url = URL.createObjectURL(blob);
        a.href = url;
        a.download = `backup-enfermagem-${new Date().toISOString().slice(0,10)}.json`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 1500);

        // Atualiza o cache local do backup para contingência
        try {
          const txt = await (await fetch(BACKEND_URL + "/api/admin/backup/export", { method: "GET" })).text();
          if (txt && txt.trim().startsWith("{")) {
            setLocalBackupText(txt);
            updateAdminLocalBackupBadge();
          }
        } catch {}
      } catch (e) {
        alert(e?.message || "Erro ao baixar backup.");
      }
    });

    document.getElementById("adminRestoreBtn")?.addEventListener("click", async () => {
      const input = document.getElementById("adminRestoreFile");
      if (input) input.click();
    });

    document.getElementById("adminRestoreFile")?.addEventListener("change", async (ev) => {
      try {
        const file = ev.target?.files?.[0];
        if (!file) return;
        if (!confirm("Restaurar/mesclar este backup? Isso não apaga histórico; apenas recupera/mescla dados.")) {
          ev.target.value = "";
          return;
        }

        // cria um backup manual antes de restaurar
        try { await adminFetchJson("/api/admin/backup/create", { method: "POST" }); } catch {}

        const txt = await file.text();
        const payload = JSON.parse(txt);

        await adminFetchJson("/api/admin/backup/import", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        ev.target.value = "";
        await adminLoadAll();
        await refreshLocalBackupFromServer();
        alert("Backup importado/mesclado com sucesso.");
      } catch (e) {
        alert(String(e?.message || e || "Falha ao restaurar backup."));
      }
    });


    document.getElementById("createUserBtn")?.addEventListener("click", async () => {
      const fullName = (document.getElementById("newFullName")?.value || "").trim();
      const dob = (document.getElementById("newDob")?.value || "").trim();
      const phone = (document.getElementById("newPhone")?.value || "").trim();
      const login = (document.getElementById("newLogin")?.value || "").trim();
      const password = (document.getElementById("newPassword")?.value || "").trim();
      const st = document.getElementById("createUserStatus");
      const missing = [];
      if (!fullName) missing.push("Nome completo");
      if (!phone) missing.push("Telefone");
      if (!login) missing.push("CPF (Login)");
      if (!password) missing.push("Senha");
      if (missing.length) {
        if (st) st.textContent = "Preencha: " + missing.join(", ") + ".";
        return;
      }
      if (st) st.textContent = "Cadastrando...";
      try {
        await adminFetchJson("/api/admin/users", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ fullName, dob, phone, login, password })
        });
        if (st) st.textContent = "Usuário cadastrado.";
        // Limpa campos
        ["newFullName","newDob","newPhone","newLogin","newPassword"].forEach(id => {
          const el = document.getElementById(id);
          if (el) el.value = "";
        });
        await adminLoadAll();
            await refreshLocalBackupFromServer();
      } catch (e) {
        if (st) st.textContent = String(e.message || e);
      }
    });

    // Inicializa a sessão ao carregar
    restoreSession();

    // Failsafe: se nenhuma view estiver visível após 1s, mostra login
    setTimeout(() => {
      const lv = document.getElementById("loginView");
      const av = document.getElementById("adminView");
      const nv = document.getElementById("nurseView");
      const anyVisible = (lv && !lv.classList.contains("hidden")) || (av && !av.classList.contains("hidden")) || (nv && !nv.classList.contains("hidden"));
      if (!anyVisible) showLogin();
    }, 1000);



    

    // ============================
    // MÓDULO: Guias de consulta (nurseView)
    // ============================
    (function initConsultGuides() {
      const consultButtons = Array.from(document.querySelectorAll(".consult-type-btn"));
      const drawer = document.getElementById("consultGuideDrawer");
      const titleEl = document.getElementById("consultGuideTitle");
      const subtitleEl = document.getElementById("consultGuideSubtitle");
      const contentEl = document.getElementById("consultGuideContent");
      const closeBtn = document.getElementById("closeConsultGuideBtn");
      const prenatalTriRow = document.getElementById("prenatalTrimesterRow");
      const triBtns = Array.from(document.querySelectorAll(".trimester-btn"));

      if (!consultButtons.length || !drawer || !titleEl || !subtitleEl || !contentEl || !closeBtn || !prenatalTriRow) return;

      function esc(s) {
        return String(s ?? "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      const GUIDE = {
        prenatal: {
          title: "Consulta pré-natal por trimestre",
          subtitle: "Roteiro prático com linguagem direta e detalhada, baseado nas recomendações do Ministério da Saúde. Ajuste conforme risco gestacional e protocolos locais.",
          trimester: {
            1: {
              subtitle: "1º trimestre (até 13 semanas + 6 dias)",
              html: `
                <h4>Objetivos</h4>
                <ul>
                  <li>Confirmar gestação, estimar idade gestacional, identificar riscos e organizar o plano de pré-natal.</li>
                  <li>Garantir que a gestante entenda como será o acompanhamento, quais exames serão feitos e quando retornar.</li>
                </ul>

                <h4>Perguntas essenciais (anamnese)</h4>
                <ul>
                  <li>Data da última menstruação (DUM) e regularidade do ciclo; dúvidas sobre a data.</li>
                  <li>Gestas/partos/abortos anteriores, cesáreas, complicações (preeclâmpsia, hemorragia, prematuridade, DMG, infecções).</li>
                  <li>Doenças prévias: hipertensão, diabetes, tireoide, epilepsia, cardiopatias, trombose, asma, doenças renais.</li>
                  <li>Uso de medicamentos, álcool, tabaco, outras drogas; alergias.</li>
                  <li>Sintomas atuais: náuseas/vômitos intensos, dor abdominal, febre, sangramento, corrimento, disúria.</li>
                  <li>Condições sociais e de segurança: suporte familiar, trabalho, violência, acesso ao serviço.</li>
                </ul>

                <h4>Exame físico e obstétrico (passo a passo)</h4>
                <ul>
                  <li>Pressão arterial, peso, altura, IMC e ganho de peso esperado.</li>
                  <li>Avaliar edema, sinais de anemia, tireoide, mamas e cavidade oral conforme necessidade.</li>
                  <li>Exame obstétrico conforme idade gestacional: altura uterina (quando aplicável) e ausculta de BCF (quando possível).</li>
                </ul>

                <h4>Exames recomendados (rotina mínima do MS)</h4>
                <ul>
                  <li>ABO-Rh e hemoglobina/hematócrito na primeira consulta.</li>
                  <li>Glicemia de jejum na primeira consulta.</li>
                  <li>VDRL (sífilis) na primeira consulta.</li>
                  <li>Urina tipo 1 na primeira consulta.</li>
                  <li>Teste anti-HIV na primeira consulta.</li>
                  <li>Sorologia para toxoplasmose na primeira consulta (se disponível).</li>
                </ul>

                <h4>O que explicar para quem não entende nada</h4>
                <ul>
                  <li><b>Por que tantos exames?</b> Eles servem para descobrir cedo problemas que podem não dar sintoma (anemia, diabetes, sífilis, HIV, infecção urinária).</li>
                  <li><b>O que acontece se der alterado?</b> A equipe orienta o tratamento e faz acompanhamento mais de perto para proteger mãe e bebê.</li>
                </ul>
              `
            },
            2: {
              subtitle: "2º trimestre (14 a 27 semanas + 6 dias)",
              html: `
                <h4>Objetivos</h4>
                <ul>
                  <li>Acompanhar crescimento do bebê e saúde da gestante.</li>
                  <li>Rastrear diabetes gestacional no período recomendado.</li>
                </ul>

                <h4>O que perguntar e registrar</h4>
                <ul>
                  <li>Sintomas de alarme: sangramento, perda de líquido, febre, dor forte, redução de movimentos fetais (quando já perceptíveis).</li>
                  <li>Sintomas urinários (ardor ao urinar, urgência, dor lombar), cefaleia importante, alteração visual, dor no “boca do estômago”.</li>
                  <li>Adesão a ferro/ácido fólico (se prescritos), alimentação e atividade física.</li>
                </ul>

                <h4>Exame físico e obstétrico (rotina)</h4>
                <ul>
                  <li>Pressão arterial e peso em toda consulta.</li>
                  <li>Altura uterina, ausculta de BCF e avaliação de edema conforme evolução.</li>
                </ul>

                <h4>Exames recomendados</h4>
                <ul>
                  <li>Se a glicemia de jejum do início estiver normal, realizar entre 24 e 28 semanas o Teste Oral de Tolerância à Glicose (TOTG) para investigar diabetes gestacional.</li>
                  <li>Manter atenção para sinais e sintomas que indiquem necessidade de repetir urina e investigar infecção urinária.</li>
                </ul>

                <h4>Como explicar o TOTG (bem simples)</h4>
                <ul>
                  <li>É um exame para ver como o corpo “lida com açúcar”. A gestante fica em jejum, colhe sangue, toma uma solução doce e faz novas coletas.</li>
                  <li>Ele é feito nesse período porque é quando a gravidez pode “desencadear” diabetes gestacional, mesmo em quem nunca teve.</li>
                </ul>
              `
            },
            3: {
              subtitle: "3º trimestre (28 semanas até o parto)",
              html: `
                <h4>Objetivos</h4>
                <ul>
                  <li>Reforçar segurança materno-fetal, planejar parto e identificar precocemente complicações.</li>
                  <li>Repetir exames de rastreio no momento recomendado pelo MS.</li>
                </ul>

                <h4>Exames recomendados (rotina mínima do MS)</h4>
                <ul>
                  <li>Glicemia de jejum próxima à 30ª semana.</li>
                  <li>VDRL (sífilis) próximo à 30ª semana.</li>
                  <li>Urina tipo 1 próxima à 30ª semana.</li>
                  <li>Teste anti-HIV próximo à 30ª semana (sempre que possível).</li>
                  <li>HBsAg (hepatite B) de preferência próximo à 30ª semana (se disponível).</li>
                </ul>

                <h4>O que perguntar e orientar</h4>
                <ul>
                  <li>Movimentos fetais, contrações, sangramento, perda de líquido, febre.</li>
                  <li>Sinais de gravidade: dor de cabeça forte, visão embaçada, falta de ar, dor intensa no abdome superior, inchaço importante.</li>
                  <li>Plano de parto: local de referência, documentos, sinais para ir à maternidade, transporte.</li>
                </ul>

                <h4>Explicação simples para a paciente</h4>
                <ul>
                  <li>“Vamos repetir alguns exames porque, mesmo que antes estivesse tudo normal, algumas infecções e alterações podem aparecer mais tarde e precisam ser tratadas a tempo.”</li>
                </ul>
              `
            }
          }
        },

        puericultura: {
          title: "Consulta puericultura",
          subtitle: "Roteiro prático com o que observar, perguntar e quais testes/triagens devem estar em dia.",
          html: `
            <h4>Quando acompanhar (consultas de rotina)</h4>
            <ul>
              <li>Consulta na primeira semana de vida (muito importante para avaliar mãe e bebê).</li>
              <li>Consultas de rotina: 1, 2, 4, 6, 9, 12, 18 e 24 meses; após 2 anos, pelo menos 1 vez ao ano (ou mais, se necessário).</li>
            </ul>

            <h4>Triagens (testes) que devem estar registrados</h4>
            <ul>
              <li>Teste do pezinho: idealmente entre o 3º e 5º dia de vida.</li>
              <li>Teste da orelhinha: entre 24 e 48 horas após o nascimento e, no máximo, durante o 1º mês.</li>
              <li>Teste do coraçãozinho: oximetria de pulso após 24 horas de vida (geralmente na maternidade).</li>
              <li>Teste do olhinho: triagem ocular no recém-nascido (registrar resultado e encaminhar se alterado).</li>
            </ul>

            <h4>O que fazer na consulta (bem detalhado)</h4>
            <ul>
              <li>Medir peso, comprimento/estatura e perímetro cefálico (quando aplicável), e comparar com as curvas.</li>
              <li>Perguntar sobre alimentação: aleitamento materno (exclusivo ou não), dificuldades para mamar, vômitos, diarreia, constipação.</li>
              <li>Checar vacinação: comparar com o Calendário Nacional e orientar próximas doses.</li>
              <li>Avaliar desenvolvimento: olhar, sorriso, controle de cabeça, sentar, engatinhar, andar, fala e interação, conforme a idade.</li>
              <li>Exame físico: pele, respiração, coração, abdome, quadril (quando indicado), olhos, ouvidos, boca, genitália, coluna, tônus.</li>
              <li>Orientar sinais de alarme: febre em recém-nascido, dificuldade para respirar, recusa alimentar persistente, sonolência excessiva, vômitos em jato, sangue nas fezes, icterícia intensa.</li>
            </ul>
          `
        },

        planejamento: {
          title: "Consulta planejamento familiar",
          subtitle: "Roteiro para orientar escolha do método contraceptivo com segurança e linguagem simples.",
          html: `
            <h4>Passo 1: entender o objetivo da pessoa</h4>
            <ul>
              <li>Quer evitar gravidez agora? Por quanto tempo? Quer engravidar em breve?</li>
              <li>Tem parceiro(a)? Usa preservativo? Há risco de IST?</li>
              <li>Já usou algum método? Teve efeitos colaterais? Está satisfeita?</li>
            </ul>

            <h4>Passo 2: checagem de segurança (antes de indicar um método)</h4>
            <ul>
              <li>Medir pressão arterial e peso/IMC.</li>
              <li>Perguntar sobre enxaqueca com aura, trombose, câncer de mama, hepatopatias, sangramento uterino inexplicado, tabagismo (principalmente &gt; 35 anos).</li>
              <li>Se houver chance de gravidez, orientar teste de gravidez e/ou critérios clínicos para excluir gestação.</li>
            </ul>

            <h4>Exames: o que é rotina e o que é por indicação</h4>
            <ul>
              <li>Em geral, a consulta se baseia em história e exame físico (especialmente pressão). Exames laboratoriais não são exigência “para todo mundo” e devem ser solicitados quando houver indicação clínica.</li>
              <li>Para DIU, deve haver avaliação clínica e ginecológica conforme protocolos do serviço; se houver risco de IST, orientar investigação e manejo.</li>
              <li>Citopatológico (preventivo) deve seguir o protocolo do rastreamento do colo do útero; não é “obrigatório” para iniciar todos os métodos, mas deve estar em dia conforme idade/intervalo.</li>
            </ul>

            <h4>Explicação simples dos métodos (para leigos)</h4>
            <ul>
              <li><b>Preservativo:</b> protege contra gravidez e IST. Precisa usar em todas as relações.</li>
              <li><b>Pílula/adesivo/anel (com hormônio):</b> muito eficaz se usado certo; pode ter restrições em quem tem risco de trombose ou pressão alta descontrolada.</li>
              <li><b>Injetável:</b> aplicação mensal ou trimestral; pode alterar o sangramento.</li>
              <li><b>DIU:</b> longa duração; a pessoa não precisa lembrar todo dia. Pode ser de cobre ou hormonal (quando disponível).</li>
              <li><b>Laqueadura/vasectomia:</b> métodos definitivos; exige decisão muito segura.</li>
            </ul>

            <h4>Fechamento</h4>
            <ul>
              <li>Confirmar que a pessoa entendeu como usar o método e o que fazer se esquecer.</li>
              <li>Orientar retorno (efeitos colaterais, adaptação, revisão) e sinais de alerta (dor forte, sangramento intenso, falta de ar, dor na perna, desmaio).</li>
            </ul>
          `
        },

        hiperdia: {
          title: "Consulta hiperdia",
          subtitle: "Checklist de consulta para hipertensão e diabetes, com monitoramento e exames recomendados pelo Ministério da Saúde (PCDT).",
          html: `
            <h4>1) Perguntas essenciais (o que não pode faltar)</h4>
            <ul>
              <li>Quais remédios está usando (nome, dose, horário)? Está tomando todos os dias?</li>
              <li>Teve efeitos colaterais? Teve hipoglicemia (tremor, suor frio, confusão, desmaio)?</li>
              <li>Teve dor no peito, falta de ar, inchaço, fraqueza em um lado do corpo, alteração de visão?</li>
              <li>Como está a alimentação, atividade física, sono, tabagismo e álcool?</li>
            </ul>

            <h4>2) Exame físico (rotina em toda consulta)</h4>
            <ul>
              <li>Pressão arterial, peso/IMC e circunferência abdominal.</li>
              <li>Avaliar edema, ausculta cardíaca, pulsos periféricos e sinais de insuficiência cardíaca.</li>
              <li>Para diabetes: examinar os pés (pele, unhas, feridas, sensibilidade e pulsos) e orientar cuidados diários.</li>
            </ul>

            <h4>3) Monitoramento e periodicidade (HAS)</h4>
            <ul>
              <li><b>Reavaliação inicial:</b> mensal até alcançar a meta de pressão; depois, a cada 3–6 meses no primeiro ano e, após controle, pode ser semestral.</li>
              <li><b>Exames laboratoriais:</b> perfil lipídico, glicemia de jejum ou HbA1c, creatinina, potássio (e sódio se em diurético tiazídico), urinálise; solicitar anualmente ou pelo menos a cada 2 anos, conforme o caso.</li>
              <li><b>Eletrocardiograma:</b> solicitar para avaliação e acompanhamento conforme necessidade clínica.</li>
            </ul>

            <h4>4) Monitoramento e periodicidade (DM2)</h4>
            <ul>
              <li><b>Consultas:</b> reavaliar no máximo a cada 3 a 6 meses, ajustando o tratamento conforme metas e risco.</li>
              <li><b>Em cada consulta:</b> peso, pressão arterial e estratificação de risco cardiovascular.</li>
              <li><b>Ao diagnóstico e anualmente:</b> perfil lipídico, creatinina/albuminúria (nefropatia), fundoscopia (retinopatia), avaliação do pé diabético (monofilamento e pulsos podais).</li>
              <li><b>Ao diagnóstico e a cada 6 meses:</b> glicemia de jejum e hemoglobina glicada (HbA1c).</li>
            </ul>

            <h4>5) Orientações em linguagem simples (para o paciente entender)</h4>
            <ul>
              <li><b>Pressão alta</b> costuma não dar sintoma. Mesmo “se sentindo bem”, precisa tratar para evitar AVC, infarto e problemas no rim.</li>
              <li><b>Diabetes</b> pode machucar olhos, rins e pés “por dentro”. Os exames e o exame do pé servem para detectar cedo.</li>
              <li><b>Procure urgência se</b>: dor no peito, falta de ar forte, desmaio, confusão, fraqueza em um lado do corpo, glicemia muito baixa com rebaixamento.</li>
            </ul>
          `
        },puerperio: {
          title: "Consulta de puerpério",
          subtitle: "Roteiro para a consulta pós-parto com foco em segurança, amamentação, saúde mental e planejamento reprodutivo.",
          html: `
            <h4>Quando fazer</h4>
            <ul>
              <li>Atenção à mulher e ao recém-nascido na primeira semana após o parto.</li>
              <li>Consulta puerperal até o 42º dia pós-parto (6 semanas).</li>
            </ul>

            <h4>O que perguntar (bem detalhado)</h4>
            <ul>
              <li>Sangramento: quantidade, odor, coágulos; febre; dor pélvica; secreção na ferida (cesárea/episiotomia).</li>
              <li>Sintomas urinários e intestinais; dor intensa; tontura; falta de ar.</li>
              <li>Amamentação: pega, dor, fissuras, ingurgitamento, mastite; ganho de peso do bebê.</li>
              <li>Humor: tristeza persistente, ansiedade intensa, insônia grave, pensamentos de autoagressão (avaliar risco).</li>
              <li>Contracepção e retorno da atividade sexual.</li>
            </ul>

            <h4>Exame físico</h4>
            <ul>
              <li>Pressão arterial, estado geral e sinais de anemia/desidratação.</li>
              <li>Mamas (se dor, febre, fissuras), abdome e avaliação uterina conforme queixa e período.</li>
              <li>Ferida operatória/episiotomia: sinais de infecção.</li>
            </ul>

            <h4>Exames e condutas lembradas pelo MS</h4>
            <ul>
              <li>Se não foi feito durante o pré-natal, ofertar teste anti-HIV e VDRL no puerpério, considerando o risco e a disponibilidade.</li>
              <li>Reposição de ferro se anemia/situações de risco e orientação alimentar para recuperação.</li>
              <li>Planejamento reprodutivo: orientar método seguro no puerpério conforme condição clínica e amamentação.</li>
            </ul>

            <h4>Explicação simples para a paciente</h4>
            <ul>
              <li>“Essa consulta serve para garantir que você está se recuperando bem do parto, que o bebê está bem, e para evitar problemas que podem aparecer depois que você já foi para casa.”</li>
            </ul>
          `
        },

        sbar: {
          title: "Perguntas para Passagem de Plantão (SBAR)",
          subtitle: "Use este roteiro para coletar rapidamente informações e montar um SBAR claro para o próximo profissional.",
          html: `
            <h4>S (Situação) – o que está acontecendo agora</h4>
            <ul>
              <li>Quem é o paciente (nome, idade, identificação) e onde está (sala/leito/consultório)?</li>
              <li>Qual é o problema principal neste momento?</li>
              <li>Há instabilidade? (queda de pressão, falta de ar, rebaixamento de consciência, dor intensa, sangramento)</li>
              <li>Sinais vitais atuais e tendência (melhorou/piorou)?</li>
            </ul>

            <h4>B (Background) – contexto e histórico relevante</h4>
            <ul>
              <li>Diagnósticos principais e comorbidades importantes.</li>
              <li>Motivo de internação/atendimento e evolução até aqui (em 2–3 frases).</li>
              <li>Alergias, medicamentos em uso e intervenções recentes (antibiótico, soro, oxigênio, procedimentos).</li>
              <li>Resultados relevantes já disponíveis (exames, imagem) e pendências (o que ainda falta sair).</li>
            </ul>

            <h4>A (Avaliação) – interpretação e o que você acha que é</h4>
            <ul>
              <li>Como você interpreta o quadro agora? (ex.: “piora respiratória com provável pneumonia”, “hipotensão possivelmente por desidratação”)</li>
              <li>Principais riscos nas próximas horas (choque, rebaixamento, sangramento, hipoglicemia, crise hipertensiva).</li>
              <li>Resposta ao que foi feito até agora (melhorou com medicação? persistiu?).</li>
            </ul>

            <h4>R (Recomendação) – o que precisa ser feito a seguir</h4>
            <ul>
              <li>O que você precisa que o próximo profissional faça (objetivo e claro).</li>
              <li>Monitorização: frequência de sinais vitais, controle de glicemia, diurese, dor, saturação.</li>
              <li>Condutas pendentes: exames a coletar, medicações a administrar, reavaliação em X minutos/horas.</li>
              <li>Quando chamar médico imediatamente (critérios objetivos).</li>
            </ul>
          `
        }
      };

      let currentConsultKey = null;
      let currentTri = 1;

      function setActive(btn) {
        consultButtons.forEach(b => b.classList.remove("active"));
        if (btn) btn.classList.add("active");
      }

      function renderGuide(key) {
        const g = GUIDE[key];
        if (!g) return;

        titleEl.textContent = g.title || "";
        subtitleEl.textContent = g.subtitle || "";
        drawer.classList.remove("hidden");

        if (key === "prenatal") {
          prenatalTriRow.classList.remove("hidden");
          // Seleciona trimestre atual
          triBtns.forEach(b => {
            const tri = Number(b.getAttribute("data-tri"));
            if (tri === currentTri) b.classList.add("active");
            else b.classList.remove("active");
          });
          const triData = g.trimester?.[currentTri] || g.trimester?.[1];
          if (triData) {
            subtitleEl.textContent = triData.subtitle || g.subtitle || "";
            contentEl.innerHTML = triData.html || "";
          } else {
            contentEl.textContent = "Conteúdo indisponível.";
          }
        } else {
          prenatalTriRow.classList.add("hidden");
          contentEl.innerHTML = g.html || "";
        }
      }

      function openGuide(key, btn) {
        currentConsultKey = key;
        currentTri = 1;
        setActive(btn);
        renderGuide(key);
        try {
          drawer.scrollIntoView({ behavior: "smooth", block: "start" });
        } catch (e) {}
      }

      function closeGuide() {
        drawer.classList.add("hidden");
        prenatalTriRow.classList.add("hidden");
        contentEl.innerHTML = "";
        currentConsultKey = null;
        consultButtons.forEach(b => b.classList.remove("active"));
      }

      consultButtons.forEach(btn => {
        btn.addEventListener("click", () => {
          const key = btn.getAttribute("data-consult");
          if (!key) return;
          openGuide(key, btn);
        });
      });

      triBtns.forEach(btn => {
        btn.addEventListener("click", () => {
          const tri = Number(btn.getAttribute("data-tri"));
          if (!Number.isFinite(tri) || tri < 1 || tri > 3) return;
          currentTri = tri;
          if (currentConsultKey === "prenatal") renderGuide("prenatal");
        });
      });

      closeBtn.addEventListener("click", closeGuide);

      // Fecha com ESC quando o drawer estiver aberto
      document.addEventListener("keydown", (ev) => {
        if (ev.key === "Escape" && drawer && !drawer.classList.contains("hidden")) closeGuide();
      });
    })();

// ============================
    // MÓDULO: Calculadoras Clínicas
    // ============================
    const calculatorsCard = document.getElementById("calculatorsCard");
    const calcSelect = document.getElementById("calcSelect");

    const calcPanels = {
      imc: document.getElementById("calcPanel_imc"),
      cv_risk: document.getElementById("calcPanel_cv_risk"),
      bsa: document.getElementById("calcPanel_bsa"),
      gest_age: document.getElementById("calcPanel_gest_age"),
      drip_pump: document.getElementById("calcPanel_drip_pump"),
      fluid_balance: document.getElementById("calcPanel_fluid_balance"),
      weight_dose: document.getElementById("calcPanel_weight_dose"),
      glasgow: document.getElementById("calcPanel_glasgow"),
      sedation: document.getElementById("calcPanel_sedation"),
      pain: document.getElementById("calcPanel_pain"),
      morse: document.getElementById("calcPanel_morse"),
      braden: document.getElementById("calcPanel_braden"),
      pews: document.getElementById("calcPanel_pews"),
    };

    function safeNumber(v) {
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    }

    function formatPtNumber(n, decimals = 2) {
      if (!Number.isFinite(n)) return "-";
      return n.toLocaleString("pt-BR", { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
    }

    function parseDateYYYYMMDD(value) {
      if (!value) return null;
      const parts = String(value).split("-");
      if (parts.length !== 3) return null;
      const y = Number(parts[0]);
      const m = Number(parts[1]);
      const d = Number(parts[2]);
      if (!Number.isFinite(y) || !Number.isFinite(m) || !Number.isFinite(d)) return null;
      // horário do meio-dia para reduzir risco de variações por fuso/DST
      return new Date(y, m - 1, d, 12, 0, 0, 0);
    }

    function formatDatePt(dateObj) {
      try {
        return dateObj.toLocaleDateString("pt-BR");
      } catch (e) {
        return "-";
      }
    }

    function showCalcPanel(key) {
      Object.keys(calcPanels).forEach(k => {
        const el = calcPanels[k];
        if (!el) return;
        if (k === key) el.classList.remove("hidden");
        else el.classList.add("hidden");
      });
    }

    if (calcSelect) {
      calcSelect.addEventListener("change", () => {
        showCalcPanel(calcSelect.value);
      });
      showCalcPanel(calcSelect.value || "imc");
    }

    // IMC
    const imcWeightKg = document.getElementById("imcWeightKg");
    const imcHeightCm = document.getElementById("imcHeightCm");
    const imcResult = document.getElementById("imcResult");

    function calcIMC() {
      if (!imcResult) return;
      const w = safeNumber(imcWeightKg?.value);
      const hcm = safeNumber(imcHeightCm?.value);
      if (!w || !hcm || w <= 0 || hcm <= 0) {
        imcResult.textContent = "Preencha peso e altura.";
        return;
      }
      const hm = hcm / 100;
      const bmi = w / (hm * hm);
      let cat = "";
      if (bmi < 18.5) cat = "Baixo peso";
      else if (bmi < 25) cat = "Eutrofia";
      else if (bmi < 30) cat = "Sobrepeso";
      else if (bmi < 35) cat = "Obesidade grau I";
      else if (bmi < 40) cat = "Obesidade grau II";
      else cat = "Obesidade grau III";
      imcResult.textContent = `IMC: ${formatPtNumber(bmi, 1)}\nClassificação: ${cat}`;
    }
    [imcWeightKg, imcHeightCm].forEach(el => el && el.addEventListener("input", calcIMC));
    calcIMC();

    // Risco cardiovascular (PREVENT - SBC/TribeMD)
    const cvAge = document.getElementById("cvAge");
    const cvSex = document.getElementById("cvSex");
    const cvWeightKg = document.getElementById("cvWeightKg");
    const cvHeightCm = document.getElementById("cvHeightCm");
    const cvSbp = document.getElementById("cvSbp");
    const cvCreatinine = document.getElementById("cvCreatinine");
    const cvTotalChol = document.getElementById("cvTotalChol");
    const cvHdl = document.getElementById("cvHdl");
    const cvSmoker = document.getElementById("cvSmoker");
    const cvDiabetes = document.getElementById("cvDiabetes");
    const cvOnHtnMeds = document.getElementById("cvOnHtnMeds");
    const cvOnStatin = document.getElementById("cvOnStatin");
    const cvRiskResult = document.getElementById("cvRiskResult");

    // Coeficientes: PREVENT (AHA) - Base model (sem fatores "novos"): 10 anos e 30 anos.
    // Referência técnica dos coeficientes: tabela do PREVENT (AHA) conforme EBMcalc.
    const PREVENT_BASE_10 = {
      C0: [0.7939329, 0.7688528, 0.719883, 0.7099847, 0.8998235, 0.8972642],
      C1: [0, 0, 0, 0, 0, 0],
      C2: [0.0305239, 0.0736174, 0.1176967, 0.1658663, 0, 0],
      C3: [-0.1606857, -0.0954431, -0.151185, -0.1144285, 0, 0],
      C4: [-0.2394003, -0.4347345, -0.0835358, -0.2837212, -0.4559771, -0.6811466],
      C5: [0.3600781, 0.3362658, 0.3592852, 0.3239977, 0.3576505, 0.3634461],
      C6: [0.8667604, 0.7692857, 0.8348585, 0.7189597, 1.038346, 0.923776],
      C7: [0.5360739, 0.4386871, 0.4831078, 0.3956973, 0.583916, 0.5023736],
      C8: [0, 0, 0, 0, -0.0072294, -0.0485841],
      C9: [0, 0, 0, 0, 0.2997706, 0.3726929],
      C10: [0.6045917, 0.5378979, 0.4864619, 0.3690075, 0.7451638, 0.6926917],
      C11: [0.0433769, 0.0164827, 0.0397779, 0.0203619, 0.0557087, 0.0251827],
      C12: [0.3151672, 0.288879, 0.2265309, 0.2036522, 0.3534442, 0.2980922],
      C13: [-0.1477655, -0.1337349, -0.0592374, -0.0865581, 0, 0],
      C14: [-0.0663612, -0.0475924, -0.0395762, -0.0322916, -0.0981511, -0.0497731],
      C15: [0.1197879, 0.150273, 0.0844423, 0.114563, 0, 0],
      C16: [-0.0819715, -0.0517874, -0.0567839, -0.0300005, 0, 0],
      C17: [0.0306769, 0.0191169, 0.0325692, 0.0232747, 0, 0],
      C18: [-0.0946348, -0.1049477, -0.1035985, -0.0927024, -0.0946663, -0.1289201],
      C19: [-0.27057, -0.2251948, -0.2417542, -0.2018525, -0.3581041, -0.3040924],
      C20: [-0.078715, -0.0895067, -0.0791142, -0.0970527, -0.1159453, -0.1401688],
      C21: [0, 0, 0, 0, -0.003878, 0.0068126],
      C22: [-0.1637806, -0.1543702, -0.1671492, -0.1217081, -0.1884289, -0.1797778],
      C23: [0, 0, 0, 0, 0, 0],
      C24: [0, 0, 0, 0, 0, 0],
      C25: [0, 0, 0, 0, 0, 0],
      C26: [0, 0, 0, 0, 0, 0],
      C27: [0, 0, 0, 0, 0, 0],
      C28: [0, 0, 0, 0, 0, 0],
      C29: [0, 0, 0, 0, 0, 0],
      C30: [0, 0, 0, 0, 0, 0],
      C31: [-3.307728, -3.031168, -3.819975, -3.500655, -4.310409, -3.946391],
    };

    const PREVENT_BASE_30 = {
      C0: [0.5503079, 0.4627309, 0.4669202, 0.3994099, 0.6254374, 0.5681541],
      C1: [-0.0928369, -0.0984281, -0.0893118, -0.0937484, -0.0983038, -0.1048388],
      C2: [0.0409794, 0.0836088, 0.1256901, 0.1744643, 0, 0],
      C3: [-0.1663306, -0.1029824, -0.1542255, -0.120203, 0, 0],
      C4: [-0.1628654, -0.2140352, -0.0018093, -0.0665117, -0.3919241, -0.4761564],
      C5: [0.3299505, 0.2904325, 0.322949, 0.2753037, 0.3142295, 0.30324],
      C6: [0.6793894, 0.5331276, 0.6296707, 0.4790257, 0.8330787, 0.6840338],
      C7: [0.3196112, 0.2141914, 0.268292, 0.1782635, 0.3438651, 0.2656273],
      C8: [0, 0, 0, 0, 0.0594874, 0.0833107],
      C9: [0, 0, 0, 0, 0.2525536, 0.26999],
      C10: [0.1857101, 0.1155556, 0.100106, -0.0218789, 0.2981642, 0.2541805],
      C11: [0.0553528, 0.0603775, 0.0499663, 0.0602553, 0.0667159, 0.0638923],
      C12: [0.2894, 0.232714, 0.1875292, 0.1421182, 0.333921, 0.2583631],
      C13: [-0.075688, -0.0272112, 0.0152476, 0.0135996, 0, 0],
      C14: [-0.056367, -0.0384488, -0.0276123, -0.0218265, -0.0893177, -0.0391938],
      C15: [0.1071019, 0.134192, 0.0736147, 0.1013148, 0, 0],
      C16: [-0.0751438, -0.0511759, -0.0521962, -0.0312619, 0, 0],
      C17: [0.0301786, 0.0165865, 0.0316918, 0.020673, 0, 0],
      C18: [-0.0998776, -0.1101437, -0.1046101, -0.0920935, -0.0974299, -0.1269124],
      C19: [-0.3206166, -0.2585943, -0.2727793, -0.2159947, -0.404855, -0.3273572],
      C20: [-0.1607862, -0.1566406, -0.1530907, -0.1548811, -0.1982991, -0.2043019],
      C21: [0, 0, 0, 0, -0.0035619, -0.0182831],
      C22: [-0.1450788, -0.1166776, -0.1299149, -0.0712547, -0.1564215, -0.1342618],
      C23: [0, 0, 0, 0, 0, 0],
      C24: [0, 0, 0, 0, 0, 0],
      C25: [0, 0, 0, 0, 0, 0],
      C26: [0, 0, 0, 0, 0, 0],
      C27: [0, 0, 0, 0, 0, 0],
      C28: [0, 0, 0, 0, 0, 0],
      C29: [0, 0, 0, 0, 0, 0],
      C30: [0, 0, 0, 0, 0, 0],
      C31: [-1.318827, -1.148204, -1.974074, -1.736444, -2.205379, -1.95751],
    };

    function preventIndex(endpoint, sex) {
      const sx = (sex === "male") ? "m" : "f";
      if (endpoint === "total") return sx === "f" ? 0 : 1;
      if (endpoint === "ascvd") return sx === "f" ? 2 : 3;
      return sx === "f" ? 4 : 5; // hf
    }

    function preventEgfrCkdEpi2021(creatinineMgDl, ageYears, sex) {
      // CKD-EPI 2021 (sem raça): https://www.kidney.org/professionals/kdoqi/gfr_calculator (equação 2021)
      const scr = creatinineMgDl;
      const age = ageYears;
      const female = (sex !== "male");

      const kappa = female ? 0.7 : 0.9;
      const alpha = female ? -0.241 : -0.302;
      const sexFactor = female ? 1.012 : 1.0;

      const minPart = Math.min(scr / kappa, 1);
      const maxPart = Math.max(scr / kappa, 1);

      const egfr = 142 * Math.pow(minPart, alpha) * Math.pow(maxPart, -1.2) * Math.pow(0.9938, age) * sexFactor;
      return egfr;
    }

    function preventRiskPct(logit) {
      // 100 * exp(x) / (1 + exp(x))
      const ex = Math.exp(logit);
      const p = ex / (1 + ex);
      return p * 100;
    }

    function preventComputeLogit(model, endpoint, sex, v) {
      const idx = preventIndex(endpoint, sex);
      const C = (name) => (model[name] ? model[name][idx] : 0);

      // Variáveis conforme especificação do PREVENT:
      const ageTerm = (v.age - 55) / 10;
      const nonHdlTerm = (((v.totalChol - v.hdl) * 0.02586) - 3.5); // mmol/L
      const hdlTerm = ((v.hdl * 0.02586) - 1.3) / 0.3; // mmol/L

      const sbpLow = (Math.min(v.sbp, 110) - 110) / 20;
      const sbpHigh = (Math.max(v.sbp, 110) - 130) / 20;

      const bmiLow = (Math.min(v.bmi, 30) - 25) / 5;
      const bmiHigh = (Math.max(v.bmi, 30) - 30) / 5;

      const egfrLow = (Math.min(v.egfr, 60) - 60) / -15;
      const egfrHigh = (Math.max(v.egfr, 60) - 90) / -15;

      const diabetes = v.diabetes ? 1 : 0;
      const smoker = v.smoker ? 1 : 0;
      const onHtnMeds = v.onHtnMeds ? 1 : 0;
      const onStatin = v.onStatin ? 1 : 0;

      const logit =
        (C("C0") * ageTerm) +
        (C("C1") * (ageTerm * ageTerm)) +
        (C("C2") * nonHdlTerm) +
        (C("C3") * hdlTerm) +
        (C("C4") * sbpLow) +
        (C("C5") * sbpHigh) +
        (C("C6") * diabetes) +
        (C("C7") * smoker) +
        (C("C8") * bmiLow) +
        (C("C9") * bmiHigh) +
        (C("C10") * egfrLow) +
        (C("C11") * egfrHigh) +
        (C("C12") * onHtnMeds) +
        (C("C13") * onStatin) +
        (C("C14") * onHtnMeds * sbpHigh) +
        (C("C15") * onStatin * nonHdlTerm) +
        (C("C16") * ageTerm * nonHdlTerm) +
        (C("C17") * ageTerm * hdlTerm) +
        (C("C18") * ageTerm * sbpHigh) +
        (C("C19") * ageTerm * diabetes) +
        (C("C20") * ageTerm * smoker) +
        (C("C21") * bmiHigh) +
        (C("C22") * ageTerm * egfrLow) +
        (C("C31"));

      return logit;
    }

    function cvRiskBandAscvd10y(pct) {
      if (!Number.isFinite(pct)) return "-";
      if (pct < 5) return "Baixo (<5%)";
      if (pct < 7.5) return "Limítrofe (5% a <7,5%)";
      if (pct < 20) return "Intermediário (7,5% a <20%)";
      return "Alto (≥20%)";
    }

    function calcCvRiskPrevent() {
      if (!cvRiskResult) return;

      const age = safeNumber(cvAge?.value);
      const sex = cvSex?.value || "female";
      const w = safeNumber(cvWeightKg?.value);
      const hcm = safeNumber(cvHeightCm?.value);
      const sbp = safeNumber(cvSbp?.value);
      const scr = safeNumber(cvCreatinine?.value);
      const tc = safeNumber(cvTotalChol?.value);
      const hdl = safeNumber(cvHdl?.value);
      const smoker = Number(cvSmoker?.value || "0") === 1;
      const diabetes = Number(cvDiabetes?.value || "0") === 1;
      const onHtnMeds = Number(cvOnHtnMeds?.value || "0") === 1;
      const onStatin = Number(cvOnStatin?.value || "0") === 1;

      const missing = [];
      if (!age || age <= 0) missing.push("idade");
      if (!w || w <= 0) missing.push("peso");
      if (!hcm || hcm <= 0) missing.push("altura");
      if (!sbp || sbp <= 0) missing.push("PAS");
      if (!scr || scr <= 0) missing.push("creatinina");
      if (!tc || tc <= 0) missing.push("colesterol total");
      if (!hdl || hdl <= 0) missing.push("HDL");

      if (missing.length) {
        cvRiskResult.textContent = "Preencha: " + missing.join(", ") + ".";
        return;
      }

      const hm = hcm / 100;
      const bmi = w / (hm * hm);
      const egfr = preventEgfrCkdEpi2021(scr, age, sex);

      const v = {
        age,
        sbp,
        totalChol: tc,
        hdl,
        bmi,
        egfr,
        smoker,
        diabetes,
        onHtnMeds,
        onStatin
      };

      const total10 = preventRiskPct(preventComputeLogit(PREVENT_BASE_10, "total", sex, v));
      const ascvd10 = preventRiskPct(preventComputeLogit(PREVENT_BASE_10, "ascvd", sex, v));
      const hf10 = preventRiskPct(preventComputeLogit(PREVENT_BASE_10, "hf", sex, v));

      let text = "";
      const warnings = [];
      if (age < 30 || age > 79) warnings.push("Faixa etária fora do intervalo típico (30 a 79 anos) do PREVENT; interpretar com cautela.");
      if (egfr <= 0 || !Number.isFinite(egfr)) warnings.push("Não foi possível estimar eTFG com segurança; verifique creatinina/idade/sexo.");
      if (warnings.length) text += warnings.map(w => "Atenção: " + w).join("\n") + "\n\n";

      text += `IMC: ${formatPtNumber(bmi, 1)} kg/m²\n`;
      text += `eTFG (CKD-EPI 2021): ${formatPtNumber(egfr, 0)} mL/min/1,73m²\n\n`;

      text += `Risco em 10 anos (PREVENT)\n`;
      text += `CVD total: ${formatPtNumber(total10, 1)}%\n`;
      text += `ASCVD: ${formatPtNumber(ascvd10, 1)}% (${cvRiskBandAscvd10y(ascvd10)})\n`;
      text += `Insuficiência cardíaca: ${formatPtNumber(hf10, 1)}%\n`;

      // 30-year: aplicável principalmente para 30-59 anos
      if (age >= 30 && age <= 59) {
        const total30 = preventRiskPct(preventComputeLogit(PREVENT_BASE_30, "total", sex, v));
        const ascvd30 = preventRiskPct(preventComputeLogit(PREVENT_BASE_30, "ascvd", sex, v));
        const hf30 = preventRiskPct(preventComputeLogit(PREVENT_BASE_30, "hf", sex, v));
        text += `\nRisco em 30 anos (PREVENT)\n`;
        text += `CVD total: ${formatPtNumber(total30, 1)}%\n`;
        text += `ASCVD: ${formatPtNumber(ascvd30, 1)}%\n`;
        text += `Insuficiência cardíaca: ${formatPtNumber(hf30, 1)}%\n`;
      } else {
        text += `\nRisco em 30 anos: aplicável principalmente para 30 a 59 anos.\n`;
      }

      text += `\nObservação: ferramenta de apoio. A interpretação e conduta dependem do contexto clínico e diretriz adotada.`;

      cvRiskResult.textContent = text;
    }

    [
      cvAge, cvSex, cvWeightKg, cvHeightCm, cvSbp, cvCreatinine,
      cvTotalChol, cvHdl, cvSmoker, cvDiabetes, cvOnHtnMeds, cvOnStatin
    ].forEach(el => el && el.addEventListener("input", calcCvRiskPrevent));
    [cvSex, cvSmoker, cvDiabetes, cvOnHtnMeds, cvOnStatin].forEach(el => el && el.addEventListener("change", calcCvRiskPrevent));
    calcCvRiskPrevent();


    // BSA (Mosteller)
    const bsaWeightKg = document.getElementById("bsaWeightKg");
    const bsaHeightCm = document.getElementById("bsaHeightCm");
    const bsaResult = document.getElementById("bsaResult");

    function calcBSA() {
      if (!bsaResult) return;
      const w = safeNumber(bsaWeightKg?.value);
      const hcm = safeNumber(bsaHeightCm?.value);
      if (!w || !hcm || w <= 0 || hcm <= 0) {
        bsaResult.textContent = "Preencha peso e altura.";
        return;
      }
      const bsa = Math.sqrt((hcm * w) / 3600);
      bsaResult.textContent = `SC (Mosteller): ${formatPtNumber(bsa, 2)} m²`;
    }
    [bsaWeightKg, bsaHeightCm].forEach(el => el && el.addEventListener("input", calcBSA));
    calcBSA();

    // Idade gestacional (por DUM)
    const gestDum = document.getElementById("gestDum");
    const gestResult = document.getElementById("gestResult");

    function calcGestAge() {
      if (!gestResult) return;
      const dum = parseDateYYYYMMDD(gestDum?.value);
      if (!dum) {
        gestResult.textContent = "Informe a DUM.";
        return;
      }
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 12, 0, 0, 0);
      const diffMs = today.getTime() - dum.getTime();
      const diffDays = Math.floor(diffMs / (24 * 60 * 60 * 1000));
      if (diffDays < 0) {
        gestResult.textContent = "A DUM está no futuro. Verifique a data.";
        return;
      }
      const weeks = Math.floor(diffDays / 7);
      const days = diffDays % 7;

      const dpp = new Date(dum.getTime() + 280 * 24 * 60 * 60 * 1000);
      gestResult.textContent = `Idade gestacional hoje: ${weeks} semanas e ${days} dias\nDPP (DUM + 280 dias): ${formatDatePt(dpp)}\nDUM: ${formatDatePt(dum)}`;
    }
    gestDum && gestDum.addEventListener("change", calcGestAge);
    calcGestAge();

    // Gotejamento e bomba
    const dripVolumeMl = document.getElementById("dripVolumeMl");
    const dripTimeH = document.getElementById("dripTimeH");
    const dripTimeMin = document.getElementById("dripTimeMin");
    const dripFactor = document.getElementById("dripFactor");
    const dripResult = document.getElementById("dripResult");

    function calcDrip() {
      if (!dripResult) return;
      const vol = safeNumber(dripVolumeMl?.value);
      const h = safeNumber(dripTimeH?.value) ?? 0;
      const m = safeNumber(dripTimeMin?.value) ?? 0;
      const factor = safeNumber(dripFactor?.value);
      const totalMin = (h * 60) + m;

      if (!vol || vol <= 0 || !factor || factor <= 0 || !totalMin || totalMin <= 0) {
        dripResult.textContent = "Preencha volume, tempo e fator de gotejamento.";
        return;
      }

      const mlPerH = vol / (totalMin / 60);
      const gttPerMin = (vol * factor) / totalMin;

      dripResult.textContent =
        `Bomba de infusão: ${formatPtNumber(mlPerH, 1)} mL/h\nGotejamento: ${formatPtNumber(gttPerMin, 0)} gotas/min\n(Volume: ${formatPtNumber(vol, 1)} mL, Tempo: ${formatPtNumber(totalMin, 0)} min, Fator: ${formatPtNumber(factor, 0)} gotas/mL)`;
    }
    [dripVolumeMl, dripTimeH, dripTimeMin, dripFactor].forEach(el => el && el.addEventListener("input", calcDrip));
    dripFactor && dripFactor.addEventListener("change", calcDrip);
    calcDrip();

    // Balanço hídrico
    const fbInputMl = document.getElementById("fbInputMl");
    const fbOutputMl = document.getElementById("fbOutputMl");
    const fbWeightKg = document.getElementById("fbWeightKg");
    const fbHours = document.getElementById("fbHours");
    const fbResult = document.getElementById("fbResult");

    function calcFluidBalance() {
      if (!fbResult) return;
      const input = safeNumber(fbInputMl?.value) ?? 0;
      const output = safeNumber(fbOutputMl?.value) ?? 0;
      const bal = input - output;

      let msg = `Entradas: ${formatPtNumber(input, 0)} mL\nSaídas: ${formatPtNumber(output, 0)} mL\nBalanço: ${formatPtNumber(bal, 0)} mL`;

      const w = safeNumber(fbWeightKg?.value);
      const hours = safeNumber(fbHours?.value);
      if (w && w > 0 && hours && hours > 0) {
        const diuresis = output / (w * hours);
        msg += `\nDiurese estimada: ${formatPtNumber(diuresis, 2)} mL/kg/h`;
      }
      fbResult.textContent = msg;
    }
    [fbInputMl, fbOutputMl, fbWeightKg, fbHours].forEach(el => el && el.addEventListener("input", calcFluidBalance));
    calcFluidBalance();

    // Dose por peso
    const wdWeightKg = document.getElementById("wdWeightKg");
    const wdDoseMgKg = document.getElementById("wdDoseMgKg");
    const wdMaxDoseMg = document.getElementById("wdMaxDoseMg");
    const wdConcMgMl = document.getElementById("wdConcMgMl");
    const wdResult = document.getElementById("wdResult");

    function calcWeightDose() {
      if (!wdResult) return;
      const w = safeNumber(wdWeightKg?.value);
      const d = safeNumber(wdDoseMgKg?.value);
      if (!w || !d || w <= 0 || d <= 0) {
        wdResult.textContent = "Preencha peso e dose (mg/kg).";
        return;
      }
      let mg = w * d;
      const maxMg = safeNumber(wdMaxDoseMg?.value);
      let capped = false;
      if (maxMg && maxMg > 0 && mg > maxMg) {
        mg = maxMg;
        capped = true;
      }

      let msg = `Dose por tomada: ${formatPtNumber(mg, 2)} mg`;
      if (capped) msg += `\n(Aplicado limite de dose máxima: ${formatPtNumber(maxMg, 2)} mg)`;

      const conc = safeNumber(wdConcMgMl?.value);
      if (conc && conc > 0) {
        const ml = mg / conc;
        msg += `\nVolume por tomada: ${formatPtNumber(ml, 2)} mL (concentração: ${formatPtNumber(conc, 2)} mg/mL)`;
      }
      wdResult.textContent = msg;
    }
    [wdWeightKg, wdDoseMgKg, wdMaxDoseMg, wdConcMgMl].forEach(el => el && el.addEventListener("input", calcWeightDose));
    calcWeightDose();

    // Glasgow
    const gcsEye = document.getElementById("gcsEye");
    const gcsVerbal = document.getElementById("gcsVerbal");
    const gcsMotor = document.getElementById("gcsMotor");
    const gcsResult = document.getElementById("gcsResult");

    function calcGCS() {
      if (!gcsResult) return;
      const e = safeNumber(gcsEye?.value) ?? 0;
      const v = safeNumber(gcsVerbal?.value) ?? 0;
      const m = safeNumber(gcsMotor?.value) ?? 0;
      const total = e + v + m;
      let grav = "";
      if (total >= 13) grav = "Leve (13 a 15)";
      else if (total >= 9) grav = "Moderado (9 a 12)";
      else grav = "Grave (3 a 8)";
      gcsResult.textContent = `ECG total: ${total} (E${e} V${v} M${m})\nGravidade (interpretação usual): ${grav}`;
    }
    [gcsEye, gcsVerbal, gcsMotor].forEach(el => el && el.addEventListener("change", calcGCS));
    calcGCS();

    // Ramsay / RASS
    const ramsay = document.getElementById("ramsay");
    const rass = document.getElementById("rass");
    const sedationResult = document.getElementById("sedationResult");

    function ramsayText(score) {
      const map = {
        1: "Ansioso/agitado.",
        2: "Cooperativo/orientado/tranquilo.",
        3: "Responde apenas a comandos.",
        4: "Resposta rápida a estímulo (tátil/sonoro).",
        5: "Resposta lenta a estímulo.",
        6: "Sem resposta."
      };
      return map[score] || "-";
    }

    function rassText(score) {
      const map = {
        4: "Combativo.",
        3: "Muito agitado.",
        2: "Agitado.",
        1: "Inquieto.",
        0: "Alerta e calmo.",
        "-1": "Sonolento (desperta ao chamado).",
        "-2": "Sedação leve (breve despertar ao chamado).",
        "-3": "Sedação moderada (movimenta ou abre olhos à voz, sem contato visual).",
        "-4": "Sedação profunda (responde a estímulo físico).",
        "-5": "Não desperta."
      };
      return map[String(score)] || "-";
    }

    function calcSedation() {
      if (!sedationResult) return;
      const rs = safeNumber(ramsay?.value);
      const ra = safeNumber(rass?.value);
      const ram = rs ? `Ramsay: ${rs} - ${ramsayText(rs)}` : "Ramsay: -";
      const raa = (ra !== null) ? `RASS: ${ra} - ${rassText(ra)}` : "RASS: -";
      sedationResult.textContent = `${ram}\n${raa}`;
    }
    [ramsay, rass].forEach(el => el && el.addEventListener("change", calcSedation));
    calcSedation();

    // Dor
    const painScore = document.getElementById("painScore");
    const painResult = document.getElementById("painResult");

    function calcPain() {
      if (!painResult) return;
      const p = safeNumber(painScore?.value);
      if (p === null || p < 0 || p > 10) {
        painResult.textContent = "Informe um valor de 0 a 10.";
        return;
      }
      let cat = "";
      if (p === 0) cat = "Sem dor";
      else if (p <= 3) cat = "Dor leve";
      else if (p <= 6) cat = "Dor moderada";
      else cat = "Dor intensa";
      painResult.textContent = `Pontuação: ${p}\nClassificação: ${cat}`;
    }
    painScore && painScore.addEventListener("input", calcPain);
    calcPain();

    // Morse
    const morseFallHx = document.getElementById("morseFallHx");
    const morseSecondaryDx = document.getElementById("morseSecondaryDx");
    const morseAid = document.getElementById("morseAid");
    const morseIv = document.getElementById("morseIv");
    const morseGait = document.getElementById("morseGait");
    const morseMental = document.getElementById("morseMental");
    const morseResult = document.getElementById("morseResult");

    function calcMorse() {
      if (!morseResult) return;
      const items = [morseFallHx, morseSecondaryDx, morseAid, morseIv, morseGait, morseMental]
        .map(el => safeNumber(el?.value) ?? 0);
      const total = items.reduce((a,b) => a + b, 0);
      let risk = "";
      if (total <= 24) risk = "Baixo (0 a 24)";
      else if (total <= 44) risk = "Moderado (25 a 44)";
      else risk = "Alto (≥ 45)";
      morseResult.textContent = `Morse total: ${total}\nClassificação (interpretação usual): ${risk}`;
    }
    [morseFallHx, morseSecondaryDx, morseAid, morseIv, morseGait, morseMental].forEach(el => el && el.addEventListener("change", calcMorse));
    calcMorse();

    // Braden
    const brSensory = document.getElementById("brSensory");
    const brMoisture = document.getElementById("brMoisture");
    const brActivity = document.getElementById("brActivity");
    const brMobility = document.getElementById("brMobility");
    const brNutrition = document.getElementById("brNutrition");
    const brFriction = document.getElementById("brFriction");
    const bradenResult = document.getElementById("bradenResult");

    function calcBraden() {
      if (!bradenResult) return;
      const vals = [brSensory, brMoisture, brActivity, brMobility, brNutrition, brFriction]
        .map(el => safeNumber(el?.value) ?? 0);
      const total = vals.reduce((a,b) => a + b, 0);

      let cat = "";
      if (total <= 9) cat = "Risco muito alto (≤ 9)";
      else if (total <= 12) cat = "Risco alto (10 a 12)";
      else if (total <= 14) cat = "Risco moderado (13 a 14)";
      else if (total <= 18) cat = "Risco leve (15 a 18)";
      else cat = "Sem risco ou risco mínimo (19 a 23)";

      bradenResult.textContent = `Braden total: ${total}\nClassificação (interpretação usual): ${cat}`;
    }
    [brSensory, brMoisture, brActivity, brMobility, brNutrition, brFriction].forEach(el => el && el.addEventListener("change", calcBraden));
    calcBraden();

    // PEWS (Brighton)
    const pewsBehavior = document.getElementById("pewsBehavior");
    const pewsCardio = document.getElementById("pewsCardio");
    const pewsResp = document.getElementById("pewsResp");
    const pewsResult = document.getElementById("pewsResult");

    function calcPEWS() {
      if (!pewsResult) return;
      const b = safeNumber(pewsBehavior?.value) ?? 0;
      const c = safeNumber(pewsCardio?.value) ?? 0;
      const r = safeNumber(pewsResp?.value) ?? 0;
      const total = b + c + r;

      let cat = "";
      if (total <= 2) cat = "Baixo (0 a 2)";
      else if (total <= 4) cat = "Intermediário (3 a 4)";
      else cat = "Elevado (≥ 5)";

      pewsResult.textContent = `PEWS total: ${total} (Comportamento ${b}, Cardiovascular ${c}, Respiratório ${r})\nClassificação (orientação geral): ${cat}\nObservação: em muitas instituições, pontuação ≥ 3 exige reavaliação e possível escalonamento conforme protocolo local.`;
    }
    [pewsBehavior, pewsCardio, pewsResp].forEach(el => el && el.addEventListener("change", calcPEWS));
    calcPEWS();


    // ============================================================
        // MÓDULO: Escala de plantão (geração local + persistência no backend)
    // =========================================

    // Ocultar/mostrar o módulo "Escala de plantão" para economizar espaço na página
    const rosterToggleBtn = document.getElementById("rosterToggleBtn");
    const rosterPanelEl = document.getElementById("rosterShell");
    function setRosterOpen(open, doScroll) {
      if (!rosterToggleBtn || !rosterPanelEl) return;
      rosterPanelEl.style.display = open ? "block" : "none";
      rosterToggleBtn.textContent = open ? "Ocultar escala de plantão" : "Gerar escala de plantão";
      try { localStorage.setItem("roster_open", open ? "1" : "0"); } catch (e) {}
      if (open && doScroll) {
        setTimeout(() => {
          try { rosterPanelEl.scrollIntoView({ behavior: "smooth", block: "start" }); } catch (e) {}
        }, 80);
      }
    }
    if (rosterToggleBtn && rosterPanelEl) {
      let open = false;
      try { open = localStorage.getItem("roster_open") === "1"; } catch (e) { open = false; }
      setRosterOpen(open, false);
      rosterToggleBtn.addEventListener("click", () => {
        const currentlyOpen = rosterPanelEl.style.display !== "none";
        setRosterOpen(!currentlyOpen, true);
      });
    }

// ===================

    const rosterMonthEl = document.getElementById("rosterMonth");
    const rosterShiftModelEl = document.getElementById("rosterShiftModel");
    const rosterStartTimeEl = document.getElementById("rosterStartTime");

    const rosterNeedPerShiftWrap = document.getElementById("rosterNeedPerShiftWrap");
    const rosterNeedPerShiftEl = document.getElementById("rosterNeedPerShift");

    const rosterNeedDayWrap = document.getElementById("rosterNeedDayWrap");
    const rosterNeedDayEl = document.getElementById("rosterNeedDay");

    const rosterNeedNightWrap = document.getElementById("rosterNeedNightWrap");
    const rosterNeedNightEl = document.getElementById("rosterNeedNight");

    const rosterNeedAfternoonWrap = document.getElementById("rosterNeedAfternoonWrap");
    const rosterNeedAfternoonEl = document.getElementById("rosterNeedAfternoon");

    const rosterMaxConsecNightsWrap = document.getElementById("rosterMaxConsecNightsWrap");
    const rosterMaxConsecNightsEl = document.getElementById("rosterMaxConsecNights");

    const rosterCoverageBox = document.getElementById("rosterCoverageBox");
    const rosterModelNote = document.getElementById("rosterModelNote");

    const rosterTeamTbody = document.getElementById("rosterTeamTbody");
    const rosterTeamCards = document.getElementById("rosterTeamCards");

    const rosterWarnBox = document.getElementById("rosterWarnBox");
    const rosterOutput = document.getElementById("rosterOutput");
    const rosterOutputMobile = document.getElementById("rosterOutputMobile");
    const rosterTableOut = document.getElementById("rosterTableOut");
    const rosterSummaryOut = document.getElementById("rosterSummaryOut");

    const rosterAddPersonBtn = document.getElementById("rosterAddPersonBtn");
    const rosterBulkAddBtn = document.getElementById("rosterBulkAddBtn");
    const rosterSaveConfigBtn = document.getElementById("rosterSaveConfigBtn");
    const rosterLoadConfigBtn = document.getElementById("rosterLoadConfigBtn");

    const rosterGenerateBtn = document.getElementById("rosterGenerateBtn");
    const rosterSaveScheduleBtn = document.getElementById("rosterSaveScheduleBtn");
    const rosterExportCsvBtn = document.getElementById("rosterExportCsvBtn");
    const rosterPrintBtn = document.getElementById("rosterPrintBtn");

    const rosterHelpBtn = document.getElementById("rosterHelpBtn");
    const closeRosterHelpBtn = document.getElementById("closeRosterHelpBtn");
    const rosterHelpDrawer = document.getElementById("rosterHelpDrawer");

    let rosterTeam = [];
    let rosterLastGenerated = null; // { month, shiftModel, startTime, rows:[], summary:[], warnings:[], csv, printableTitle }

    function rosterTodayYYYYMM() {
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      return `${y}-${m}`;
    }

    function rosterIsoDate(d) {
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      return `${y}-${m}-${day}`;
    }

    function rosterDaysInMonth(yyyyMM) {
      const [yStr, mStr] = String(yyyyMM || "").split("-");
      const y = Number(yStr);
      const m = Number(mStr);
      if (!y || !m || m < 1 || m > 12) return [];
      const first = new Date(y, m - 1, 1);
      const days = [];
      for (let i = 0; i < 40; i++) {
        const d = new Date(y, m - 1, 1 + i);
        if (d.getMonth() !== first.getMonth()) break;
        days.push(rosterIsoDate(d));
      }
      return days;
    }


    function rosterIsWeekend(dateIso) {
      try {
        const d = new Date(String(dateIso || "") + "T00:00:00");
        const wd = d.getDay(); // 0 dom, 6 sáb
        return wd === 0 || wd === 6;
      } catch {
        return false;
      }
    }


    function rosterNextDate(dateIso) {
      const d = new Date(dateIso + "T00:00:00");
      d.setDate(d.getDate() + 1);
      return rosterIsoDate(d);
    }

    function rosterSafeInt(v, defVal) {
      const n = Number(v);
      if (!Number.isFinite(n)) return defVal;
      const i = Math.floor(n);
      if (i < 0) return defVal;
      return i;
    }

    function rosterTrim(s, maxLen) {
      const t = (typeof s === "string" ? s : "").trim();
      if (!t) return "";
      return t.length > maxLen ? t.slice(0, maxLen) : t;
    }

    function rosterParseOffDates(raw) {
      const s = String(raw || "").trim();
      if (!s) return [];
      const parts = s.split(",").map(x => x.trim()).filter(Boolean);
      const out = [];
      for (const p of parts) {
        if (!/^\d{4}-\d{2}-\d{2}$/.test(p)) continue;
        out.push(p);
        if (out.length >= 120) break;
      }
      return out;
    }

    function rosterNewMember() {
      return {
        id: "mem_" + Math.random().toString(16).slice(2),
        name: "",
        preference: "any", // day | night | any
        canNight: true,
        offDates: [],
        maxShifts: ""
      };
    }

    function rosterValidatedTeam() {
      const clean = [];
      const seen = new Set();
      for (const m of (Array.isArray(rosterTeam) ? rosterTeam : [])) {
        const name = rosterTrim(m?.name || "", 90);
        if (!name) continue;
        const key = name.toLowerCase();
        if (seen.has(key)) continue;
        seen.add(key);

        const preference = (m?.preference === "day" || m?.preference === "night") ? m.preference : "any";
        const canNight = preference === "night" ? true : !!m?.canNight;
        const offDates = rosterParseOffDates((Array.isArray(m?.offDates) ? m.offDates.join(",") : String(m?.offDates || "")));

        let maxShifts = String(m?.maxShifts || "").trim();
        if (maxShifts === "") maxShifts = "";
        else {
          const n = rosterSafeInt(maxShifts, 0);
          maxShifts = n > 0 ? String(Math.min(80, n)) : "";
        }

        clean.push({ id: m?.id || ("mem_" + Math.random().toString(16).slice(2)), name, preference, canNight, offDates, maxShifts });
        if (clean.length >= 200) break;
      }
      return clean;
    }

    function rosterCanDoShift(member, shiftKind, shiftModel) {
      if (!member) return false;
      if (shiftModel === "12x36") {
        if (shiftKind === "night") {
          if (member.preference === "day") return false;
          return !!member.canNight;
        }
        if (shiftKind === "day") {
          if (member.preference === "night") return false;
          return true;
        }
      }
      if (shiftModel === "mtn") {
        if (shiftKind === "night") {
          if (member.preference === "day") return false;
          return !!member.canNight;
        }
        if (shiftKind === "morning" || shiftKind === "afternoon") {
          if (member.preference === "night") return false;
          return true;
        }
      }
      // 18x36 e 24x48: não usa preferência; apenas respeita folga e limite mensal.
      return true;
    }

    function rosterReadSettings() {
      const month = rosterTrim(rosterMonthEl?.value || "", 7);
      const shiftModel = rosterTrim(rosterShiftModelEl?.value || "12x36", 20);
      const startTime = rosterTrim(rosterStartTimeEl?.value || "07:00", 5);

      const needPerShift = Math.max(1, rosterSafeInt(rosterNeedPerShiftEl?.value, 1));
      const needDay = Math.max(1, rosterSafeInt(rosterNeedDayEl?.value, 1));
      const needNight = Math.max(1, rosterSafeInt(rosterNeedNightEl?.value, 1));
      const needAfternoon = Math.max(0, rosterSafeInt(rosterNeedAfternoonEl?.value, 1));
      const maxConsecNights = Math.max(1, rosterSafeInt(rosterMaxConsecNightsEl?.value, 2));

      return { month, shiftModel, startTime, needPerShift, needDay, needNight, needAfternoon, maxConsecNights };
    }

    function rosterModelMinStaff(settings) {
      const s = settings || rosterReadSettings();
      if (s.shiftModel === "12x36") {
        const min = 2 * (Math.max(1, s.needDay) + Math.max(1, s.needNight));
        return { min, recommended: Math.ceil(min * 1.15) };
      }
      if (s.shiftModel === "24x48") {
        const min = 3 * Math.max(1, s.needPerShift);
        return { min, recommended: Math.ceil(min * 1.15) };
      }
      if (s.shiftModel === "18x36") {
        const min = 3 * Math.max(1, s.needPerShift);
        return { min, recommended: Math.ceil(min * 1.15) };
      }
      return { min: 0, recommended: 0 };
    }

    function rosterUpdateCoverageUI() {
      if (!rosterCoverageBox) return;
      const s = rosterReadSettings();
      const team = rosterValidatedTeam();

      const calc = rosterModelMinStaff(s);
      const modelName = (s.shiftModel === "12x36") ? "12x36" :
                        (s.shiftModel === "18x36") ? "18x36" :
                        (s.shiftModel === "24x48") ? "24x48" :
                        "Manhã/Tarde/Noite";

      const startTxt = String(s.startTime || "07:00");
      const teamCount = team.length;

      let lines = [];
      lines.push(`<div><strong>Resumo automático</strong></div>`);
      lines.push(`<div>Modelo: ${escapeHtml(modelName)}. Início do ciclo: ${escapeHtml(startTxt)}.</div>`);

      if (s.shiftModel === "12x36") {
        lines.push(`<div>Necessidade informada: 07:00–19:00 = ${Math.max(1, s.needDay)} pessoa(s); 19:00–07:00 = ${Math.max(1, s.needNight)} pessoa(s).</div>`);
      } else if (s.shiftModel === "18x36" || s.shiftModel === "24x48") {
        lines.push(`<div>Necessidade informada: ${Math.max(1, s.needPerShift)} pessoa(s) por plantão.</div>`);
      } else {
        lines.push(`<div>Necessidade informada: Manhã = ${Math.max(1, s.needDay)}; Tarde = ${Math.max(0, s.needAfternoon)}; Noite = ${Math.max(1, s.needNight)}.</div>`);
      }

      if (calc.min > 0) {
        const status = (teamCount >= calc.min) ? "Equipe suficiente para gerar (mínimo atingido)." :
                      (teamCount >= calc.recommended) ? "Equipe suficiente (com reserva)." :
                      "Equipe abaixo do mínimo: o sistema vai precisar relaxar regras ou ficará com vagas.";
        const status2 = (teamCount >= calc.recommended) ? "Boa folga para cobrir folgas, licenças e imprevistos." :
                       (teamCount >= calc.min) ? "Sugestão: aumentar equipe ou reduzir necessidade por plantão se houver muitos avisos." :
                       "Sugestão: aumentar equipe cadastrada ou reduzir a necessidade por plantão.";

        lines.push(`
          <div class="roster-coverage-grid">
            <div class="roster-coverage-item"><strong>Mínimo estimado</strong><div>${calc.min} colaborador(es)</div></div>
            <div class="roster-coverage-item"><strong>Recomendado (com reserva 15%)</strong><div>${calc.recommended} colaborador(es)</div></div>
            <div class="roster-coverage-item"><strong>Equipe cadastrada</strong><div>${teamCount} colaborador(es)</div></div>
            <div class="roster-coverage-item"><strong>Status</strong><div>${escapeHtml(status)}</div><div style="margin-top:6px;">${escapeHtml(status2)}</div></div>
          </div>
        `);
      } else {
        lines.push(`<div style="margin-top:8px;">Para Manhã/Tarde/Noite, o mínimo depende do tempo de jornada adotado na unidade. Cadastre a equipe e gere para validar se fecha sem avisos.</div>`);
      }

      rosterCoverageBox.innerHTML = lines.join("");
    }

    function rosterUpdateModelUI() {
      const s = rosterReadSettings();

      const is12 = s.shiftModel === "12x36";
      const is18 = s.shiftModel === "18x36";
      const is24 = s.shiftModel === "24x48";
      const isMTN = s.shiftModel === "mtn";

      if (rosterNeedPerShiftWrap) rosterNeedPerShiftWrap.style.display = (is18 || is24) ? "" : "none";
      if (rosterNeedDayWrap) rosterNeedDayWrap.style.display = (is12 || isMTN) ? "" : "none";
      if (rosterNeedNightWrap) rosterNeedNightWrap.style.display = (is12 || isMTN) ? "" : "none";
      if (rosterNeedAfternoonWrap) rosterNeedAfternoonWrap.style.display = (isMTN) ? "" : "none";
      if (rosterMaxConsecNightsWrap) rosterMaxConsecNightsWrap.style.display = (is12 || isMTN) ? "" : "none";

      if (rosterModelNote) {
        if (is12) {
          rosterModelNote.textContent =
            (s.startTime === "19:00")
              ? "No 12x36, cada linha é um ciclo iniciado às 19:00: primeiro plantão 19:00–07:00 e depois 07:00–19:00 do dia seguinte."
              : "No 12x36, cada linha é um ciclo iniciado às 07:00: primeiro plantão 07:00–19:00 e depois 19:00–07:00.";
        } else if (is24) {
          rosterModelNote.textContent = "No 24x48, a escala é uma sequência de plantões de 24 horas. O sistema rotaciona automaticamente para respeitar o descanso de 48 horas, usando rodízio em 3 equipes por posto.";
        } else if (is18) {
          rosterModelNote.textContent = "No 18x36, a escala é uma sequência de plantões de 18 horas. O sistema rotaciona automaticamente para respeitar o descanso de 36 horas, usando rodízio em 3 equipes por posto.";
        } else {
          rosterModelNote.textContent = "No modelo Manhã/Tarde/Noite, a escala é por dia. Informe quantas pessoas precisa em cada turno e gere para validar.";
        }
      }

      rosterRenderTeam();
      rosterUpdateCoverageUI();
    }

    function rosterRenderTeam() {
      const s = rosterReadSettings();
      const is12 = s.shiftModel === "12x36";
      const isMTN = s.shiftModel === "mtn";
      const showNightControls = (is12 || isMTN);

      if (rosterTeamTbody) rosterTeamTbody.innerHTML = "";
      if (rosterTeamCards) rosterTeamCards.innerHTML = "";

      rosterTeam.forEach((m, idx) => {
        // Desktop row
        if (rosterTeamTbody) {
          const tr = document.createElement("tr");

          const tdName = document.createElement("td");
          const inpName = document.createElement("input");
          inpName.className = "roster-mini-input";
          inpName.value = m.name || "";
          inpName.placeholder = "Nome";
          inpName.addEventListener("input", () => { m.name = rosterTrim(inpName.value, 90); rosterUpdateCoverageUI(); });
          tdName.appendChild(inpName);

          const tdPref = document.createElement("td");
          const selPref = document.createElement("select");
          selPref.className = "roster-mini-input";
          selPref.innerHTML = `
            <option value="any">Indiferente</option>
            <option value="day">Somente dia</option>
            <option value="night">Somente noite</option>
          `;
          selPref.value = m.preference || "any";
          selPref.disabled = !showNightControls;
          selPref.addEventListener("change", () => {
            m.preference = String(selPref.value || "any");
            if (m.preference === "night") m.canNight = true;
            rosterRenderTeam();
          });
          tdPref.appendChild(selPref);

          const tdCanNight = document.createElement("td");
          const selNight = document.createElement("select");
          selNight.className = "roster-mini-input";
          selNight.innerHTML = `<option value="yes">Sim</option><option value="no">Não</option>`;
          selNight.value = m.canNight ? "yes" : "no";
          selNight.disabled = (!showNightControls) || (m.preference === "night");
          selNight.addEventListener("change", () => { m.canNight = (selNight.value === "yes"); });
          tdCanNight.appendChild(selNight);

          const tdOff = document.createElement("td");
          const inpOff = document.createElement("input");
          inpOff.className = "roster-mini-input";
          inpOff.placeholder = "2026-01-05, 2026-01-20";
          inpOff.value = (Array.isArray(m.offDates) ? m.offDates.join(", ") : "");
          inpOff.addEventListener("input", () => { m.offDates = rosterParseOffDates(inpOff.value); });
          tdOff.appendChild(inpOff);

          const tdMax = document.createElement("td");
          const inpMax = document.createElement("input");
          inpMax.className = "roster-mini-input";
          inpMax.type = "number";
          inpMax.min = "0";
          inpMax.max = "80";
          inpMax.placeholder = "Opcional";
          inpMax.value = String(m.maxShifts || "");
          inpMax.addEventListener("input", () => { m.maxShifts = rosterTrim(inpMax.value, 3); });
          tdMax.appendChild(inpMax);

          const tdRm = document.createElement("td");
          const rmBtn = document.createElement("button");
          rmBtn.type = "button";
          rmBtn.className = "secondary";
          rmBtn.textContent = "Remover";
          rmBtn.addEventListener("click", () => { rosterTeam.splice(idx, 1); rosterRenderTeam(); rosterUpdateCoverageUI(); });
          tdRm.appendChild(rmBtn);

          tr.appendChild(tdName);
          tr.appendChild(tdPref);
          tr.appendChild(tdCanNight);
          tr.appendChild(tdOff);
          tr.appendChild(tdMax);
          tr.appendChild(tdRm);

          rosterTeamTbody.appendChild(tr);
        }

        // Mobile card
        if (rosterTeamCards) {
          const card = document.createElement("div");
          card.className = "roster-team-card";

          const title = document.createElement("div");
          title.className = "roster-team-card-title";
          title.textContent = `Colaborador ${idx + 1}`;
          card.appendChild(title);

          const grid = document.createElement("div");
          grid.className = "roster-team-card-grid";

          const mkField = (labelTxt, el) => {
            const wrap = document.createElement("div");
            wrap.className = "roster-field";
            const lab = document.createElement("label");
            lab.textContent = labelTxt;
            wrap.appendChild(lab);
            wrap.appendChild(el);
            return wrap;
          };

          const inpName2 = document.createElement("input");
          inpName2.value = m.name || "";
          inpName2.placeholder = "Nome";
          inpName2.addEventListener("input", () => { m.name = rosterTrim(inpName2.value, 90); rosterUpdateCoverageUI(); });
          grid.appendChild(mkField("Nome", inpName2));

          if (showNightControls) {
            const selPref2 = document.createElement("select");
            selPref2.innerHTML = `<option value="any">Indiferente</option><option value="day">Somente dia</option><option value="night">Somente noite</option>`;
            selPref2.value = m.preference || "any";
            selPref2.addEventListener("change", () => { m.preference = String(selPref2.value || "any"); if (m.preference === "night") m.canNight = true; rosterRenderTeam(); });
            grid.appendChild(mkField("Preferência", selPref2));

            const selNight2 = document.createElement("select");
            selNight2.innerHTML = `<option value="yes">Sim</option><option value="no">Não</option>`;
            selNight2.value = m.canNight ? "yes" : "no";
            selNight2.disabled = (m.preference === "night");
            selNight2.addEventListener("change", () => { m.canNight = (selNight2.value === "yes"); });
            grid.appendChild(mkField("Pode noite", selNight2));
          }

          const inpOff2 = document.createElement("input");
          inpOff2.placeholder = "2026-01-05, 2026-01-20";
          inpOff2.value = (Array.isArray(m.offDates) ? m.offDates.join(", ") : "");
          inpOff2.addEventListener("input", () => { m.offDates = rosterParseOffDates(inpOff2.value); });
          grid.appendChild(mkField("Folgas (datas)", inpOff2));

          const inpMax2 = document.createElement("input");
          inpMax2.type = "number";
          inpMax2.min = "0";
          inpMax2.max = "80";
          inpMax2.placeholder = "Opcional";
          inpMax2.value = String(m.maxShifts || "");
          inpMax2.addEventListener("input", () => { m.maxShifts = rosterTrim(inpMax2.value, 3); });
          grid.appendChild(mkField("Máx plantões/mês", inpMax2));

          card.appendChild(grid);

          const actions = document.createElement("div");
          actions.className = "roster-team-card-actions";
          const rm2 = document.createElement("button");
          rm2.type = "button";
          rm2.className = "danger";
          rm2.textContent = "Remover";
          rm2.addEventListener("click", () => { rosterTeam.splice(idx, 1); rosterRenderTeam(); rosterUpdateCoverageUI(); });
          actions.appendChild(rm2);
          card.appendChild(actions);

          rosterTeamCards.appendChild(card);
        }
      });
    }

    function rosterBulkAdd() {
      const raw = prompt(
        "Cole uma lista (1 por linha). Formatos aceitos:\n" +
        "1) Nome\n" +
        "2) Nome;preferencia(day|night|any);podeNoite(yes|no);folgas(AAAA-MM-DD, ...);max\n\n" +
        "Exemplo:\nMaria;day;yes;2026-01-05,2026-01-20;14\n\n" +
        "Dica: se você estiver usando 24x48 ou 18x36, pode colar apenas os nomes."
      );
      if (!raw) return;

      const lines = String(raw).split("\n").map(l => l.trim()).filter(Boolean);
      const added = [];
      for (const line of lines) {
        const parts = line.split(";").map(x => x.trim());
        const name = rosterTrim(parts[0] || "", 90);
        if (!name) continue;

        const prefRaw = String(parts[1] || "any").toLowerCase();
        const preference = (prefRaw === "day" || prefRaw === "night" || prefRaw === "any") ? prefRaw : "any";

        const canNightRaw = String(parts[2] || "yes").toLowerCase();
        const canNight = (preference === "night") ? true : (canNightRaw !== "no");

        const offDates = rosterParseOffDates(parts[3] || "");
        let maxShifts = String(parts[4] || "").trim();
        if (maxShifts !== "") {
          const n = rosterSafeInt(maxShifts, 0);
          maxShifts = n > 0 ? String(Math.min(80, n)) : "";
        }

        added.push({ id: "mem_" + Math.random().toString(16).slice(2), name, preference, canNight, offDates, maxShifts });
      }

      if (!added.length) return;
      rosterTeam = rosterTeam.concat(added);
      rosterRenderTeam();
      rosterUpdateCoverageUI();
    }

    function rosterSetWarnBox(warnings) {
      if (!rosterWarnBox) return;
      const list = Array.isArray(warnings) ? warnings.filter(Boolean) : [];
      if (!list.length) {
        rosterWarnBox.classList.add("hidden");
        rosterWarnBox.textContent = "";
        return;
      }
      rosterWarnBox.classList.remove("hidden");
      rosterWarnBox.textContent = list.join("\n");
    }

    function rosterRenderOutput(result) {
      rosterSetWarnBox(result?.warnings || []);

      if (!result) {
        rosterOutput?.classList.add("hidden");
        if (rosterTableOut) rosterTableOut.innerHTML = "";
        if (rosterSummaryOut) rosterSummaryOut.innerHTML = "";
        if (rosterOutputMobile) rosterOutputMobile.innerHTML = "";
        rosterSaveScheduleBtn.disabled = true;
        rosterExportCsvBtn.disabled = true;
        rosterPrintBtn.disabled = true;
        rosterLastGenerated = null;
        return;
      }

      // Desktop tables
      if (rosterTableOut) rosterTableOut.innerHTML = result.desktopTableHtml || "";
      if (rosterSummaryOut) rosterSummaryOut.innerHTML = result.summaryTableHtml || "";

      // Mobile cards
      if (rosterOutputMobile) rosterOutputMobile.innerHTML = result.mobileCardsHtml || "";

      rosterOutput?.classList.remove("hidden");

      rosterLastGenerated = {
        month: result.month,
        shiftModel: result.shiftModel,
        startTime: result.startTime,
        rows: result.rows,
        summary: result.summary,
        warnings: result.warnings,
        csv: result.csv,
        printableTitle: result.printableTitle || (`Escala ${result.month}`)
      };

      rosterSaveScheduleBtn.disabled = false;
      rosterExportCsvBtn.disabled = false;
      rosterPrintBtn.disabled = false;
    }

    function rosterGenerateDayNight(yyyyMM, needDay, needNight, maxConsecNights) {
      const days = rosterDaysInMonth(yyyyMM);
      const team = rosterValidatedTeam();
      if (!days.length) return { ok: false, error: "Selecione um mês válido." };
      if (team.length < 1) return { ok: false, error: "Cadastre pelo menos 1 pessoa." };

      const needByShift = { day: Math.max(1, needDay), night: Math.max(1, needNight) };

      const counts = {};
      const nightStreak = {};
      const warnings = [];
      const rowsByDate = {};

      for (const m of team) {
        counts[m.id] = { total: 0, day: 0, night: 0, weekend: 0 };
        nightStreak[m.id] = 0;
      }

      const lastDateAssigned = {}; // memberId -> last dateIso (independente do tipo)

      function hitMonthlyLimit(member) {
        const maxShifts = member.maxShifts ? rosterSafeInt(member.maxShifts, 0) : 0;
        if (maxShifts > 0 && counts[member.id].total >= maxShifts) return true;
        return false;
      }

      function hasConsecutiveDay(member, dateIso) {
        const last = lastDateAssigned[member.id];
        if (!last) return false;
        return (dateIso === rosterNextDate(last)) || (last === rosterNextDate(dateIso));
      }

      function eligible(member, dateIso, kind, excludeIds) {
        if (!member) return false;
        if (excludeIds && excludeIds.has(member.id)) return false;

        if (!rosterCanDoShift(member, kind, "12x36")) return false;
        if (Array.isArray(member.offDates) && member.offDates.includes(dateIso)) return false;
        if (hitMonthlyLimit(member)) return false;

        // regra conservadora: evita plantões em dias consecutivos no 12x36
        if (hasConsecutiveDay(member, dateIso)) return false;

        if (kind === "night" && nightStreak[member.id] >= maxConsecNights) return false;

        return true;
      }

      function pick(dateIso, kind, excludeIds) {
        const pool = team.slice().filter(m => eligible(m, dateIso, kind, excludeIds));
        pool.sort((a, b) => {
          const ca = counts[a.id];
          const cb = counts[b.id];
          if (ca.total !== cb.total) return ca.total - cb.total;

          if (kind === "night") {
            if (ca.night !== cb.night) return ca.night - cb.night;
          } else {
            if (ca.day !== cb.day) return ca.day - cb.day;
          }
          return String(a.name || "").localeCompare(String(b.name || ""));
        });
        return pool[0] || null;
      }

      function pickRelaxed(dateIso, kind, excludeIds) {
        const pool = team.slice().filter(m => {
          if (!m) return false;
          if (excludeIds && excludeIds.has(m.id)) return false;
          if (!rosterCanDoShift(m, kind, "12x36")) return false;
          if (Array.isArray(m.offDates) && m.offDates.includes(dateIso)) return false;
          if (hitMonthlyLimit(m)) return false;
          return true;
        });
        pool.sort((a, b) => (counts[a.id].total - counts[b.id].total) || String(a.name || "").localeCompare(String(b.name || "")));
        return pool[0] || null;
      }

      for (const dateIso of days) {
        const usedDay = new Set();
        const usedNight = new Set();

        const dayAssigned = [];
        const nightAssigned = [];

        for (let i = 0; i < needByShift.day; i++) {
          let mem = pick(dateIso, "day", usedDay);
          if (!mem) {
            warnings.push(`${dateIso}: houve relaxamento de regras para completar 07:00–19:00.`);
            mem = pickRelaxed(dateIso, "day", usedDay);
          }
          if (!mem) break;

          usedDay.add(mem.id);
          dayAssigned.push(mem.name);

          counts[mem.id].total += 1;
          counts[mem.id].day += 1;
          if (rosterIsWeekend(dateIso)) counts[mem.id].weekend += 1;

          nightStreak[mem.id] = 0;
          lastDateAssigned[mem.id] = dateIso;
        }

        for (let i = 0; i < needByShift.night; i++) {
          let mem = pick(dateIso, "night", usedNight);
          if (!mem) {
            warnings.push(`${dateIso}: houve relaxamento de regras para completar 19:00–07:00.`);
            mem = pickRelaxed(dateIso, "night", usedNight);
          }
          if (!mem) break;

          usedNight.add(mem.id);
          nightAssigned.push(mem.name);

          counts[mem.id].total += 1;
          counts[mem.id].night += 1;
          if (rosterIsWeekend(dateIso)) counts[mem.id].weekend += 1;

          nightStreak[mem.id] = (nightStreak[mem.id] || 0) + 1;
          lastDateAssigned[mem.id] = dateIso;
        }

        rowsByDate[dateIso] = { date: dateIso, day: dayAssigned, night: nightAssigned };
      }

      const summary = team.map(m => ({
        name: m.name,
        total: counts[m.id].total,
        day: counts[m.id].day,
        night: counts[m.id].night,
        weekend: counts[m.id].weekend
      })).sort((a, b) => b.total - a.total || a.name.localeCompare(b.name));

      return { ok: true, month: yyyyMM, days, rowsByDate, summary, warnings };
    }

    function rosterGenerateMTN(yyyyMM, needMorning, needAfternoon, needNight, maxConsecNights) {
      const days = rosterDaysInMonth(yyyyMM);
      const team = rosterValidatedTeam();
      if (!days.length) return { ok: false, error: "Selecione um mês válido." };
      if (team.length < 1) return { ok: false, error: "Cadastre pelo menos 1 pessoa." };

      const needByShift = { morning: Math.max(1, needMorning), afternoon: Math.max(0, needAfternoon), night: Math.max(1, needNight) };

      const counts = {};
      const nightStreak = {};
      const warnings = [];
      const rows = [];

      for (const m of team) {
        counts[m.id] = { total: 0, morning: 0, afternoon: 0, night: 0, weekend: 0 };
        nightStreak[m.id] = 0;
      }

      function hitMonthlyLimit(member) {
        const maxShifts = member.maxShifts ? rosterSafeInt(member.maxShifts, 0) : 0;
        if (maxShifts > 0 && counts[member.id].total >= maxShifts) return true;
        return false;
      }

      function eligible(member, dateIso, kind, excludeIds) {
        if (!member) return false;
        if (excludeIds && excludeIds.has(member.id)) return false;

        if (!rosterCanDoShift(member, kind, "mtn")) return false;
        if (Array.isArray(member.offDates) && member.offDates.includes(dateIso)) return false;
        if (hitMonthlyLimit(member)) return false;

        if (kind === "night" && nightStreak[member.id] >= maxConsecNights) return false;
        return true;
      }

      function pick(dateIso, kind, excludeIds) {
        const pool = team.slice().filter(m => eligible(m, dateIso, kind, excludeIds));
        pool.sort((a, b) => {
          const ca = counts[a.id];
          const cb = counts[b.id];
          if (ca.total !== cb.total) return ca.total - cb.total;
          return String(a.name || "").localeCompare(String(b.name || ""));
        });
        return pool[0] || null;
      }

      function pickRelaxed(dateIso, kind, excludeIds) {
        const pool = team.slice().filter(m => {
          if (!m) return false;
          if (excludeIds && excludeIds.has(m.id)) return false;
          if (!rosterCanDoShift(m, kind, "mtn")) return false;
          if (Array.isArray(m.offDates) && m.offDates.includes(dateIso)) return false;
          if (hitMonthlyLimit(m)) return false;
          return true;
        });
        pool.sort((a, b) => (counts[a.id].total - counts[b.id].total) || String(a.name || "").localeCompare(String(b.name || "")));
        return pool[0] || null;
      }

      for (const dateIso of days) {
        const usedMorning = new Set();
        const usedAfternoon = new Set();
        const usedNight = new Set();

        const row = { date: dateIso, morning: [], afternoon: [], night: [] };

        for (let i = 0; i < needByShift.morning; i++) {
          let mem = pick(dateIso, "morning", usedMorning);
          if (!mem) {
            warnings.push(`${dateIso}: houve relaxamento de regras para completar manhã.`);
            mem = pickRelaxed(dateIso, "morning", usedMorning);
          }
          if (!mem) break;

          usedMorning.add(mem.id);
          row.morning.push(mem.name);

          counts[mem.id].total += 1;
          counts[mem.id].morning += 1;
          if (rosterIsWeekend(dateIso)) counts[mem.id].weekend += 1;
          nightStreak[mem.id] = 0;
        }

        for (let i = 0; i < needByShift.afternoon; i++) {
          let mem = pick(dateIso, "afternoon", usedAfternoon);
          if (!mem) {
            warnings.push(`${dateIso}: houve relaxamento de regras para completar tarde.`);
            mem = pickRelaxed(dateIso, "afternoon", usedAfternoon);
          }
          if (!mem) break;

          usedAfternoon.add(mem.id);
          row.afternoon.push(mem.name);

          counts[mem.id].total += 1;
          counts[mem.id].afternoon += 1;
          if (rosterIsWeekend(dateIso)) counts[mem.id].weekend += 1;
          nightStreak[mem.id] = 0;
        }

        for (let i = 0; i < needByShift.night; i++) {
          let mem = pick(dateIso, "night", usedNight);
          if (!mem) {
            warnings.push(`${dateIso}: houve relaxamento de regras para completar noite.`);
            mem = pickRelaxed(dateIso, "night", usedNight);
          }
          if (!mem) break;

          usedNight.add(mem.id);
          row.night.push(mem.name);

          counts[mem.id].total += 1;
          counts[mem.id].night += 1;
          if (rosterIsWeekend(dateIso)) counts[mem.id].weekend += 1;
          nightStreak[mem.id] = (nightStreak[mem.id] || 0) + 1;
        }

        rows.push(row);
      }

      const summary = team.map(m => ({
        name: m.name,
        total: counts[m.id].total,
        morning: counts[m.id].morning,
        afternoon: counts[m.id].afternoon,
        night: counts[m.id].night,
        weekend: counts[m.id].weekend
      })).sort((a, b) => b.total - a.total || a.name.localeCompare(b.name));

      return { ok: true, month: yyyyMM, rows, summary, warnings };
    }

    function rosterFormatDateTime(d) {
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const dd = String(d.getDate()).padStart(2, "0");
      const hh = String(d.getHours()).padStart(2, "0");
      const mi = String(d.getMinutes()).padStart(2, "0");
      return `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
    }

    function rosterGenerateContinuous(yyyyMM, startTime, shiftHours, restHours, needPerShift) {
      const team = rosterValidatedTeam();
      if (!team.length) return { ok: false, error: "Cadastre pelo menos 1 pessoa." };

      const m = /^\d{4}-\d{2}$/.test(yyyyMM || "") ? yyyyMM : "";
      if (!m) return { ok: false, error: "Selecione um mês válido." };

      const [yStr, moStr] = m.split("-");
      const y = Number(yStr), mo = Number(moStr);
      const monthStart = new Date(y, mo - 1, 1, 0, 0, 0);
      const monthEnd = new Date(y, mo, 1, 0, 0, 0);

      const [hhStr, mmStr] = String(startTime || "07:00").split(":");
      const startH = rosterSafeInt(hhStr, 7);
      const startM = rosterSafeInt(mmStr, 0);

      // Passo entre inícios: igual ao tempo de trabalho (para cobrir continuamente).
      const stepHours = shiftHours;
      let cursor = new Date(y, mo - 1, 1, startH, startM, 0);

      // Ajuste para pegar o último início antes (ou igual) ao início do mês, para não deixar buracos na virada do mês.
      while (cursor > monthStart) {
        cursor = new Date(cursor.getTime() - stepHours * 3600 * 1000);
      }

      const shifts = [];
      for (let guard = 0; guard < 2000; guard++) {
        const start = new Date(cursor.getTime());
        const end = new Date(start.getTime() + shiftHours * 3600 * 1000);
        const overlaps = (start < monthEnd) && (end > monthStart);
        if (overlaps) shifts.push({ start, end });
        cursor = new Date(cursor.getTime() + stepHours * 3600 * 1000);
        if (start >= monthEnd) break;
        if (cursor > new Date(monthEnd.getTime() + 10 * 24 * 3600 * 1000)) break;
      }

      const warnings = [];
      const need = Math.max(1, rosterSafeInt(needPerShift, 1));

      const teamsPerSlot = 3; // 18x36 e 24x48
      const minNeeded = teamsPerSlot * need;
      if (team.length < minNeeded) {
        warnings.push(`Equipe cadastrada (${team.length}) abaixo do mínimo estimado (${minNeeded}) para ${need} posto(s). O sistema pode preencher com repetição e avisos.`);
      }

      // grupos por posto
      const groups = [];
      const pool = team.slice();
      for (let slot = 0; slot < need; slot++) {
        groups.push(pool.slice(slot * teamsPerSlot, slot * teamsPerSlot + teamsPerSlot));
      }

      // contadores
      const counts = {};
      const lastEnd = {};
      for (const m of team) { counts[m.id] = 0; lastEnd[m.id] = null; }

      function canAssign(member, shiftStartDateIso, shiftStartTs) {
        if (!member) return false;
        // folga (considera data de início)
        if (Array.isArray(member.offDates) && member.offDates.includes(shiftStartDateIso)) return false;

        // limite mensal
        const maxShifts = member.maxShifts ? rosterSafeInt(member.maxShifts, 0) : 0;
        if (maxShifts > 0 && counts[member.id] >= maxShifts) return false;

        // descanso mínimo (conservador)
        const le = lastEnd[member.id];
        if (le && typeof le === "number") {
          const minRestMs = restHours * 3600 * 1000;
          if (shiftStartTs < le + minRestMs) return false;
        }
        return true;
      }

      function pickFallback(shiftStartDateIso, shiftStartTs) {
        const sorted = team.slice().sort((a, b) => (counts[a.id] - counts[b.id]) || String(a.name).localeCompare(String(b.name)));
        for (const cand of sorted) {
          if (canAssign(cand, shiftStartDateIso, shiftStartTs)) return cand;
        }
        return null;
      }

      const rows = [];

      for (let i = 0; i < shifts.length; i++) {
        const sh = shifts[i];
        const startIso = rosterIsoDate(sh.start);
        const startTs = sh.start.getTime();

        const assignedNames = [];

        for (let slot = 0; slot < need; slot++) {
          const group = groups[slot] || [];
          let chosen = null;

          // prioridade: rodízio dentro do grupo (A/B/C) para manter descanso
          const preferred = group.length ? group[i % teamsPerSlot] : null;
          if (preferred && canAssign(preferred, startIso, startTs)) chosen = preferred;

          if (!chosen && group.length) {
            for (const cand of group) {
              if (canAssign(cand, startIso, startTs)) { chosen = cand; break; }
            }
          }

          // fallback: pega da equipe geral
          if (!chosen) {
            chosen = pickFallback(startIso, startTs);
            if (chosen) warnings.push(`${rosterFormatDateTime(sh.start)}: houve relaxamento de regras (descanso/limites/folgas) para completar posto ${slot + 1}.`);
          }

          if (!chosen) {
            assignedNames.push("VAGO");
            warnings.push(`${rosterFormatDateTime(sh.start)}: não foi possível preencher posto ${slot + 1}.`);
            continue;
          }

          assignedNames.push(chosen.name);
          counts[chosen.id] += 1;
          lastEnd[chosen.id] = sh.end.getTime();
        }

        rows.push({
          start: rosterFormatDateTime(sh.start),
          end: rosterFormatDateTime(sh.end),
          people: assignedNames
        });
      }

      const summary = team.map(m => ({ name: m.name, total: counts[m.id] || 0 })).sort((a, b) => b.total - a.total || a.name.localeCompare(b.name));

      return { ok: true, month: yyyyMM, rows, summary, warnings };
    }

    function rosterBuildTablesAndCards(settings, result) {
      const s = settings;
      const model = s.shiftModel;
      const startTime = s.startTime;

      const warnings = Array.isArray(result.warnings) ? result.warnings : [];
      const month = result.month || s.month;

      const printableTitle = `Escala ${month} (${model})`;

      // Desktop table HTML (string de <thead>+<tbody> para inserir no <table>)
      let desktopTableHtml = "";
      let mobileCardsHtml = "";
      let csv = "";
      let rowsForSave = [];

      if (model === "12x36") {
        const days = result.days || rosterDaysInMonth(month);
        const map = result.rowsByDate || {};

        // Monta ciclos (B): cada linha inicia na hora escolhida
        const cycles = [];
        for (const d of days) {
          if (startTime === "19:00") {
            const night = (map[d]?.night || []);
            const d2 = rosterNextDate(d);
            const day2 = (map[d2]?.day || []);
            cycles.push({
              cycleStart: `${d} 19:00`,
              part1Label: "19:00–07:00",
              part1: night,
              part2Label: "07:00–19:00",
              part2: day2,
              note: (d2.startsWith(month)) ? "" : "2º plantão fora do mês"
            });
          } else {
            const day = (map[d]?.day || []);
            const night = (map[d]?.night || []);
            cycles.push({
              cycleStart: `${d} 07:00`,
              part1Label: "07:00–19:00",
              part1: day,
              part2Label: "19:00–07:00",
              part2: night,
              note: ""
            });
          }
        }

        const header = ["Início do ciclo", "Plantão 1", "Plantão 2"];
        desktopTableHtml += "<thead><tr>" + header.map(h => `<th>${escapeHtml(h)}</th>`).join("") + "</tr></thead><tbody>";
        for (const c of cycles) {
          const p1 = (c.part1 || []).join(" | ");
          const p2 = (c.part2 || []).join(" | ");
          desktopTableHtml += "<tr>" + [
            `<td>${escapeHtml(c.cycleStart)}${c.note ? `<div style="font-size:12px;color:#666;margin-top:4px;">${escapeHtml(c.note)}</div>` : ""}</td>`,
            `<td><span class="roster-pill">${escapeHtml(c.part1Label)}</span>${escapeHtml(p1)}</td>`,
            `<td><span class="roster-pill">${escapeHtml(c.part2Label)}</span>${escapeHtml(p2)}</td>`
          ].join("") + "</tr>";

          mobileCardsHtml += `
            <div class="roster-out-card">
              <div class="roster-out-card-title">${escapeHtml(c.cycleStart)}</div>
              ${c.note ? `<div class="roster-out-card-line" style="font-size:12px;color:#666;">${escapeHtml(c.note)}</div>` : ""}
              <div class="roster-out-card-line"><span class="roster-pill">${escapeHtml(c.part1Label)}</span>${escapeHtml(p1 || "")}</div>
              <div class="roster-out-card-line"><span class="roster-pill">${escapeHtml(c.part2Label)}</span>${escapeHtml(p2 || "")}</div>
            </div>
          `;

          rowsForSave.push({ cycleStart: c.cycleStart, part1Label: c.part1Label, part1: c.part1, part2Label: c.part2Label, part2: c.part2, note: c.note });
        }
        desktopTableHtml += "</tbody>";

        const sumHeader = ["Nome", "Total", "Dia", "Noite", "Finais de semana"];
        let summaryTableHtml = "<thead><tr>" + sumHeader.map(h => `<th>${escapeHtml(h)}</th>`).join("") + "</tr></thead><tbody>";
        for (const r of (result.summary || [])) {
          summaryTableHtml += "<tr>" + [
            `<td>${escapeHtml(r.name || "")}</td>`,
            `<td>${r.total || 0}</td>`,
            `<td>${r.day || 0}</td>`,
            `<td>${r.night || 0}</td>`,
            `<td>${r.weekend || 0}</td>`
          ].join("") + "</tr>";
        }
        summaryTableHtml += "</tbody>";

        // CSV
        const csvLines = [];
        csvLines.push(header.join(";"));
        for (const c of cycles) {
          csvLines.push([c.cycleStart, (c.part1 || []).join(" | "), (c.part2 || []).join(" | ")].join(";"));
        }
        csv = csvLines.join("\n");

        return { month, printableTitle, desktopTableHtml, summaryTableHtml, mobileCardsHtml, csv, rows: rowsForSave, summary: result.summary || [], warnings };
      }

      if (model === "mtn") {
        const header = ["Data", "Manhã", "Tarde", "Noite"];
        desktopTableHtml += "<thead><tr>" + header.map(h => `<th>${escapeHtml(h)}</th>`).join("") + "</tr></thead><tbody>";
        for (const row of (result.rows || [])) {
          const m = (row.morning || []).join(" | ");
          const a = (row.afternoon || []).join(" | ");
          const n = (row.night || []).join(" | ");
          desktopTableHtml += "<tr>" + [
            `<td>${escapeHtml(row.date || "")}</td>`,
            `<td>${escapeHtml(m)}</td>`,
            `<td>${escapeHtml(a)}</td>`,
            `<td>${escapeHtml(n)}</td>`
          ].join("") + "</tr>";

          mobileCardsHtml += `
            <div class="roster-out-card">
              <div class="roster-out-card-title">${escapeHtml(row.date || "")}</div>
              <div class="roster-out-card-line"><span class="roster-pill">Manhã</span>${escapeHtml(m || "")}</div>
              <div class="roster-out-card-line"><span class="roster-pill">Tarde</span>${escapeHtml(a || "")}</div>
              <div class="roster-out-card-line"><span class="roster-pill">Noite</span>${escapeHtml(n || "")}</div>
            </div>
          `;
          rowsForSave.push({ date: row.date, morning: row.morning, afternoon: row.afternoon, night: row.night });
        }
        desktopTableHtml += "</tbody>";

        const sumHeader = ["Nome", "Total", "Manhã", "Tarde", "Noite", "Finais de semana"];
        let summaryTableHtml = "<thead><tr>" + sumHeader.map(h => `<th>${escapeHtml(h)}</th>`).join("") + "</tr></thead><tbody>";
        for (const r of (result.summary || [])) {
          summaryTableHtml += "<tr>" + [
            `<td>${escapeHtml(r.name || "")}</td>`,
            `<td>${r.total || 0}</td>`,
            `<td>${r.morning || 0}</td>`,
            `<td>${r.afternoon || 0}</td>`,
            `<td>${r.night || 0}</td>`,
            `<td>${r.weekend || 0}</td>`
          ].join("") + "</tr>";
        }
        summaryTableHtml += "</tbody>";

        // CSV
        const csvLines = [];
        csvLines.push(header.join(";"));
        for (const row of (result.rows || [])) {
          csvLines.push([row.date || "", (row.morning || []).join(" | "), (row.afternoon || []).join(" | "), (row.night || []).join(" | ")].join(";"));
        }
        csv = csvLines.join("\n");

        return { month, printableTitle, desktopTableHtml, summaryTableHtml, mobileCardsHtml, csv, rows: rowsForSave, summary: result.summary || [], warnings };
      }

      // 18x36 e 24x48
      const header = ["Início", "Fim", "Pessoas"];
      desktopTableHtml += "<thead><tr>" + header.map(h => `<th>${escapeHtml(h)}</th>`).join("") + "</tr></thead><tbody>";
      for (const row of (result.rows || [])) {
        const ppl = (row.people || []).join(" | ");
        desktopTableHtml += "<tr>" + [
          `<td>${escapeHtml(row.start || "")}</td>`,
          `<td>${escapeHtml(row.end || "")}</td>`,
          `<td>${escapeHtml(ppl)}</td>`
        ].join("") + "</tr>";

        mobileCardsHtml += `
          <div class="roster-out-card">
            <div class="roster-out-card-title">${escapeHtml(row.start || "")}</div>
            <div class="roster-out-card-line"><span class="roster-pill">Fim</span>${escapeHtml(row.end || "")}</div>
            <div class="roster-out-card-line"><span class="roster-pill">Equipe</span>${escapeHtml(ppl || "")}</div>
          </div>
        `;
        rowsForSave.push({ start: row.start, end: row.end, people: row.people });
      }
      desktopTableHtml += "</tbody>";

      const sumHeader = ["Nome", "Total"];
      let summaryTableHtml = "<thead><tr>" + sumHeader.map(h => `<th>${escapeHtml(h)}</th>`).join("") + "</tr></thead><tbody>";
      for (const r of (result.summary || [])) {
        summaryTableHtml += "<tr>" + [
          `<td>${escapeHtml(r.name || "")}</td>`,
          `<td>${r.total || 0}</td>`
        ].join("") + "</tr>";
      }
      summaryTableHtml += "</tbody>";

      const csvLines = [];
      csvLines.push(header.join(";"));
      for (const row of (result.rows || [])) {
        csvLines.push([row.start || "", row.end || "", (row.people || []).join(" | ")].join(";"));
      }
      csv = csvLines.join("\n");

      return { month, printableTitle, desktopTableHtml, summaryTableHtml, mobileCardsHtml, csv, rows: rowsForSave, summary: result.summary || [], warnings };
    }

    async function rosterSaveConfig() {
      const settings = rosterReadSettings();
      const team = rosterValidatedTeam();

      const payload = { config: { settings, team } };

      try {
        rosterSaveConfigBtn.disabled = true;
        const resp = await fetch(BACKEND_URL + "/api/escala/config", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) throw new Error(data?.error || "Falha ao salvar.");
        alert("Configuração da escala salva.");
      } catch (e) {
        alert(String(e?.message || e || "Falha ao salvar."));
      } finally {
        rosterSaveConfigBtn.disabled = false;
      }
    }

    async function rosterLoadConfig() {
      try {
        rosterLoadConfigBtn.disabled = true;
        const resp = await fetch(BACKEND_URL + "/api/escala/config", { method: "GET" });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) throw new Error(data?.error || "Falha ao carregar.");

        const cfg = data?.config || null;
        if (!cfg) {
          alert("Nenhuma configuração salva para este usuário.");
          return;
        }

        const settings = cfg.settings || {};
        const team = Array.isArray(cfg.team) ? cfg.team : [];

        if (rosterMonthEl && settings.month) rosterMonthEl.value = settings.month;
        if (rosterShiftModelEl && settings.shiftModel) rosterShiftModelEl.value = settings.shiftModel;
        if (rosterStartTimeEl && settings.startTime) rosterStartTimeEl.value = settings.startTime;

        if (rosterNeedPerShiftEl && Number.isFinite(Number(settings.needPerShift))) rosterNeedPerShiftEl.value = String(settings.needPerShift);
        if (rosterNeedDayEl && Number.isFinite(Number(settings.needDay))) rosterNeedDayEl.value = String(settings.needDay);
        if (rosterNeedNightEl && Number.isFinite(Number(settings.needNight))) rosterNeedNightEl.value = String(settings.needNight);
        if (rosterNeedAfternoonEl && Number.isFinite(Number(settings.needAfternoon))) rosterNeedAfternoonEl.value = String(settings.needAfternoon);
        if (rosterMaxConsecNightsEl && Number.isFinite(Number(settings.maxConsecNights))) rosterMaxConsecNightsEl.value = String(settings.maxConsecNights);

        rosterTeam = team.map(t => ({
          id: t.id || ("mem_" + Math.random().toString(16).slice(2)),
          name: rosterTrim(t.name || "", 90),
          preference: (t.preference === "day" || t.preference === "night") ? t.preference : "any",
          canNight: !!t.canNight,
          offDates: rosterParseOffDates(Array.isArray(t.offDates) ? t.offDates.join(",") : String(t.offDates || "")),
          maxShifts: (t.maxShifts === "" || t.maxShifts === null || typeof t.maxShifts === "undefined") ? "" : String(t.maxShifts)
        }));

        rosterUpdateModelUI();
        alert("Configuração carregada.");
      } catch (e) {
        alert(String(e?.message || e || "Falha ao carregar."));
      } finally {
        rosterLoadConfigBtn.disabled = false;
      }
    }

    async function rosterSaveSchedule() {
      if (!rosterLastGenerated || !rosterLastGenerated.month) return;

      const title = rosterLastGenerated.printableTitle || `Escala ${rosterLastGenerated.month}`;
      const payload = {
        title,
        month: rosterLastGenerated.month,
        shiftModel: rosterLastGenerated.shiftModel,
        data: {
          startTime: rosterLastGenerated.startTime,
          rows: rosterLastGenerated.rows
        },
        summary: rosterLastGenerated.summary,
        warnings: rosterLastGenerated.warnings
      };

      try {
        rosterSaveScheduleBtn.disabled = true;
        const resp = await fetch(BACKEND_URL + "/api/escala/schedules", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) throw new Error(data?.error || "Falha ao salvar escala.");
        alert("Escala salva no servidor.");
      } catch (e) {
        alert(String(e?.message || e || "Falha ao salvar escala."));
      } finally {
        rosterSaveScheduleBtn.disabled = false;
      }
    }

    function rosterDownloadCsv() {
      if (!rosterLastGenerated?.csv) return;
      const blob = new Blob([rosterLastGenerated.csv], { type: "text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `escala_${rosterLastGenerated.month}_${rosterLastGenerated.shiftModel}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }

    function rosterPrint() {
      if (!rosterLastGenerated) return;
      const title = rosterLastGenerated.printableTitle || `Escala ${rosterLastGenerated.month}`;
      const html = `
        <html><head><meta charset="utf-8"><title>${escapeHtml(title)}</title>
        <style>
          body{font-family: Arial, Helvetica, sans-serif; padding: 18px;}
          h1{font-size: 18px; margin: 0 0 12px 0;}
          table{border-collapse: collapse; width: 100%;}
          th,td{border: 1px solid #ccc; padding: 6px; font-size: 12px; vertical-align: top;}
          th{background: #f1f1f1;}
        </style>
        </head><body>
        <h1>${escapeHtml(title)}</h1>
        <table>${rosterTableOut?.innerHTML || ""}</table>
        <div style="height: 14px;"></div>
        <table>${rosterSummaryOut?.innerHTML || ""}</table>
        </body></html>
      `;
      const w = window.open("", "_blank");
      if (!w) {
        alert("Seu navegador bloqueou a janela de impressão.");
        return;
      }
      w.document.open();
      w.document.write(html);
      w.document.close();
      w.focus();
      setTimeout(() => { try { w.print(); } catch {} }, 350);
    }

    function rosterGenerateNow() {
      const s = rosterReadSettings();

      if (!s.month || !/^\d{4}-\d{2}$/.test(s.month)) {
        alert("Selecione um mês válido.");
        rosterRenderOutput(null);
        return;
      }

      const team = rosterValidatedTeam();
      if (!team.length) {
        alert("Cadastre pelo menos 1 pessoa.");
        rosterRenderOutput(null);
        return;
      }

      let gen = null;

      if (s.shiftModel === "12x36") {
        gen = rosterGenerateDayNight(s.month, s.needDay, s.needNight, s.maxConsecNights);
        if (!gen.ok) { alert(gen.error || "Falha ao gerar."); rosterRenderOutput(null); return; }
        const built = rosterBuildTablesAndCards(s, gen);
        rosterRenderOutput({ ...built, shiftModel: s.shiftModel, startTime: s.startTime, warnings: gen.warnings || [] });
        return;
      }

      if (s.shiftModel === "mtn") {
        gen = rosterGenerateMTN(s.month, s.needDay, s.needAfternoon, s.needNight, s.maxConsecNights);
        if (!gen.ok) { alert(gen.error || "Falha ao gerar."); rosterRenderOutput(null); return; }
        const built = rosterBuildTablesAndCards(s, gen);
        rosterRenderOutput({ ...built, shiftModel: s.shiftModel, startTime: s.startTime, warnings: gen.warnings || [] });
        return;
      }

      if (s.shiftModel === "24x48") {
        gen = rosterGenerateContinuous(s.month, s.startTime, 24, 48, s.needPerShift);
        if (!gen.ok) { alert(gen.error || "Falha ao gerar."); rosterRenderOutput(null); return; }
        const built = rosterBuildTablesAndCards(s, gen);
        rosterRenderOutput({ ...built, shiftModel: s.shiftModel, startTime: s.startTime, warnings: gen.warnings || [] });
        return;
      }

      if (s.shiftModel === "18x36") {
        gen = rosterGenerateContinuous(s.month, s.startTime, 18, 36, s.needPerShift);
        if (!gen.ok) { alert(gen.error || "Falha ao gerar."); rosterRenderOutput(null); return; }
        const built = rosterBuildTablesAndCards(s, gen);
        rosterRenderOutput({ ...built, shiftModel: s.shiftModel, startTime: s.startTime, warnings: gen.warnings || [] });
        return;
      }

      alert("Modelo inválido.");
      rosterRenderOutput(null);
    }

    function rosterInitDefaults() {
      if (rosterMonthEl && !rosterMonthEl.value) rosterMonthEl.value = rosterTodayYYYYMM();
      if (rosterShiftModelEl && !rosterShiftModelEl.value) rosterShiftModelEl.value = "12x36";
      if (rosterStartTimeEl && !rosterStartTimeEl.value) rosterStartTimeEl.value = "07:00";

      if (!rosterTeam.length) {
        rosterTeam = [rosterNewMember(), rosterNewMember(), rosterNewMember()];
      }
      rosterUpdateModelUI();
      rosterRenderOutput(null);
    }

    function rosterWireUI() {
      rosterAddPersonBtn?.addEventListener("click", () => {
        rosterTeam.push(rosterNewMember());
        rosterRenderTeam();
        rosterUpdateCoverageUI();
      });

      rosterBulkAddBtn?.addEventListener("click", rosterBulkAdd);

      rosterSaveConfigBtn?.addEventListener("click", rosterSaveConfig);
      rosterLoadConfigBtn?.addEventListener("click", rosterLoadConfig);

      rosterGenerateBtn?.addEventListener("click", rosterGenerateNow);

      rosterSaveScheduleBtn?.addEventListener("click", rosterSaveSchedule);
      rosterExportCsvBtn?.addEventListener("click", rosterDownloadCsv);
      rosterPrintBtn?.addEventListener("click", rosterPrint);

      rosterShiftModelEl?.addEventListener("change", rosterUpdateModelUI);
      rosterStartTimeEl?.addEventListener("change", rosterUpdateModelUI);

      rosterNeedPerShiftEl?.addEventListener("input", rosterUpdateCoverageUI);
      rosterNeedDayEl?.addEventListener("input", rosterUpdateCoverageUI);
      rosterNeedNightEl?.addEventListener("input", rosterUpdateCoverageUI);
      rosterNeedAfternoonEl?.addEventListener("input", rosterUpdateCoverageUI);
      rosterMaxConsecNightsEl?.addEventListener("input", rosterUpdateCoverageUI);

      rosterHelpBtn?.addEventListener("click", () => {
        rosterHelpDrawer?.classList.toggle("hidden");
      });
      closeRosterHelpBtn?.addEventListener("click", () => {
        rosterHelpDrawer?.classList.add("hidden");
      });
    }

    try {
      rosterInitDefaults();
      rosterWireUI();
    } catch {}



    // ============================
    // Documentos Médicos (consulta completa -> documento) via /api/gerar-documento-medico
    // ============================

    let medicalDocsRecordBtn = null;
    let medicalDocsPauseBtn = null;
    let medicalDocsTimerEl = null;
    let medicalDocsMicStatus = null;
    let medicalDocsError = null;
    let medicalDocsOutput = null;
    let medicalDocsTypeDetected = null;
    let medicalDocsMissingFields = null;
    let copyMedicalDocsBtn = null;
    let printMedicalDocsBtn = null;

    function medicalDocsUpdateCopyPrintVisibility() {
      const hasText = !!(medicalDocsOutput && String(medicalDocsOutput.value || "").trim());
      if (copyMedicalDocsBtn) copyMedicalDocsBtn.classList.toggle("hidden", !hasText);
      if (printMedicalDocsBtn) printMedicalDocsBtn.classList.toggle("hidden", !hasText);
    }

    function medicalDocsBindElementsAndWire() {
      medicalDocsRecordBtn = document.getElementById("medicalDocsRecordBtn");
      medicalDocsPauseBtn = document.getElementById("medicalDocsPauseBtn");
      medicalDocsTimerEl = document.getElementById("medicalDocsTimer");
      medicalDocsMicStatus = document.getElementById("medicalDocsMicStatus");
      medicalDocsError = document.getElementById("medicalDocsError");
      medicalDocsOutput = document.getElementById("medicalDocsOutput");
      medicalDocsTypeDetected = document.getElementById("medicalDocsTypeDetected");
      medicalDocsMissingFields = document.getElementById("medicalDocsMissingFields");
      copyMedicalDocsBtn = document.getElementById("copyMedicalDocsBtn");
      printMedicalDocsBtn = document.getElementById("printMedicalDocsBtn");

      medicalDocsUpdateCopyPrintVisibility();
      if (medicalDocsOutput) medicalDocsOutput.addEventListener("input", medicalDocsUpdateCopyPrintVisibility);

      const medicalDocsGuideBtn = document.getElementById("medicalDocsGuideBtn");
      const medicalDocsGuidePanel = document.getElementById("medicalDocsGuidePanel");
      const closeMedicalDocsGuideBtn = document.getElementById("closeMedicalDocsGuideBtn");

      if (medicalDocsGuideBtn) {
        medicalDocsGuideBtn.addEventListener("click", () => {
          setPanelVisible(medicalDocsGuidePanel, true);
        });
      }
      if (closeMedicalDocsGuideBtn) {
        closeMedicalDocsGuideBtn.addEventListener("click", () => {
          setPanelVisible(medicalDocsGuidePanel, false);
        });
      }


      if (medicalDocsRecordBtn) {
        medicalDocsRecordBtn.addEventListener("click", () => {
          if (!medicalDocsIsRecording) startMedicalDocsRecording();
          else stopMedicalDocsRecordingAndGenerate();
        });
      }

      if (medicalDocsPauseBtn) {
        medicalDocsPauseBtn.addEventListener("click", () => {
          if (!medicalDocsIsRecording) return;
          if (!medicalDocsIsPaused) pauseMedicalDocsRecording();
          else resumeMedicalDocsRecording();
        });
      }

      if (copyMedicalDocsBtn) {
        copyMedicalDocsBtn.addEventListener("click", () => {
          const txt = medicalDocsOutput ? String(medicalDocsOutput.value || "").trim() : "";
          if (!txt) return;
          copyToClipboard(txt);
        });
      }

      if (printMedicalDocsBtn) {
        printMedicalDocsBtn.addEventListener("click", () => {
          const txt = medicalDocsOutput ? String(medicalDocsOutput.value || "").trim() : "";
          const title = medicalDocsTypeDetected ? String(medicalDocsTypeDetected.textContent || "").trim() : "Documento";
          printTextBlock(title || "Documento", txt);
        });
      }
    }

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", medicalDocsBindElementsAndWire);
    } else {
      medicalDocsBindElementsAndWire();
    }


    let medicalDocsRecognition = null;
    let medicalDocsIsRecording = false;
    let medicalDocsIsPaused = false;
    let medicalDocsFinalTranscript = "";
    let medicalDocsTimerInterval = null;
    let medicalDocsStartTime = null;
    let medicalDocsAccumulatedSeconds = 0;

    let medicalDocsLivePollInterval = null;

    function medicalDocsResetTimer() {
      medicalDocsStartTime = null;
      medicalDocsAccumulatedSeconds = 0;
      if (medicalDocsTimerInterval) clearInterval(medicalDocsTimerInterval);
      medicalDocsTimerInterval = null;
      if (medicalDocsTimerEl) medicalDocsTimerEl.textContent = "00:00";
    }

    function medicalDocsStartTimer() {
      if (medicalDocsTimerInterval) clearInterval(medicalDocsTimerInterval);
      medicalDocsStartTime = new Date();
      medicalDocsTimerInterval = setInterval(() => {
        const now = new Date();
        const delta = Math.floor((now - medicalDocsStartTime) / 1000);
        const total = medicalDocsAccumulatedSeconds + delta;
        const mm = String(Math.floor(total / 60)).padStart(2, "0");
        const ss = String(total % 60).padStart(2, "0");
        if (medicalDocsTimerEl) medicalDocsTimerEl.textContent = `${mm}:${ss}`;
      }, 1000);
    }

    function medicalDocsPauseTimer() {
      if (!medicalDocsStartTime) return;
      const now = new Date();
      const delta = Math.floor((now - medicalDocsStartTime) / 1000);
      medicalDocsAccumulatedSeconds += delta;
      medicalDocsStartTime = null;
      if (medicalDocsTimerInterval) clearInterval(medicalDocsTimerInterval);
      medicalDocsTimerInterval = null;
    }

    function initMedicalDocsSpeechRecognition() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        if (medicalDocsError) medicalDocsError.textContent = "Seu navegador não suporta reconhecimento de voz. Use Chrome no computador ou Android.";
        return false;
      }

      medicalDocsRecognition = new SR();
      medicalDocsRecognition.continuous = true;
      medicalDocsRecognition.interimResults = true;
      medicalDocsRecognition.lang = "pt-BR";

      medicalDocsRecognition.onresult = (event) => {
        let interim = "";
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript || "";
          if (event.results[i].isFinal) medicalDocsFinalTranscript += transcript + " ";
          else interim += transcript;
        }

        // Atualiza guia em tempo real a partir do acumulado
        const combined = (medicalDocsFinalTranscript + " " + interim).trim();
        if (combined.length >= 30) {
          updateMedicalDocsLiveGuide(combined);
        }
      };

      medicalDocsRecognition.onerror = (event) => {
        const msg = (event && event.error) ? String(event.error) : "erro";
        if (medicalDocsError) medicalDocsError.textContent = "Falha no microfone/reconhecimento de voz: " + msg;
      };

      medicalDocsRecognition.onend = () => {
        if (medicalDocsIsRecording && !medicalDocsIsPaused) {
          try { medicalDocsRecognition.start(); } catch (e) {}
        }
      };

      return true;
    }

    async function updateMedicalDocsLiveGuide(transcricaoParcial) {
      // Evita spam no backend; o polling abaixo já chama, mas mantemos também esta atualização por evento
      // e o backend é leve (8k chars).
      try {
        const resp = await fetch(BACKEND_URL + "/api/documento-medico-tempo-real", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao: transcricaoParcial })
        });
        if (!resp.ok) return;
        const data = await resp.json();
        const tipo = data && data.tipo_documento ? String(data.tipo_documento) : "";
        const perguntas = Array.isArray(data?.perguntas) ? data.perguntas : [];
        const gatilho = !!data?.gatilho;

        if (medicalDocsTypeDetected) medicalDocsTypeDetected.textContent = tipo ? tipo : "não informado";
        if (medicalDocsMissingFields) {
          medicalDocsMissingFields.textContent = (perguntas && perguntas.length)
            ? perguntas.join("\n")
            : (gatilho ? "Sem perguntas adicionais no momento." : "Sem indício claro de documento ainda.");
        }
      } catch (e) {}
    }

    function startMedicalDocsLivePolling() {
      stopMedicalDocsLivePolling();
      medicalDocsLivePollInterval = setInterval(() => {
        const partial = (medicalDocsFinalTranscript || "").trim();
        if (partial.length < 30) return;
        updateMedicalDocsLiveGuide(partial);
      }, 4000);
    }

    function stopMedicalDocsLivePolling() {
      if (medicalDocsLivePollInterval) clearInterval(medicalDocsLivePollInterval);
      medicalDocsLivePollInterval = null;
    }

    function startMedicalDocsRecording() {
      if (medicalDocsIsRecording) return;
      if (medicalDocsError) medicalDocsError.textContent = "";
      if (!medicalDocsRecognition) {
        const ok = initMedicalDocsSpeechRecognition();
        if (!ok) return;
      }

      medicalDocsIsRecording = true;
      medicalDocsIsPaused = false;
      medicalDocsFinalTranscript = "";

      if (medicalDocsOutput) medicalDocsOutput.value = "";
      medicalDocsUpdateCopyPrintVisibility();
      if (medicalDocsTypeDetected) medicalDocsTypeDetected.textContent = "";
      if (medicalDocsMissingFields) medicalDocsMissingFields.textContent = "";

      if (medicalDocsMicStatus) medicalDocsMicStatus.textContent = "Gravando consulta para documento médico...";
      if (medicalDocsTimerEl) medicalDocsTimerEl.classList.remove("hidden");

      if (medicalDocsPauseBtn) {
        medicalDocsPauseBtn.style.display = "inline-block";
        medicalDocsPauseBtn.innerText = "Pausar";
      }
      if (medicalDocsRecordBtn) {
        medicalDocsRecordBtn.className = "small-record-btn recording";
        medicalDocsRecordBtn.innerText = "Encerrar gravação";
      }

      // Bloqueia outros módulos durante a gravação
      if (recordBtn) recordBtn.disabled = true;
      if (triageRecordBtn) triageRecordBtn.disabled = true;
      if (docsRecordBtn) docsRecordBtn.disabled = true;
      if (handoffRecordBtn) handoffRecordBtn.disabled = true;
      if (reportRecordBtn) reportRecordBtn.disabled = true;

      medicalDocsResetTimer();
      medicalDocsStartTimer();
      startMedicalDocsLivePolling();

      try { medicalDocsRecognition.start(); } catch (e) {}
    }

    function pauseMedicalDocsRecording() {
      if (!medicalDocsIsRecording || medicalDocsIsPaused) return;
      medicalDocsIsPaused = true;
      stopMedicalDocsLivePolling();

      if (medicalDocsRecognition) {
        try { medicalDocsRecognition.stop(); } catch (e) {}
      }
      medicalDocsPauseTimer();

      if (medicalDocsPauseBtn) medicalDocsPauseBtn.innerText = "Retomar";
      if (medicalDocsMicStatus) medicalDocsMicStatus.innerText = "Gravação pausada.";
    }

    function resumeMedicalDocsRecording() {
      if (!medicalDocsIsRecording || !medicalDocsIsPaused) return;
      medicalDocsIsPaused = false;

      startMedicalDocsLivePolling();

      if (medicalDocsRecognition) {
        try { medicalDocsRecognition.start(); } catch (e) {}
      }
      medicalDocsStartTimer();

      if (medicalDocsPauseBtn) medicalDocsPauseBtn.innerText = "Pausar";
      if (medicalDocsMicStatus) medicalDocsMicStatus.innerText = "Gravando consulta para documento médico...";
    }

    async function stopMedicalDocsRecordingAndGenerate() {
      if (!medicalDocsIsRecording) return;

      medicalDocsIsRecording = false;
      medicalDocsIsPaused = false;

      stopMedicalDocsLivePolling();

      if (medicalDocsRecognition) {
        try { medicalDocsRecognition.stop(); } catch (e) {}
      }

      medicalDocsPauseTimer();

      if (medicalDocsRecordBtn) {
        medicalDocsRecordBtn.className = "small-record-btn start";
        medicalDocsRecordBtn.innerText = "Gerar documentos";
      }
      if (medicalDocsPauseBtn) medicalDocsPauseBtn.style.display = "none";

      if (recordBtn) recordBtn.disabled = false;
      if (triageRecordBtn) triageRecordBtn.disabled = false;
      if (docsRecordBtn) docsRecordBtn.disabled = false;
      if (handoffRecordBtn) handoffRecordBtn.disabled = false;
      if (reportRecordBtn) reportRecordBtn.disabled = false;

      const txt = (medicalDocsFinalTranscript || "").trim();
      if (!txt || txt.length < 40) {
        if (medicalDocsError) medicalDocsError.textContent = "A transcrição ficou muito curta. Tente novamente, falando mais próximo ao microfone.";
        if (medicalDocsMicStatus) medicalDocsMicStatus.textContent = "Pronto.";
        return;
      }

      if (medicalDocsMicStatus) medicalDocsMicStatus.textContent = "Gerando documento médico...";
      if (medicalDocsRecordBtn) medicalDocsRecordBtn.disabled = true;

      try {
        const resp = await fetch(BACKEND_URL + "/api/gerar-documento-medico", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ transcricao: txt })
        });

        if (!resp.ok) {
          const raw = await resp.text().catch(() => "");
          console.error("Erro HTTP do backend (documento médico):", resp.status, raw);
          if (medicalDocsError) medicalDocsError.textContent = "Não foi possível gerar o documento médico.";
          if (medicalDocsMicStatus) medicalDocsMicStatus.textContent = "Pronto.";
          return;
        }

        const data = await resp.json();
        const tipo = data?.tipo_documento ? String(data.tipo_documento) : "";
        const campos = Array.isArray(data?.campos_pendentes) ? data.campos_pendentes : [];
        const documento = data?.documento ? String(data.documento) : "";

        if (medicalDocsTypeDetected) medicalDocsTypeDetected.textContent = tipo || "não informado";
        if (medicalDocsMissingFields) medicalDocsMissingFields.textContent = (campos && campos.length) ? campos.join("\n") : "Sem pendências.";
        if (medicalDocsOutput) medicalDocsOutput.value = normalizeNumberedParagraphs(documento || "");
        medicalDocsUpdateCopyPrintVisibility();

        if (medicalDocsMicStatus) medicalDocsMicStatus.textContent = "Documento médico gerado.";
      } catch (err) {
        console.error("Erro ao gerar documento médico:", err);
        if (medicalDocsError) medicalDocsError.textContent = "Erro ao gerar documento médico.";
        if (medicalDocsMicStatus) medicalDocsMicStatus.textContent = "Pronto.";
      } finally {
        if (medicalDocsRecordBtn) medicalDocsRecordBtn.disabled = false;
      }
    }

    if (medicalDocsRecordBtn) {
      medicalDocsRecordBtn.addEventListener("click", () => {
        if (!medicalDocsIsRecording) startMedicalDocsRecording();
        else stopMedicalDocsRecordingAndGenerate();
      });
    }

    if (medicalDocsPauseBtn) {
      medicalDocsPauseBtn.addEventListener("click", () => {
        if (!medicalDocsIsRecording) return;
        if (!medicalDocsIsPaused) pauseMedicalDocsRecording();
        else resumeMedicalDocsRecording();
      });
    }

    if (copyMedicalDocsBtn) {
      copyMedicalDocsBtn.addEventListener("click", () => {
        const txt = medicalDocsOutput ? String(medicalDocsOutput.value || "").trim() : "";
        if (!txt) return;
        copyToClipboard(txt);
      });
    }

    function printTextBlock(title, text) {
      const t = String(text || "").trim();
      if (!t) return;
      const w = window.open("", "_blank");
      if (!w) return;
      const safeTitle = String(title || "Documento").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      const safe = t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "<br/>");
      w.document.write(`<html><head><title>${safeTitle}</title></head><body style="font-family: Arial, sans-serif; font-size: 13px; line-height: 1.45; padding: 18px;"><h2 style="margin:0 0 12px 0;">${safeTitle}</h2><div>${safe}</div></body></html>`);
      w.document.close();
      w.focus();
      w.print();
    }

    if (printMedicalDocsBtn) {
      printMedicalDocsBtn.addEventListener("click", () => {
        const txt = medicalDocsOutput ? String(medicalDocsOutput.value || "").trim() : "";
        const title = medicalDocsTypeDetected ? String(medicalDocsTypeDetected.textContent || "").trim() : "Documento";
        printTextBlock(title || "Documento", txt);
      });
    }

</script>

<div id="postLoginOnlyModules" class="hidden">

  <div class="module-divider"></div>

  <div id="medicalDocsCard" class="module-card">
    <div class="section-header-row">
      <h2>Geração de documentos</h2>
      <button id="medicalDocsGuideBtn" class="btn-print guide-main-btn" type="button">Guia</button>
    </div>

    <div class="inline-input-row" style="margin-top: 6px;">
      <button id="medicalDocsRecordBtn" class="small-record-btn start" type="button">Gerar documentos</button>
      <button id="medicalDocsPauseBtn" class="pause-btn" type="button" style="display:none;">Pausar</button>
    </div>

    <div id="medicalDocsTimer" class="mini-timer hidden">00:00</div>
    <div id="medicalDocsMicStatus" class="mini-status">Clique em "Gerar documentos" para começar.</div>
    <div id="medicalDocsError" class="error-text"></div>

    <div class="inline-input-row" style="margin-top: 10px;">
      <div style="flex: 1; min-width: 240px;">
        <div style="font-size: 12px; font-weight: 700; color: #111827; margin-bottom: 4px;">Tipo identificado</div>
        <div id="medicalDocsTypeDetected" class="answer-box" style="min-height: 44px;"></div>
      </div>
      <div style="flex: 1; min-width: 240px;">
        <div style="font-size: 12px; font-weight: 700; color: #111827; margin-bottom: 4px;">Perguntas/itens pendentes</div>
        <div id="medicalDocsMissingFields" class="answer-box" style="min-height: 44px;"></div>
      </div>
    </div>

    <textarea id="medicalDocsOutput" class="prescription-textarea" placeholder="O documento médico gerado aparecerá aqui." style="margin-top: 12px;"></textarea>

    <div class="prescription-actions">
      <button id="copyMedicalDocsBtn" class="btn-copy hidden" type="button">Copiar</button>
      <button id="printMedicalDocsBtn" class="btn-print hidden" type="button">Imprimir</button>
    </div>
  </div>
</div>

<div class="whatsapp-fab-label">
<div class="wa-label-title">WhatsApp</div><div class="wa-label-sub">Dúvidas, reportar erros, sugestões, melhorias</div></div>
  <a
    class="whatsapp-fab"
    href="https://wa.me/5575981457012?text=Ol%C3%A1%21%20Gostaria%20de%20reportar%20um%20erro%2C%20tirar%20uma%20d%C3%BAvida%20ou%20enviar%20uma%20sugest%C3%A3o."
    target="_blank"
    rel="noopener"
    aria-label="Entrar em contato pelo WhatsApp"
    title="Dúvidas, reportar erros, sugestões, melhorias"
  >
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M19.5 14.5c-.7 0-1.4-.1-2.1-.3a1 1 0 0 0-1 .2l-1.3 1.3a13.1 13.1 0 0 1-5.8-5.8l1.3-1.3a1 1 0 0 0 .2-1c-.2-.7-.3-1.4-.3-2.1a1 1 0 0 0-1-1H6.5a1 1 0 0 0-1 1c0 6.1 4.9 11 11 11a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1z"></path>
    </svg>
  </a>

</body>
</html>